(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.AccountsSDK = factory());
}(this, (function () { 'use strict';

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  var errors = {
    extend: function extend(error) {
      if (error.oauth_exception && this.oauth_exception[error.oauth_exception]) {
        return Object.assign(error, {
          description: this.oauth_exception[error.oauth_exception]
        });
      }

      if (error.identity_exception && this.identity_exception[error.identity_exception]) {
        return Object.assign(error, {
          description: this.identity_exception[error.identity_exception]
        });
      }

      return error;
    },
    oauth_exception: {
      invalid_request: 'You may be loading accounts-sdk on a domain that is not whitelisted.',
      unauthorized_client: 'Client not found, not provided or incorectly configured.',
      access_denied: 'Probably this application is installed on a different account and you do not have access to it.',
      unsupported_response_type: 'Provided response type is incorrect or unavailable for a given client.'
    },
    identity_exception: {
      unauthorized: 'Resource owner identity is not known or consent is missing.'
    }
  };

  var Listener = /*#__PURE__*/function () {
    function Listener() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, Listener);

      this.options = options;
      this.listening = false;
      this.receiveMessage = this.receiveMessage.bind(this);
    }

    _createClass(Listener, [{
      key: "start",
      value: function start(timeout, callback) {
        var _this = this;

        if (this._listenerInited) {
          return;
        }

        this.listening = true;
        this.callback = callback;

        if (timeout) {
          this.tid = setTimeout(function () {
            _this.stop();

            callback('timeout', null);
          }, timeout);
        }

        window.addEventListener('message', this.receiveMessage);
      }
    }, {
      key: "stop",
      value: function stop() {
        this.listening = false;
        clearTimeout(this.tid);
        window.removeEventListener('message', this.receiveMessage, false);
      }
    }, {
      key: "receiveMessage",
      value: function receiveMessage(event) {
        if (event.origin !== this.options.server_url && event.origin !== this.options.server_url.replace(/livechat\.com$/, 'livechatinc.com')) {
          return;
        }

        if (!event.data.data && !event.data.error) {
          return;
        }

        this.stop();

        if (event.data.error) {
          this.callback(errors.extend(event.data.error), null);
        } else {
          if (event.data.data.scopes) {
            event.data.data.scope = event.data.data.scopes;
            delete event.data.data.scopes;
          }

          if (event.data.data.expires_in) {
            event.data.data.expires_in = parseInt(event.data.data.expires_in) || 0;
          }

          this.callback(null, event.data.data);
        }
      }
    }]);

    return Listener;
  }();

  /**
   * Class for authentication using popup.
   */

  var Popup = /*#__PURE__*/function () {
    // eslint-disable-next-line require-jsdoc
    function Popup(sdk, options) {
      _classCallCheck(this, Popup);

      this.options = options;
      this.sdk = sdk;
    }
    /**
     * run popup authorization flow, should be called in a click handler to avoid beeing blocked
     * @return {Promise} promise that resolves to authorize data or error
     */


    _createClass(Popup, [{
      key: "authorize",
      value: function authorize() {
        var _this = this;

        return new Promise(function (resolve, reject) {
          var url = _this.sdk.authorizeURL(_this.options, 'button');

          var w = 500;
          var h = 650;
          var left = window.screen.width / 2 - w / 2;
          var top = window.screen.height / 2 - h / 2;
          var listener = new Listener(_this.options);
          listener.start(null, function (err, authorizeData) {
            if (err) {
              return reject(err);
            }

            resolve(authorizeData);
          });

          var open = function open() {
            window.open(url, 'livechat-login-popup', "resizable,scrollbars,width=".concat(w, ",height=").concat(h, ",left=").concat(left, ",top=").concat(top));
          };

          if (document.requestStorageAccess) {
            var promise = document.requestStorageAccess();
            promise.then(open, open);
          } else {
            open();
          }
        });
      }
    }]);

    return Popup;
  }();

  var has = Object.prototype.hasOwnProperty;
  var isArray = Array.isArray;

  var hexTable = function () {
    var array = [];

    for (var i = 0; i < 256; ++i) {
      array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
  }();

  var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
      var item = queue.pop();
      var obj = item.obj[item.prop];

      if (isArray(obj)) {
        var compacted = [];

        for (var j = 0; j < obj.length; ++j) {
          if (typeof obj[j] !== 'undefined') {
            compacted.push(obj[j]);
          }
        }

        item.obj[item.prop] = compacted;
      }
    }
  };

  var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};

    for (var i = 0; i < source.length; ++i) {
      if (typeof source[i] !== 'undefined') {
        obj[i] = source[i];
      }
    }

    return obj;
  };

  var merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */
    if (!source) {
      return target;
    }

    if (_typeof(source) !== 'object') {
      if (isArray(target)) {
        target.push(source);
      } else if (target && _typeof(target) === 'object') {
        if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
          target[source] = true;
        }
      } else {
        return [target, source];
      }

      return target;
    }

    if (!target || _typeof(target) !== 'object') {
      return [target].concat(source);
    }

    var mergeTarget = target;

    if (isArray(target) && !isArray(source)) {
      mergeTarget = arrayToObject(target, options);
    }

    if (isArray(target) && isArray(source)) {
      source.forEach(function (item, i) {
        if (has.call(target, i)) {
          var targetItem = target[i];

          if (targetItem && _typeof(targetItem) === 'object' && item && _typeof(item) === 'object') {
            target[i] = merge(targetItem, item, options);
          } else {
            target.push(item);
          }
        } else {
          target[i] = item;
        }
      });
      return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
      var value = source[key];

      if (has.call(acc, key)) {
        acc[key] = merge(acc[key], value, options);
      } else {
        acc[key] = value;
      }

      return acc;
    }, mergeTarget);
  };

  var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
      acc[key] = source[key];
      return acc;
    }, target);
  };

  var decode = function decode(str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');

    if (charset === 'iso-8859-1') {
      // unescape never throws, no try...catch needed:
      return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    } // utf-8


    try {
      return decodeURIComponent(strWithoutPlus);
    } catch (e) {
      return strWithoutPlus;
    }
  };

  var encode = function encode(str, defaultEncoder, charset) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
      return str;
    }

    var string = str;

    if (_typeof(str) === 'symbol') {
      string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
      string = String(str);
    }

    if (charset === 'iso-8859-1') {
      return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
        return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
      });
    }

    var out = '';

    for (var i = 0; i < string.length; ++i) {
      var c = string.charCodeAt(i);

      if (c === 0x2D // -
      || c === 0x2E // .
      || c === 0x5F // _
      || c === 0x7E // ~
      || c >= 0x30 && c <= 0x39 // 0-9
      || c >= 0x41 && c <= 0x5A // a-z
      || c >= 0x61 && c <= 0x7A // A-Z
      ) {
          out += string.charAt(i);
          continue;
        }

      if (c < 0x80) {
        out = out + hexTable[c];
        continue;
      }

      if (c < 0x800) {
        out = out + (hexTable[0xC0 | c >> 6] + hexTable[0x80 | c & 0x3F]);
        continue;
      }

      if (c < 0xD800 || c >= 0xE000) {
        out = out + (hexTable[0xE0 | c >> 12] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F]);
        continue;
      }

      i += 1;
      c = 0x10000 + ((c & 0x3FF) << 10 | string.charCodeAt(i) & 0x3FF);
      out += hexTable[0xF0 | c >> 18] + hexTable[0x80 | c >> 12 & 0x3F] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F];
    }

    return out;
  };

  var compact = function compact(value) {
    var queue = [{
      obj: {
        o: value
      },
      prop: 'o'
    }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
      var item = queue[i];
      var obj = item.obj[item.prop];
      var keys = Object.keys(obj);

      for (var j = 0; j < keys.length; ++j) {
        var key = keys[j];
        var val = obj[key];

        if (_typeof(val) === 'object' && val !== null && refs.indexOf(val) === -1) {
          queue.push({
            obj: obj,
            prop: key
          });
          refs.push(val);
        }
      }
    }

    compactQueue(queue);
    return value;
  };

  var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
  };

  var isBuffer = function isBuffer(obj) {
    if (!obj || _typeof(obj) !== 'object') {
      return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
  };

  var combine = function combine(a, b) {
    return [].concat(a, b);
  };

  var maybeMap = function maybeMap(val, fn) {
    if (isArray(val)) {
      var mapped = [];

      for (var i = 0; i < val.length; i += 1) {
        mapped.push(fn(val[i]));
      }

      return mapped;
    }

    return fn(val);
  };

  var utils = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    maybeMap: maybeMap,
    merge: merge
  };

  var replace = String.prototype.replace;
  var percentTwenties = /%20/g;
  var Format = {
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
  };
  var formats = utils.assign({
    'default': Format.RFC3986,
    formatters: {
      RFC1738: function RFC1738(value) {
        return replace.call(value, percentTwenties, '+');
      },
      RFC3986: function RFC3986(value) {
        return String(value);
      }
    }
  }, Format);

  var has$1 = Object.prototype.hasOwnProperty;
  var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
      return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) {
      return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
      return prefix;
    }
  };
  var isArray$1 = Array.isArray;
  var push = Array.prototype.push;

  var pushToArray = function pushToArray(arr, valueOrArray) {
    push.apply(arr, isArray$1(valueOrArray) ? valueOrArray : [valueOrArray]);
  };

  var toISO = Date.prototype.toISOString;
  var defaultFormat = formats['default'];
  var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    charset: 'utf-8',
    charsetSentinel: false,
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
      return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
  };

  var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean' || _typeof(v) === 'symbol' || typeof v === 'bigint';
  };

  var stringify = function stringify(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly, charset) {
    var obj = object;

    if (typeof filter === 'function') {
      obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
      obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray$1(obj)) {
      obj = utils.maybeMap(obj, function (value) {
        if (value instanceof Date) {
          return serializeDate(value);
        }

        return value;
      }).join(',');
    }

    if (obj === null) {
      if (strictNullHandling) {
        return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key') : prefix;
      }

      obj = '';
    }

    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
      if (encoder) {
        var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key');
        return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value'))];
      }

      return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
      return values;
    }

    var objKeys;

    if (isArray$1(filter)) {
      objKeys = filter;
    } else {
      var keys = Object.keys(obj);
      objKeys = sort ? keys.sort(sort) : keys;
    }

    for (var i = 0; i < objKeys.length; ++i) {
      var key = objKeys[i];
      var value = obj[key];

      if (skipNulls && value === null) {
        continue;
      }

      var keyPrefix = isArray$1(obj) ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(prefix, key) : prefix : prefix + (allowDots ? '.' + key : '[' + key + ']');
      pushToArray(values, stringify(value, keyPrefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly, charset));
    }

    return values;
  };

  var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
      return defaults;
    }

    if (opts.encoder !== null && opts.encoder !== undefined && typeof opts.encoder !== 'function') {
      throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults.charset;

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
      throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats['default'];

    if (typeof opts.format !== 'undefined') {
      if (!has$1.call(formats.formatters, opts.format)) {
        throw new TypeError('Unknown format option provided.');
      }

      format = opts.format;
    }

    var formatter = formats.formatters[format];
    var filter = defaults.filter;

    if (typeof opts.filter === 'function' || isArray$1(opts.filter)) {
      filter = opts.filter;
    }

    return {
      addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
      allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
      charset: charset,
      charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
      delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
      encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
      encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
      encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
      filter: filter,
      formatter: formatter,
      serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
      skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
      sort: typeof opts.sort === 'function' ? opts.sort : null,
      strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
  };

  var stringify_1 = function stringify_1(object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);
    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
      filter = options.filter;
      obj = filter('', obj);
    } else if (isArray$1(options.filter)) {
      filter = options.filter;
      objKeys = filter;
    }

    var keys = [];

    if (_typeof(obj) !== 'object' || obj === null) {
      return '';
    }

    var arrayFormat;

    if (opts && opts.arrayFormat in arrayPrefixGenerators) {
      arrayFormat = opts.arrayFormat;
    } else if (opts && 'indices' in opts) {
      arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
      arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

    if (!objKeys) {
      objKeys = Object.keys(obj);
    }

    if (options.sort) {
      objKeys.sort(options.sort);
    }

    for (var i = 0; i < objKeys.length; ++i) {
      var key = objKeys[i];

      if (options.skipNulls && obj[key] === null) {
        continue;
      }

      pushToArray(keys, stringify(obj[key], key, generateArrayPrefix, options.strictNullHandling, options.skipNulls, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.formatter, options.encodeValuesOnly, options.charset));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
      if (options.charset === 'iso-8859-1') {
        // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
        prefix += 'utf8=%26%2310003%3B&';
      } else {
        // encodeURIComponent('✓')
        prefix += 'utf8=%E2%9C%93&';
      }
    }

    return joined.length > 0 ? prefix + joined : '';
  };

  var has$2 = Object.prototype.hasOwnProperty;
  var isArray$2 = Array.isArray;
  var defaults$1 = {
    allowDots: false,
    allowPrototypes: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictNullHandling: false
  };

  var interpretNumericEntities = function interpretNumericEntities(str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
      return String.fromCharCode(parseInt(numberStr, 10));
    });
  };

  var parseArrayValue = function parseArrayValue(val, options) {
    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
      return val.split(',');
    }

    return val;
  }; // This is what browsers will submit when the ✓ character occurs in an
  // application/x-www-form-urlencoded body and the encoding of the page containing
  // the form is iso-8859-1, or when the submitted form has an accept-charset
  // attribute of iso-8859-1. Presumably also with other charsets that do not contain
  // the ✓ character, such as us-ascii.


  var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')
  // These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.

  var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')

  var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found

    var i;
    var charset = options.charset;

    if (options.charsetSentinel) {
      for (i = 0; i < parts.length; ++i) {
        if (parts[i].indexOf('utf8=') === 0) {
          if (parts[i] === charsetSentinel) {
            charset = 'utf-8';
          } else if (parts[i] === isoSentinel) {
            charset = 'iso-8859-1';
          }

          skipIndex = i;
          i = parts.length; // The eslint settings do not allow break;
        }
      }
    }

    for (i = 0; i < parts.length; ++i) {
      if (i === skipIndex) {
        continue;
      }

      var part = parts[i];
      var bracketEqualsPos = part.indexOf(']=');
      var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;
      var key, val;

      if (pos === -1) {
        key = options.decoder(part, defaults$1.decoder, charset, 'key');
        val = options.strictNullHandling ? null : '';
      } else {
        key = options.decoder(part.slice(0, pos), defaults$1.decoder, charset, 'key');
        val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options), function (encodedVal) {
          return options.decoder(encodedVal, defaults$1.decoder, charset, 'value');
        });
      }

      if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
        val = interpretNumericEntities(val);
      }

      if (part.indexOf('[]=') > -1) {
        val = isArray$2(val) ? [val] : val;
      }

      if (has$2.call(obj, key)) {
        obj[key] = utils.combine(obj[key], val);
      } else {
        obj[key] = val;
      }
    }

    return obj;
  };

  var parseObject = function parseObject(chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);

    for (var i = chain.length - 1; i >= 0; --i) {
      var obj;
      var root = chain[i];

      if (root === '[]' && options.parseArrays) {
        obj = [].concat(leaf);
      } else {
        obj = options.plainObjects ? Object.create(null) : {};
        var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
        var index = parseInt(cleanRoot, 10);

        if (!options.parseArrays && cleanRoot === '') {
          obj = {
            0: leaf
          };
        } else if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit) {
          obj = [];
          obj[index] = leaf;
        } else {
          obj[cleanRoot] = leaf;
        }
      }

      leaf = obj; // eslint-disable-line no-param-reassign
    }

    return leaf;
  };

  var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
      return;
    } // Transform dot notation to bracket notation


    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey; // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g; // Get the parent

    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key; // Stash the parent if it exists

    var keys = [];

    if (parent) {
      // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
      if (!options.plainObjects && has$2.call(Object.prototype, parent)) {
        if (!options.allowPrototypes) {
          return;
        }
      }

      keys.push(parent);
    } // Loop through children appending to the array until we hit depth


    var i = 0;

    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
      i += 1;

      if (!options.plainObjects && has$2.call(Object.prototype, segment[1].slice(1, -1))) {
        if (!options.allowPrototypes) {
          return;
        }
      }

      keys.push(segment[1]);
    } // If there's a remainder, just add whatever is left


    if (segment) {
      keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options, valuesParsed);
  };

  var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
      return defaults$1;
    }

    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {
      throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
      throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var charset = typeof opts.charset === 'undefined' ? defaults$1.charset : opts.charset;
    return {
      allowDots: typeof opts.allowDots === 'undefined' ? defaults$1.allowDots : !!opts.allowDots,
      allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults$1.allowPrototypes,
      arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults$1.arrayLimit,
      charset: charset,
      charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults$1.charsetSentinel,
      comma: typeof opts.comma === 'boolean' ? opts.comma : defaults$1.comma,
      decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults$1.decoder,
      delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults$1.delimiter,
      // eslint-disable-next-line no-implicit-coercion, no-extra-parens
      depth: typeof opts.depth === 'number' || opts.depth === false ? +opts.depth : defaults$1.depth,
      ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
      interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults$1.interpretNumericEntities,
      parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults$1.parameterLimit,
      parseArrays: opts.parseArrays !== false,
      plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults$1.plainObjects,
      strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults$1.strictNullHandling
    };
  };

  var parse = function parse(str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
      return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {}; // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);

    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];
      var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
      obj = utils.merge(obj, newObj, options);
    }

    return utils.compact(obj);
  };

  var lib = {
    formats: formats,
    parse: parse,
    stringify: stringify_1
  };

  /* eslint-disable require-jsdoc */

  /** @fileOverview
   * @author Auth0 https://github.com/auth0/auth0.js
   * @license MIT
   */
  function pick(object, keys) {
    return keys.reduce(function (prev, key) {
      if (object[key]) {
        prev[key] = object[key];
      }

      return prev;
    }, {});
  }

  var Redirect = /*#__PURE__*/function () {
    // eslint-disable-next-line require-jsdoc
    function Redirect(sdk, options) {
      _classCallCheck(this, Redirect);

      this.options = options;
      this.sdk = sdk;
    }
    /**
     * run default authorization flow
     */


    _createClass(Redirect, [{
      key: "authorize",
      value: function authorize() {
        var url = this.sdk.authorizeURL(this.options);
        window.location = url;
      }
      /**
       * this function checks if the current origin was redirected to with authorize data
       * @return {Promise} promise that resolves to authorize data or error
       */

    }, {
      key: "authorizeData",
      value: function authorizeData() {
        var _this = this;

        return new Promise(function (resolve, reject) {
          var authorizeData = {};
          var requiredFields = [];

          switch (_this.options.response_type) {
            case 'token':
              requiredFields = ['access_token', 'expires_in', 'token_type'];
              authorizeData = lib.parse(window.location.hash.substring(1));
              authorizeData = pick(authorizeData, ['access_token', 'expires_in', 'state', 'scope', 'token_type']);

              if (!requiredFields.every(function (field) {
                return authorizeData.hasOwnProperty(field);
              })) {
                reject(errors.extend({
                  identity_exception: 'unauthorized'
                }));
                return;
              }

              authorizeData.expires_in = parseInt(authorizeData.expires_in);
              break;

            case 'code':
              requiredFields = ['code'];
              authorizeData = lib.parse(window.location.search, {
                ignoreQueryPrefix: true
              });
              authorizeData = pick(authorizeData, ['state', 'code']);

              if (!requiredFields.every(function (field) {
                return authorizeData.hasOwnProperty(field);
              })) {
                reject(errors.extend({
                  identity_exception: 'unauthorized'
                }));
                return;
              }

          }

          resolve(authorizeData);
        });
      }
    }]);

    return Redirect;
  }();

  /**
   * Class for authentication using Iframe
   */

  var Iframe = /*#__PURE__*/function () {
    // eslint-disable-next-line require-jsdoc
    function Iframe(sdk, options) {
      _classCallCheck(this, Iframe);

      this.options = options;
      this.sdk = sdk;
    }
    /**
     * run iframe authorization flow, not recommended because of ITP 2.0
     * @return {Promise} promise that resolves to authorize data or error
     */


    _createClass(Iframe, [{
      key: "authorize",
      value: function authorize() {
        var _this = this;

        return new Promise(function (resolve, reject) {
          var url = _this.sdk.authorizeURL(_this.options, 'button');

          var listener = new Listener(_this.options);

          var cb = function cb(err, authorizeData) {
            _this.removeIframe();

            if (err) {
              return reject(err);
            }

            resolve(authorizeData);
          };

          listener.start(5000, cb);
          var iframe = document.createElement('iframe');
          iframe.setAttribute('src', url);
          iframe.setAttribute('id', _this.iframeID());
          iframe.style.width = '1px';
          iframe.style.height = '1px';
          iframe.style.position = 'fixed';
          iframe.style.top = '0';
          iframe.style.right = '0';
          iframe.style.opacity = '0';
          iframe.style.visibility = 'none';
          document.body.appendChild(iframe);
        });
      } // eslint-disable-next-line require-jsdoc

    }, {
      key: "iframeID",
      value: function iframeID() {
        return this.options.client_id + this.options.response_type;
      } // eslint-disable-next-line require-jsdoc

    }, {
      key: "removeIframe",
      value: function removeIframe() {
        var ref = document.getElementById(this.iframeID());

        if (ref && ref.parentNode) {
          ref.parentNode.removeChild(ref);
        }
      }
    }]);

    return Iframe;
  }();

  /* eslint-disable require-jsdoc */

  /** @fileOverview
   * @author Auth0 https://github.com/auth0/auth0.js
   * @license MIT
   */
  function string(length) {
    var bytes = new Uint8Array(length);
    var result = [];
    var charset = '0123456789ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvwxyz-._~';
    var cryptoObj = window.crypto || window.msCrypto;
    var random = '';

    if (!cryptoObj) {
      for (var i = 0; i < length; i++) {
        random += charset.charAt(Math.floor(Math.random() * charset.length));
      }
    } else {
      random = cryptoObj.getRandomValues(bytes);
    }

    for (var a = 0; a < random.length; a++) {
      result.push(charset[random[a] % charset.length]);
    }

    return result.join('');
  }

  var random = {
    string: string
  };

  /* eslint-disable require-jsdoc */

  /** @fileOverview
   * @author Auth0 https://github.com/auth0/auth0.js
   * @license MIT
   */
  function DummyStorage() {}

  DummyStorage.prototype.getItem = function () {
    return null;
  };

  DummyStorage.prototype.removeItem = function () {};

  DummyStorage.prototype.setItem = function () {};

  function createCommonjsModule(fn, basedir, module) {
  	return module = {
  	  path: basedir,
  	  exports: {},
  	  require: function (path, base) {
        return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
      }
  	}, fn(module, module.exports), module.exports;
  }

  function commonjsRequire () {
  	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
  }

  var js_cookie = createCommonjsModule(function (module, exports) {

    (function (factory) {
      var registeredInModuleLoader;

      {
        module.exports = factory();
        registeredInModuleLoader = true;
      }

      if (!registeredInModuleLoader) {
        var OldCookies = window.Cookies;
        var api = window.Cookies = factory();

        api.noConflict = function () {
          window.Cookies = OldCookies;
          return api;
        };
      }
    })(function () {
      function extend() {
        var i = 0;
        var result = {};

        for (; i < arguments.length; i++) {
          var attributes = arguments[i];

          for (var key in attributes) {
            result[key] = attributes[key];
          }
        }

        return result;
      }

      function decode(s) {
        return s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);
      }

      function init(converter) {
        function api() {}

        function set(key, value, attributes) {
          if (typeof document === 'undefined') {
            return;
          }

          attributes = extend({
            path: '/'
          }, api.defaults, attributes);

          if (typeof attributes.expires === 'number') {
            attributes.expires = new Date(new Date() * 1 + attributes.expires * 864e+5);
          } // We're using "expires" because "max-age" is not supported by IE


          attributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';

          try {
            var result = JSON.stringify(value);

            if (/^[\{\[]/.test(result)) {
              value = result;
            }
          } catch (e) {}

          value = converter.write ? converter.write(value, key) : encodeURIComponent(String(value)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);
          key = encodeURIComponent(String(key)).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/[\(\)]/g, escape);
          var stringifiedAttributes = '';

          for (var attributeName in attributes) {
            if (!attributes[attributeName]) {
              continue;
            }

            stringifiedAttributes += '; ' + attributeName;

            if (attributes[attributeName] === true) {
              continue;
            } // Considers RFC 6265 section 5.2:
            // ...
            // 3.  If the remaining unparsed-attributes contains a %x3B (";")
            //     character:
            // Consume the characters of the unparsed-attributes up to,
            // not including, the first %x3B (";") character.
            // ...


            stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
          }

          return document.cookie = key + '=' + value + stringifiedAttributes;
        }

        function get(key, json) {
          if (typeof document === 'undefined') {
            return;
          }

          var jar = {}; // To prevent the for loop in the first place assign an empty array
          // in case there are no cookies at all.

          var cookies = document.cookie ? document.cookie.split('; ') : [];
          var i = 0;

          for (; i < cookies.length; i++) {
            var parts = cookies[i].split('=');
            var cookie = parts.slice(1).join('=');

            if (!json && cookie.charAt(0) === '"') {
              cookie = cookie.slice(1, -1);
            }

            try {
              var name = decode(parts[0]);
              cookie = (converter.read || converter)(cookie, name) || decode(cookie);

              if (json) {
                try {
                  cookie = JSON.parse(cookie);
                } catch (e) {}
              }

              jar[name] = cookie;

              if (key === name) {
                break;
              }
            } catch (e) {}
          }

          return key ? jar[key] : jar;
        }

        api.set = set;

        api.get = function (key) {
          return get(key, false
          /* read as raw */
          );
        };

        api.getJSON = function (key) {
          return get(key, true
          /* read as json */
          );
        };

        api.remove = function (key, attributes) {
          set(key, '', extend(attributes, {
            expires: -1
          }));
        };

        api.defaults = {};
        api.withConverter = init;
        return api;
      }

      return init(function () {});
    });
  });

  /* eslint-disable require-jsdoc */

  function CookieStorage() {}

  CookieStorage.prototype.getItem = function (key) {
    return js_cookie.get(key);
  };

  CookieStorage.prototype.removeItem = function (key) {
    js_cookie.remove(key);
  };

  CookieStorage.prototype.setItem = function (key, value, options) {
    var params = Object.assign({
      expires: 1 // 1 day

    }, options);
    js_cookie.set(key, value, params);
  };

  /* eslint-disable require-jsdoc */

  function StorageHandler(options) {
    this.storage = new CookieStorage();

    if (options.force_local_storage !== true) {
      return;
    }

    try {
      // some browsers throw an error when trying to access localStorage
      // when localStorage is disabled.
      var localStorage = window.localStorage;

      if (localStorage) {
        this.storage = localStorage;
      }
    } catch (e) {
      console.warn(e);
      console.warn('Cant use localStorage. Using CookieStorage instead.');
    }
  }

  StorageHandler.prototype.failover = function () {
    if (this.storage instanceof DummyStorage) {
      console.warn('DummyStorage: ignore failover');
      return;
    } else if (this.storage instanceof CookieStorage) {
      console.warn('CookieStorage: failing over DummyStorage');
      this.storage = new DummyStorage();
    } else {
      console.warn('LocalStorage: failing over CookieStorage');
      this.storage = new CookieStorage();
    }
  };

  StorageHandler.prototype.getItem = function (key) {
    try {
      return this.storage.getItem(key);
    } catch (e) {
      console.warn(e);
      this.failover();
      return this.getItem(key);
    }
  };

  StorageHandler.prototype.removeItem = function (key) {
    try {
      return this.storage.removeItem(key);
    } catch (e) {
      console.warn(e);
      this.failover();
      return this.removeItem(key);
    }
  };

  StorageHandler.prototype.setItem = function (key, value, options) {
    try {
      return this.storage.setItem(key, value, options);
    } catch (e) {
      console.warn(e);
      this.failover();
      return this.setItem(key, value, options);
    }
  };

  /* eslint-disable require-jsdoc */

  function Storage(options) {
    this.handler = new StorageHandler(options);
  }

  Storage.prototype.getItem = function (key) {
    var value = this.handler.getItem(key);

    try {
      return JSON.parse(value);
    } catch (_) {
      return value;
    }
  };

  Storage.prototype.removeItem = function (key) {
    return this.handler.removeItem(key);
  };

  Storage.prototype.setItem = function (key, value, options) {
    var json = JSON.stringify(value);
    return this.handler.setItem(key, json, options);
  };

  var Transaction = /*#__PURE__*/function () {
    function Transaction(options) {
      _classCallCheck(this, Transaction);

      this.options = options.transaction;
      this.storage = new Storage(this.options);
    }

    _createClass(Transaction, [{
      key: "generate",
      value: function generate(params) {
        if (!params.state) {
          params.state = random.string(this.options.key_length);
        } // 30 minutes


        this.storage.setItem(this.options.namespace + params.state, {
          state: params.state,
          code_verifier: params.code_verifier
        }, {
          expires: 1 / 48
        });
      }
    }, {
      key: "get",
      value: function get(state) {
        var transactionData = this.storage.getItem(this.options.namespace + state);
        this.clear(state);
        return transactionData || {};
      }
    }, {
      key: "clear",
      value: function clear(state) {
        this.storage.removeItem(this.options.namespace + state);
      }
    }]);

    return Transaction;
  }();

  /** @fileOverview Javascript cryptography implementation.
   *
   * Crush to remove comments, shorten variable names and
   * generally reduce transmission size.
   *
   * @author Emily Stark
   * @author Mike Hamburg
   * @author Dan Boneh
   */
  /*jslint indent: 2, bitwise: false, nomen: false, plusplus: false, white: false, regexp: false */

  /*global document, window, escape, unescape, module, require, Uint32Array */

  /**
   * The Stanford Javascript Crypto Library, top-level namespace.
   * @namespace
   */

  var sjcl = {
    /**
     * Symmetric ciphers.
     * @namespace
     */
    cipher: {},

    /**
     * Hash functions.  Right now only SHA256 is implemented.
     * @namespace
     */
    hash: {},

    /**
     * Key exchange functions.  Right now only SRP is implemented.
     * @namespace
     */
    keyexchange: {},

    /**
     * Cipher modes of operation.
     * @namespace
     */
    mode: {},

    /**
     * Miscellaneous.  HMAC and PBKDF2.
     * @namespace
     */
    misc: {},

    /**
     * Bit array encoders and decoders.
     * @namespace
     *
     * @description
     * The members of this namespace are functions which translate between
     * SJCL's bitArrays and other objects (usually strings).  Because it
     * isn't always clear which direction is encoding and which is decoding,
     * the method names are "fromBits" and "toBits".
     */
    codec: {},

    /**
     * Exceptions.
     * @namespace
     */
    exception: {
      /**
       * Ciphertext is corrupt.
       * @constructor
       */
      corrupt: function corrupt(message) {
        this.toString = function () {
          return 'CORRUPT: ' + this.message;
        };

        this.message = message;
      },

      /**
       * Invalid parameter.
       * @constructor
       */
      invalid: function invalid(message) {
        this.toString = function () {
          return 'INVALID: ' + this.message;
        };

        this.message = message;
      },

      /**
       * Bug or missing feature in SJCL.
       * @constructor
       */
      bug: function bug(message) {
        this.toString = function () {
          return 'BUG: ' + this.message;
        };

        this.message = message;
      },

      /**
       * Something isn't ready.
       * @constructor
       */
      notReady: function notReady(message) {
        this.toString = function () {
          return 'NOT READY: ' + this.message;
        };

        this.message = message;
      }
    }
  };
  /** @fileOverview Arrays of bits, encoded as arrays of Numbers.
   *
   * @author Emily Stark
   * @author Mike Hamburg
   * @author Dan Boneh
   */

  /**
   * Arrays of bits, encoded as arrays of Numbers.
   * @namespace
   * @description
   * <p>
   * These objects are the currency accepted by SJCL's crypto functions.
   * </p>
   *
   * <p>
   * Most of our crypto primitives operate on arrays of 4-byte words internally,
   * but many of them can take arguments that are not a multiple of 4 bytes.
   * This library encodes arrays of bits (whose size need not be a multiple of 8
   * bits) as arrays of 32-bit words.  The bits are packed, big-endian, into an
   * array of words, 32 bits at a time.  Since the words are double-precision
   * floating point numbers, they fit some extra data.  We use this (in a private,
   * possibly-changing manner) to encode the number of bits actually  present
   * in the last word of the array.
   * </p>
   *
   * <p>
   * Because bitwise ops clear this out-of-band data, these arrays can be passed
   * to ciphers like AES which want arrays of words.
   * </p>
   */

  sjcl.bitArray = {
    /**
     * Array slices in units of bits.
     * @param {bitArray} a The array to slice.
     * @param {Number} bstart The offset to the start of the slice, in bits.
     * @param {Number} bend The offset to the end of the slice, in bits.  If this is undefined,
     * slice until the end of the array.
     * @return {bitArray} The requested slice.
     */
    bitSlice: function bitSlice(a, bstart, bend) {
      a = sjcl.bitArray._shiftRight(a.slice(bstart / 32), 32 - (bstart & 31)).slice(1);
      return bend === undefined ? a : sjcl.bitArray.clamp(a, bend - bstart);
    },

    /**
     * Extract a number packed into a bit array.
     * @param {bitArray} a The array to slice.
     * @param {Number} bstart The offset to the start of the slice, in bits.
     * @param {Number} blength The length of the number to extract.
     * @return {Number} The requested slice.
     */
    extract: function extract(a, bstart, blength) {
      // FIXME: this Math.floor is not necessary at all, but for some reason
      // seems to suppress a bug in the Chromium JIT.
      var x,
          sh = Math.floor(-bstart - blength & 31);

      if ((bstart + blength - 1 ^ bstart) & -32) {
        // it crosses a boundary
        x = a[bstart / 32 | 0] << 32 - sh ^ a[bstart / 32 + 1 | 0] >>> sh;
      } else {
        // within a single word
        x = a[bstart / 32 | 0] >>> sh;
      }

      return x & (1 << blength) - 1;
    },

    /**
     * Concatenate two bit arrays.
     * @param {bitArray} a1 The first array.
     * @param {bitArray} a2 The second array.
     * @return {bitArray} The concatenation of a1 and a2.
     */
    concat: function concat(a1, a2) {
      if (a1.length === 0 || a2.length === 0) {
        return a1.concat(a2);
      }

      var last = a1[a1.length - 1],
          shift = sjcl.bitArray.getPartial(last);

      if (shift === 32) {
        return a1.concat(a2);
      } else {
        return sjcl.bitArray._shiftRight(a2, shift, last | 0, a1.slice(0, a1.length - 1));
      }
    },

    /**
     * Find the length of an array of bits.
     * @param {bitArray} a The array.
     * @return {Number} The length of a, in bits.
     */
    bitLength: function bitLength(a) {
      var l = a.length,
          x;

      if (l === 0) {
        return 0;
      }

      x = a[l - 1];
      return (l - 1) * 32 + sjcl.bitArray.getPartial(x);
    },

    /**
     * Truncate an array.
     * @param {bitArray} a The array.
     * @param {Number} len The length to truncate to, in bits.
     * @return {bitArray} A new array, truncated to len bits.
     */
    clamp: function clamp(a, len) {
      if (a.length * 32 < len) {
        return a;
      }

      a = a.slice(0, Math.ceil(len / 32));
      var l = a.length;
      len = len & 31;

      if (l > 0 && len) {
        a[l - 1] = sjcl.bitArray.partial(len, a[l - 1] & 0x80000000 >> len - 1, 1);
      }

      return a;
    },

    /**
     * Make a partial word for a bit array.
     * @param {Number} len The number of bits in the word.
     * @param {Number} x The bits.
     * @param {Number} [_end=0] Pass 1 if x has already been shifted to the high side.
     * @return {Number} The partial word.
     */
    partial: function partial(len, x, _end) {
      if (len === 32) {
        return x;
      }

      return (_end ? x | 0 : x << 32 - len) + len * 0x10000000000;
    },

    /**
     * Get the number of bits used by a partial word.
     * @param {Number} x The partial word.
     * @return {Number} The number of bits used by the partial word.
     */
    getPartial: function getPartial(x) {
      return Math.round(x / 0x10000000000) || 32;
    },

    /**
     * Compare two arrays for equality in a predictable amount of time.
     * @param {bitArray} a The first array.
     * @param {bitArray} b The second array.
     * @return {boolean} true if a == b; false otherwise.
     */
    equal: function equal(a, b) {
      if (sjcl.bitArray.bitLength(a) !== sjcl.bitArray.bitLength(b)) {
        return false;
      }

      var x = 0,
          i;

      for (i = 0; i < a.length; i++) {
        x |= a[i] ^ b[i];
      }

      return x === 0;
    },

    /** Shift an array right.
     * @param {bitArray} a The array to shift.
     * @param {Number} shift The number of bits to shift.
     * @param {Number} [carry=0] A byte to carry in
     * @param {bitArray} [out=[]] An array to prepend to the output.
     * @private
     */
    _shiftRight: function _shiftRight(a, shift, carry, out) {
      var i,
          last2 = 0,
          shift2;

      if (out === undefined) {
        out = [];
      }

      for (; shift >= 32; shift -= 32) {
        out.push(carry);
        carry = 0;
      }

      if (shift === 0) {
        return out.concat(a);
      }

      for (i = 0; i < a.length; i++) {
        out.push(carry | a[i] >>> shift);
        carry = a[i] << 32 - shift;
      }

      last2 = a.length ? a[a.length - 1] : 0;
      shift2 = sjcl.bitArray.getPartial(last2);
      out.push(sjcl.bitArray.partial(shift + shift2 & 31, shift + shift2 > 32 ? carry : out.pop(), 1));
      return out;
    },

    /** xor a block of 4 words together.
     * @private
     */
    _xor4: function _xor4(x, y) {
      return [x[0] ^ y[0], x[1] ^ y[1], x[2] ^ y[2], x[3] ^ y[3]];
    },

    /** byteswap a word array inplace.
     * (does not handle partial words)
     * @param {sjcl.bitArray} a word array
     * @return {sjcl.bitArray} byteswapped array
     */
    byteswapM: function byteswapM(a) {
      var i,
          v,
          m = 0xff00;

      for (i = 0; i < a.length; ++i) {
        v = a[i];
        a[i] = v >>> 24 | v >>> 8 & m | (v & m) << 8 | v << 24;
      }

      return a;
    }
  };
  /** @fileOverview Bit array codec implementations.
   *
   * @author Emily Stark
   * @author Mike Hamburg
   * @author Dan Boneh
   */

  /**
   * UTF-8 strings
   * @namespace
   */

  sjcl.codec.utf8String = {
    /** Convert from a bitArray to a UTF-8 string. */
    fromBits: function fromBits(arr) {
      var out = '',
          bl = sjcl.bitArray.bitLength(arr),
          i,
          tmp;

      for (i = 0; i < bl / 8; i++) {
        if ((i & 3) === 0) {
          tmp = arr[i / 4];
        }

        out += String.fromCharCode(tmp >>> 8 >>> 8 >>> 8);
        tmp <<= 8;
      }

      return decodeURIComponent(escape(out));
    },

    /** Convert from a UTF-8 string to a bitArray. */
    toBits: function toBits(str) {
      str = unescape(encodeURIComponent(str));
      var out = [],
          i,
          tmp = 0;

      for (i = 0; i < str.length; i++) {
        tmp = tmp << 8 | str.charCodeAt(i);

        if ((i & 3) === 3) {
          out.push(tmp);
          tmp = 0;
        }
      }

      if (i & 3) {
        out.push(sjcl.bitArray.partial(8 * (i & 3), tmp));
      }

      return out;
    }
  };
  /** @fileOverview Javascript SHA-256 implementation.
   *
   * An older version of this implementation is available in the public
   * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,
   * Stanford University 2008-2010 and BSD-licensed for liability
   * reasons.
   *
   * Special thanks to Aldo Cortesi for pointing out several bugs in
   * this code.
   *
   * @author Emily Stark
   * @author Mike Hamburg
   * @author Dan Boneh
   */

  /**
   * Context for a SHA-256 operation in progress.
   * @constructor
   */

  sjcl.hash.sha256 = function (hash) {
    if (!this._key[0]) {
      this._precompute();
    }

    if (hash) {
      this._h = hash._h.slice(0);
      this._buffer = hash._buffer.slice(0);
      this._length = hash._length;
    } else {
      this.reset();
    }
  };
  /**
   * Hash a string or an array of words.
   * @static
   * @param {bitArray|String} data the data to hash.
   * @return {bitArray} The hash value, an array of 16 big-endian words.
   */


  sjcl.hash.sha256.hash = function (data) {
    return new sjcl.hash.sha256().update(data).finalize();
  };

  sjcl.hash.sha256.prototype = {
    /**
     * The hash's block size, in bits.
     * @constant
     */
    blockSize: 512,

    /**
     * Reset the hash state.
     * @return this
     */
    reset: function reset() {
      this._h = this._init.slice(0);
      this._buffer = [];
      this._length = 0;
      return this;
    },

    /**
     * Input several words to the hash.
     * @param {bitArray|String} data the data to hash.
     * @return this
     */
    update: function update(data) {
      if (typeof data === 'string') {
        data = sjcl.codec.utf8String.toBits(data);
      }

      var i,
          b = this._buffer = sjcl.bitArray.concat(this._buffer, data),
          ol = this._length,
          nl = this._length = ol + sjcl.bitArray.bitLength(data);

      if (nl > 9007199254740991) {
        throw new sjcl.exception.invalid('Cannot hash more than 2^53 - 1 bits');
      }

      if (typeof Uint32Array !== 'undefined') {
        var c = new Uint32Array(b);
        var j = 0;

        for (i = 512 + ol - (512 + ol & 511); i <= nl; i += 512) {
          this._block(c.subarray(16 * j, 16 * (j + 1)));

          j += 1;
        }

        b.splice(0, 16 * j);
      } else {
        for (i = 512 + ol - (512 + ol & 511); i <= nl; i += 512) {
          this._block(b.splice(0, 16));
        }
      }

      return this;
    },

    /**
     * Complete hashing and output the hash value.
     * @return {bitArray} The hash value, an array of 8 big-endian words.
     */
    finalize: function finalize() {
      var i,
          b = this._buffer,
          h = this._h; // Round out and push the buffer

      b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1, 1)]); // Round out the buffer to a multiple of 16 words, less the 2 length words.

      for (i = b.length + 2; i & 15; i++) {
        b.push(0);
      } // append the length


      b.push(Math.floor(this._length / 0x100000000));
      b.push(this._length | 0);

      while (b.length) {
        this._block(b.splice(0, 16));
      }

      this.reset();
      return h;
    },

    /**
     * The SHA-256 initialization vector, to be precomputed.
     * @private
     */
    _init: [],

    /*
     _init:[0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19],
     */

    /**
     * The SHA-256 hash key, to be precomputed.
     * @private
     */
    _key: [],

    /*
     _key:
       [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2],
     */

    /**
     * Function to precompute _init and _key.
     * @private
     */
    _precompute: function _precompute() {
      var i = 0,
          prime = 2,
          factor,
          isPrime;

      function frac(x) {
        return (x - Math.floor(x)) * 0x100000000 | 0;
      }

      for (; i < 64; prime++) {
        isPrime = true;

        for (factor = 2; factor * factor <= prime; factor++) {
          if (prime % factor === 0) {
            isPrime = false;
            break;
          }
        }

        if (isPrime) {
          if (i < 8) {
            this._init[i] = frac(Math.pow(prime, 1 / 2));
          }

          this._key[i] = frac(Math.pow(prime, 1 / 3));
          i++;
        }
      }
    },

    /**
     * Perform one cycle of SHA-256.
     * @param {Uint32Array|bitArray} w one block of words.
     * @private
     */
    _block: function _block(w) {
      var i,
          tmp,
          a,
          b,
          h = this._h,
          k = this._key,
          h0 = h[0],
          h1 = h[1],
          h2 = h[2],
          h3 = h[3],
          h4 = h[4],
          h5 = h[5],
          h6 = h[6],
          h7 = h[7];
      /* Rationale for placement of |0 :
       * If a value can overflow is original 32 bits by a factor of more than a few
       * million (2^23 ish), there is a possibility that it might overflow the
       * 53-bit mantissa and lose precision.
       *
       * To avoid this, we clamp back to 32 bits by |'ing with 0 on any value that
       * propagates around the loop, and on the hash state h[].  I don't believe
       * that the clamps on h4 and on h0 are strictly necessary, but it's close
       * (for h4 anyway), and better safe than sorry.
       *
       * The clamps on h[] are necessary for the output to be correct even in the
       * common case and for short inputs.
       */

      for (i = 0; i < 64; i++) {
        // load up the input word for this round
        if (i < 16) {
          tmp = w[i];
        } else {
          a = w[i + 1 & 15];
          b = w[i + 14 & 15];
          tmp = w[i & 15] = (a >>> 7 ^ a >>> 18 ^ a >>> 3 ^ a << 25 ^ a << 14) + (b >>> 17 ^ b >>> 19 ^ b >>> 10 ^ b << 15 ^ b << 13) + w[i & 15] + w[i + 9 & 15] | 0;
        }

        tmp = tmp + h7 + (h4 >>> 6 ^ h4 >>> 11 ^ h4 >>> 25 ^ h4 << 26 ^ h4 << 21 ^ h4 << 7) + (h6 ^ h4 & (h5 ^ h6)) + k[i]; // | 0;
        // shift register

        h7 = h6;
        h6 = h5;
        h5 = h4;
        h4 = h3 + tmp | 0;
        h3 = h2;
        h2 = h1;
        h1 = h0;
        h0 = tmp + (h1 & h2 ^ h3 & (h1 ^ h2)) + (h1 >>> 2 ^ h1 >>> 13 ^ h1 >>> 22 ^ h1 << 30 ^ h1 << 19 ^ h1 << 10) | 0;
      }

      h[0] = h[0] + h0 | 0;
      h[1] = h[1] + h1 | 0;
      h[2] = h[2] + h2 | 0;
      h[3] = h[3] + h3 | 0;
      h[4] = h[4] + h4 | 0;
      h[5] = h[5] + h5 | 0;
      h[6] = h[6] + h6 | 0;
      h[7] = h[7] + h7 | 0;
    }
  };

  // eslint-disable-next-line require-jsdoc
  function base64URLEncode(str) {
    return btoa(str).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
  }

  var encoding = {
    base64URLEncode: base64URLEncode
  };

  /**
   * Accounts SDK main class
   */

  var AccountsSDK = /*#__PURE__*/function () {
    /**
     * Accounts SDK constructor
     *
     * @constructor
     * @param {Object} options
     * @param {String} options.client_id registered client ID
     * @param {String} [options.prompt=''] use `consent` to force consent prompt in popup and redirect flows
     * @param {String} [options.response_type='token'] OAuth response type, use `token` or `code`
     * @param {String} [options.popup_flow='auto'] `auto` - close popup when not required, `manual` - always show popup
     * @param {String} [options.state=''] OAuth state param
     * @param {Boolean} [options.verify_state=true] check if state matches after redirect
     * @param {String} [options.scope=null] request exact scopes - must be configured for a given client id
     * @param {String} [options.redirect_uri=''] OAuth redirect uri - default current location
     * @param {String} [options.email_hint=''] fill in email in forms
     * @param {String} [options.server_url='https://accounts.livechat.com'] authorization server url
     * @param {String} [options.path=''] option to provide a path when loading accounts, for example '/signup'
     * @param {Object} [options.tracking] tracking querystring params
     * @param {Object} [options.transaction] options for transaction manager
     * @param {String} [options.transaction.namespace='com.livechat.accounts'] transaction keys prefix
     * @param {Number} [options.transaction.key_length=32] transaction random state length
     * @param {Boolean} [options.transaction.force_local_storage=false] try to use local storage instead of cookies
     * @param {Object} [options.pkce] PKCE configuration
     * @param {Boolean} [options.pkce.enabled=true] Oauth 2.1 PKCE extension enabled
     * @param {String} [options.pkce.code_verifier] override auto generated code verifier
     * @param {Number} [options.pkce.code_verifier_length=128] code verifier length, between 43 and 128 characters https://tools.ietf.org/html/rfc7636#section-4.1
     * @param {String} [options.pkce.code_challange_method='S256'] code challange method, use `S256` or `plain`
     */
    function AccountsSDK() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, AccountsSDK);

      if (options.client_id == null) {
        throw new Error('client id not provided');
      }

      var defaultOptions = {
        prompt: '',
        response_type: 'token',
        popup_flow: 'auto',
        state: '',
        verify_state: true,
        verify_callback: true,
        scope: null,
        redirect_uri: '',
        email_hint: null,
        server_url: 'https://accounts.livechat.com',
        tracking: {
          utm_source: 'accounts.livechat.com',
          utm_medium: 'accounts-sdk'
        },
        transaction: {
          namespace: 'com.livechat.accounts',
          key_length: 32,
          force_local_storage: false
        },
        pkce: {
          enabled: true,
          code_verifier_length: 128,
          code_challange_method: 'S256'
        }
      };
      this.options = Object.assign({}, defaultOptions, options);
      this.transaction = new Transaction(this.options);
    }
    /**
     * use iframe for authorization
     * @param {Object} options for overriding defaults
     * @return {Object} instance of an iframe flow
     */


    _createClass(AccountsSDK, [{
      key: "iframe",
      value: function iframe() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var localOptions = Object.assign({}, this.options, options);
        return new Iframe(this, localOptions);
      }
      /**
       * use popup for authorization
       * @param {Object} options for overriding defaults
       * @return {Object} instance of a popup flow
       */

    }, {
      key: "popup",
      value: function popup() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var localOptions = Object.assign({}, this.options, options);
        return new Popup(this, localOptions);
      }
      /**
       * use redirect for authorization
       * @param {Object} options for overriding defaults
       * @return {Object} instance of a redirect flow
       */

    }, {
      key: "redirect",
      value: function redirect() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var localOptions = Object.assign({}, this.options, options);
        return new Redirect(this, localOptions);
      }
      /**
       * create authorization url
       * @param {Object} options for overriding defaults
       * @param {String} flow set 'button' for popup and iframe
       * @return {string} generated url
       */

    }, {
      key: "authorizeURL",
      value: function authorizeURL() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var flow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
        var localOptions = Object.assign({}, this.options, options);

        if (!localOptions.redirect_uri) {
          localOptions.redirect_uri = window.location.origin + window.location.pathname;
        }

        var params = pick(localOptions, ['client_id', 'redirect_uri', 'state', 'response_type', 'scope', 'prompt']);
        Object.assign(params, localOptions.tracking);

        if (params.scope === null) {
          delete params.scope;
        }

        if (flow != null) {
          params.flow = flow;
        }

        if (localOptions.email_hint) {
          params.email = localOptions.email_hint;
        }

        var url = localOptions.server_url;

        if (localOptions.popup_flow === 'manual') {
          url += '/signin';
        }

        if (localOptions.path) {
          url += localOptions.path;
        }

        if (localOptions.response_type === 'code' && localOptions.pkce.enabled) {
          var codeVerifier = localOptions.pkce.code_verifier || random.string(localOptions.pkce.code_verifier_length);

          switch (localOptions.pkce.code_challange_method) {
            case 'S256':
              var codeChallenge = sjcl.hash.sha256.hash(codeVerifier);
              Object.assign(params, {
                code_verifier: codeVerifier,
                code_challenge: encoding.base64URLEncode(codeChallenge),
                code_challenge_method: localOptions.pkce.code_challange_method
              });
              break;

            default:
              Object.assign(params, {
                code_verifier: codeVerifier,
                code_challenge: codeVerifier,
                code_challenge_method: localOptions.pkce.code_challange_method
              });
          }
        }

        this.transaction.generate(params);
        delete params.code_verifier;
        return url + '?' + lib.stringify(params);
      }
      /**
       * This function verifies if redirect transaction params are valid.
       * @param {Object} authorizeData authorize data to validate and return transaction state - redirect state, pkce code verifier
       * @return {Object} transaction state if valid, null otherwise
       */

    }, {
      key: "verify",
      value: function verify(authorizeData) {
        var transactionData = this.transaction.get(authorizeData.state);

        if (authorizeData.state && this.options.verify_state) {
          if (transactionData.state != authorizeData.state) {
            return null;
          }
        }

        return transactionData;
      }
    }]);

    return AccountsSDK;
  }();

  return AccountsSDK;

})));
//# sourceMappingURL=accounts-sdk.js.map
