'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var InformationOutlineIcon = _interopDefault(require('react-material-icon-svg/dist/InformationOutlineIcon'));
var BlockHelperIcon = _interopDefault(require('react-material-icon-svg/dist/BlockHelperIcon'));
var CheckCircleIcon = _interopDefault(require('react-material-icon-svg/dist/CheckCircleIcon'));
var AlertIcon = _interopDefault(require('react-material-icon-svg/dist/AlertIcon'));
var InformationIcon = _interopDefault(require('react-material-icon-svg/dist/InformationIcon'));
var MenuDownIcon = _interopDefault(require('react-material-icon-svg/dist/MenuDownIcon'));
var ReactDayPicker = _interopDefault(require('react-day-picker'));
var ChevronLeftIcon = _interopDefault(require('react-material-icon-svg/dist/ChevronLeftIcon'));
var ChevronRightIcon = _interopDefault(require('react-material-icon-svg/dist/ChevronRightIcon'));
var ChevronDoubleLeftIcon = _interopDefault(require('react-material-icon-svg/dist/ChevronDoubleLeftIcon'));
var ChevronDoubleRightIcon = _interopDefault(require('react-material-icon-svg/dist/ChevronDoubleRightIcon'));
var dateFns = require('date-fns');
var ReactDOM = require('react-dom');
var ResizeObserver = _interopDefault(require('resize-observer-polyfill'));
var memoizeOne = _interopDefault(require('memoize-one'));
var reactPopper = require('react-popper');
var dataUtils = require('@livechat/data-utils');
var AlertCircleIcon = _interopDefault(require('react-material-icon-svg/dist/AlertCircleIcon'));
var reactTransitionGroup = require('react-transition-group');
var RefreshIcon = _interopDefault(require('react-material-icon-svg/dist/RefreshIcon'));
var CheckIcon = _interopDefault(require('react-material-icon-svg/dist/CheckIcon'));
var classNames = _interopDefault(require('classnames/bind'));
var debounce = _interopDefault(require('lodash.debounce'));
var cx = _interopDefault(require('classnames'));
var SearchIcon = _interopDefault(require('react-material-icon-svg/dist/MagnifyIcon'));
var CloseIcon = _interopDefault(require('react-material-icon-svg/dist/CloseIcon'));
var React = require('react');
var PropTypes = require('prop-types');

var styles = { "btn": "lc-btn", "btn--loading": "lc-btn--loading", "btn--disabled": "lc-btn--disabled", "btn--full-width": "lc-btn--full-width", "btn--primary": "lc-btn--primary", "btn--secondary": "lc-btn--secondary", "btn--destructive": "lc-btn--destructive", "btn--text": "lc-btn--text", "btn--large": "lc-btn--large", "btn--compact": "lc-btn--compact", "icon": "lc-icon", "btn__loader": "lc-btn__loader", "btn__loader-label": "lc-btn__loader-label", "btn__icon": "lc-btn__icon", "btn__icon-left": "lc-btn__icon-left", "btn__icon-right": "lc-btn__icon-right" };

var getMergedClassNames = function getMergedClassNames(classNames$$1, classNameProperty) {
  if (classNameProperty) {
    return classNames$$1 + " " + classNameProperty;
  }
  return classNames$$1;
};

var styles$1 = { "loader-spinner": "lc-loader-spinner", "rotate": "lc-rotate", "loader-spinner--thin": "lc-loader-spinner--thin", "loader-spinner--medium": "lc-loader-spinner--medium", "loader-spinner--thick": "lc-loader-spinner--thick", "loader-spinner-wrapper": "lc-loader-spinner-wrapper", "loader-spinner-wrapper--small": "lc-loader-spinner-wrapper--small", "loader-spinner-wrapper--medium": "lc-loader-spinner-wrapper--medium", "loader-spinner-wrapper--large": "lc-loader-spinner-wrapper--large", "loader-spinner-wrapper--hidden": "lc-loader-spinner-wrapper--hidden", "loader-label": "lc-loader-label", "loader-wrapper": "lc-loader-wrapper", "loader-wrapper--hidden": "lc-loader-wrapper--hidden" };

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var cx$1 = classNames.bind(styles$1);

var baseClass = 'loader-wrapper';

var LoaderWrapper = function LoaderWrapper(props) {
  var _cx;

  var className = props.className,
      isLoading = props.isLoading,
      children = props.children,
      restProps = objectWithoutProperties(props, ['className', 'isLoading', 'children']);


  var mergedClassNames = getMergedClassNames(cx$1((_cx = {}, _cx[baseClass] = true, _cx[baseClass + '--hidden'] = isLoading !== undefined && !isLoading, _cx)), className);

  return React.createElement(
    'div',
    _extends({}, restProps, { className: mergedClassNames }),
    children
  );
};
process.env.NODE_ENV !== "production" ? LoaderWrapper.propTypes = {
  children: PropTypes.oneOfType([PropTypes.node, PropTypes.arrayOf(PropTypes.node)]),
  className: PropTypes.string,
  isLoading: PropTypes.bool
} : void 0;

var _THICKNESS_FROM_SIZE;

var THICKNESS = {
  thin: 'thin',
  medium: 'medium',
  thick: 'thick'
};

var SIZE = {
  small: 'small',
  medium: 'medium',
  large: 'large'
};

var THICKNESS_FROM_SIZE = (_THICKNESS_FROM_SIZE = {}, _THICKNESS_FROM_SIZE[SIZE.small] = THICKNESS.thin, _THICKNESS_FROM_SIZE[SIZE.medium] = THICKNESS.medium, _THICKNESS_FROM_SIZE[SIZE.large] = THICKNESS.thick, _THICKNESS_FROM_SIZE);

var cx$2 = classNames.bind(styles$1);

var baseClass$1 = 'loader-spinner';

var LoaderSpinner = function LoaderSpinner(props) {
  var _cx, _cx2;

  var className = props.className,
      isLoading = props.isLoading,
      size = props.size,
      primaryColor = props.primaryColor,
      secondaryColor = props.secondaryColor,
      spinnerClassName = props.spinnerClassName,
      restProps = objectWithoutProperties(props, ['className', 'isLoading', 'size', 'primaryColor', 'secondaryColor', 'spinnerClassName']);


  var mergedWrapperClassNames = getMergedClassNames(cx$2((_cx = {}, _cx[baseClass$1 + '-wrapper'] = true, _cx[baseClass$1 + '-wrapper--' + size] = size, _cx[baseClass$1 + '-wrapper--hidden'] = isLoading !== undefined && !isLoading, _cx)), className);

  var mergedSpinnerClassNames = getMergedClassNames(cx$2((_cx2 = {}, _cx2[baseClass$1] = true, _cx2[baseClass$1 + '--' + THICKNESS_FROM_SIZE[size]] = size && THICKNESS_FROM_SIZE[size], _cx2)), spinnerClassName);

  return React.createElement(
    'div',
    _extends({ className: mergedWrapperClassNames }, restProps),
    React.createElement('div', {
      className: mergedSpinnerClassNames,
      style: (primaryColor || secondaryColor) && {
        borderColor: secondaryColor,
        borderTopColor: primaryColor
      }
    })
  );
};
process.env.NODE_ENV !== "production" ? LoaderSpinner.propTypes = {
  className: PropTypes.string,
  spinnerClassName: PropTypes.string,
  isLoading: PropTypes.bool,
  primaryColor: PropTypes.string,
  secondaryColor: PropTypes.string,
  size: PropTypes.oneOf(['small', 'medium', 'large'])
} : void 0;

var cx$3 = classNames.bind(styles$1);

var baseClass$2 = 'loader-label';

var LoaderLabel = function LoaderLabel(props) {
  var className = props.className,
      children = props.children,
      restProps = objectWithoutProperties(props, ['className', 'children']);


  var mergedClassNames = getMergedClassNames(cx$3(baseClass$2), className);

  return React.createElement(
    'div',
    _extends({ className: mergedClassNames }, restProps),
    children
  );
};
process.env.NODE_ENV !== "production" ? LoaderLabel.propTypes = {
  children: PropTypes.node,
  className: PropTypes.string
} : void 0;

var Loader = function Loader(props) {
  var className = props.className,
      isLoading = props.isLoading,
      label = props.label,
      spinnerClassName = props.spinnerClassName,
      spinnerWrapperClassName = props.spinnerWrapperClassName,
      labelClassName = props.labelClassName,
      primaryColor = props.primaryColor,
      secondaryColor = props.secondaryColor,
      size = props.size,
      restProps = objectWithoutProperties(props, ['className', 'isLoading', 'label', 'spinnerClassName', 'spinnerWrapperClassName', 'labelClassName', 'primaryColor', 'secondaryColor', 'size']);


  return React.createElement(
    LoaderWrapper,
    _extends({}, restProps, { isLoading: isLoading, className: className }),
    React.createElement(LoaderSpinner, {
      className: spinnerWrapperClassName,
      spinnerClassName: spinnerClassName,
      primaryColor: primaryColor,
      secondaryColor: secondaryColor,
      size: size
    }),
    label && React.createElement(
      LoaderLabel,
      { className: labelClassName },
      label
    )
  );
};
process.env.NODE_ENV !== "production" ? Loader.propTypes = {
  /**
   * Classname for the wrapper of the loader atoms (label and spinner).
   */
  className: PropTypes.string,
  /**
   * A brief description of the process.
   */
  label: PropTypes.string,
  /**
   * Label element classname.
   */
  labelClassName: PropTypes.string,
  /**
   * Spinner element classname.
   */
  spinnerClassName: PropTypes.string,
  /**
   * Spinner wrapper classname.
   */
  spinnerWrapperClassName: PropTypes.string,
  /**
   * You can unmount Loader when it's not necessary or use `isLoading` prop to control its visibility without unmounting.
   */
  isLoading: PropTypes.bool,
  /**
   * Changing primary color of spinner.
   */
  primaryColor: PropTypes.string,
  /**
   * Changing secondary color of spinner.
   */
  secondaryColor: PropTypes.string,
  /**
   * `Size` prop defines width and height of the wrapper and spinner thickness if it is not provided.
   * To define your custom size use css and `spinnerWrapperClassName` property (however, we recommend using defined size).
   */
  size: PropTypes.oneOf(['small', 'medium', 'large'])
} : void 0;

var noticeAboutDeprecation = function noticeAboutDeprecation(message) {
    var env = process.env.NODE_ENV;
    var isDevelopmetEnv = env === 'dev' || env === 'development' || env === 'labs';
    isDevelopmetEnv && console.error('[Design System] ' + message);
};

var cx$4 = classNames.bind(styles);

var ButtonIcon = function ButtonIcon(_ref) {
  var _cx;

  var position = _ref.position,
      children = _ref.children;

  var baseClass = 'btn__icon';
  var classes = getMergedClassNames(cx$4((_cx = {}, _cx['' + baseClass] = true, _cx[baseClass + '-left'] = position === 'left', _cx[baseClass + '-right'] = position === 'right', _cx)));
  return React.createElement(
    'i',
    { className: classes },
    children
  );
};

process.env.NODE_ENV !== "production" ? ButtonIcon.propTypes = {
  position: PropTypes.oneOf(['left', 'right']).isRequired,
  children: PropTypes.node.isRequired
} : void 0;

var cx$5 = classNames.bind(styles);
var acceptedSizes = ['large', 'compact'];
var acceptedKinds = ['primary', 'secondary', 'destructive', 'text'];

var getDeprecatedKind = function getDeprecatedKind(primary, destructive, secondary) {
  if (primary) {
    return 'primary';
  }

  if (destructive) {
    return 'destructive';
  }

  if (secondary) {
    return 'secondary';
  }

  return null;
};

var Button = React.forwardRef(function (props, ref) {
  var _cx;

  var children = props.children,
      primary = props.primary,
      destructive = props.destructive,
      disabled = props.disabled,
      loading = props.loading,
      loaderLabel = props.loaderLabel,
      icon = props.icon,
      size = props.size,
      fullWidth = props.fullWidth,
      submit = props.submit,
      secondary = props.secondary,
      accessibilityLabel = props.accessibilityLabel,
      ariaControls = props.ariaControls,
      ariaExpanded = props.ariaExpanded,
      className = props.className,
      htmlType = props.type,
      kind = props.kind,
      iconPosition = props.iconPosition,
      buttonProps = objectWithoutProperties(props, ['children', 'primary', 'destructive', 'disabled', 'loading', 'loaderLabel', 'icon', 'size', 'fullWidth', 'submit', 'secondary', 'accessibilityLabel', 'ariaControls', 'ariaExpanded', 'className', 'type', 'kind', 'iconPosition']);


  var isDisabled = disabled || loading;
  var type = submit ? 'submit' : htmlType || 'button';
  var isValidKind = kind && acceptedKinds.includes(kind);
  var deprecatedKind = getDeprecatedKind(primary, destructive, secondary);
  var buttonKind = isValidKind && kind || deprecatedKind || null;

  if (deprecatedKind) {
    noticeAboutDeprecation('deprecated prop \'' + deprecatedKind + '\' in Button component - please use \'kind\' prop instead');
  }

  var baseClass = 'btn';
  var mergedClassNames = getMergedClassNames(cx$5((_cx = {}, _cx[baseClass] = true, _cx[baseClass + '--disabled'] = disabled, _cx[baseClass + '--loading'] = loading, _cx[baseClass + '--full-width'] = fullWidth, _cx[baseClass + '--' + buttonKind] = !!buttonKind, _cx[baseClass + '--' + size] = acceptedSizes.some(function (s) {
    return s === size;
  }), _cx)), className);

  return React.createElement(
    'button',
    _extends({}, buttonProps, {
      ref: ref,
      className: mergedClassNames,
      type: type,
      disabled: isDisabled,
      role: loading ? 'alert' : undefined,
      'aria-busy': loading ? true : undefined,
      'aria-label': accessibilityLabel,
      'aria-controls': ariaControls,
      'aria-expanded': ariaExpanded
    }),
    loading && React.createElement(Loader, {
      size: 'small',
      label: loaderLabel,
      className: styles[baseClass + '__loader'],
      labelClassName: styles[baseClass + '__loader-label']
    }),
    icon && React.createElement(
      ButtonIcon,
      { position: iconPosition },
      icon
    ),
    children && React.createElement(
      'div',
      null,
      children
    )
  );
});

Button.defaultProps = {
  iconPosition: 'left'
};

process.env.NODE_ENV !== "production" ? Button.propTypes = {
  accessibilityLabel: PropTypes.string,
  ariaControls: PropTypes.string,
  ariaExpanded: PropTypes.string,
  children: PropTypes.node.isRequired,
  className: PropTypes.string,
  id: PropTypes.string,
  disabled: PropTypes.bool,
  /**
   * Sets button width to max-width=320px
   */
  fullWidth: PropTypes.bool,
  icon: PropTypes.node,
  loading: PropTypes.bool,
  loaderLabel: PropTypes.node,
  onClick: PropTypes.func,
  onFocus: PropTypes.func,
  onBlur: PropTypes.func,
  /**
   * Size of button
   */
  size: PropTypes.oneOf(['compact', 'large']),
  submit: PropTypes.bool,
  type: PropTypes.string,
  /**
   * Type of button
   */
  kind: PropTypes.oneOf(['primary', 'secondary', 'destructive', 'text']),
  /**
   * Position of provided icon
   */
  iconPosition: PropTypes.oneOf(['left', 'right']),
  /**
   * DEPRECATED - use 'kind' instead
   */
  primary: PropTypes.bool,
  /**
   * DEPRECATED - use 'kind' instead
   */
  destructive: PropTypes.bool,
  /**
   * DEPRECATED - use 'kind' instead
   */
  secondary: PropTypes.bool
} : void 0;

var styles$2 = { "btn-group": "lc-btn-group", "btn": "lc-btn", "active": "lc-active" };

var defaultIndex = -1;
var baseClass$3 = 'btn-group';

var ButtonGroup = function (_React$Component) {
  inherits(ButtonGroup, _React$Component);

  function ButtonGroup() {
    var _temp, _this, _ret;

    classCallCheck(this, ButtonGroup);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      index: defaultIndex
    }, _this.handleClick = function (index, event) {
      if (_this.props.onIndexChange) {
        _this.props.onIndexChange(index, event);
      }
      _this.setState({ currentIndex: index });
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  ButtonGroup.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
    return {
      index: typeof props.currentIndex === 'number' ? props.currentIndex : state.currentIndex
    };
  };

  ButtonGroup.prototype.render = function render() {
    var _this2 = this;

    var index = this.state.index;
    var _props = this.props,
        size = _props.size,
        fullWidth = _props.fullWidth,
        children = _props.children,
        className = _props.className,
        onIndexChange = _props.onIndexChange,
        currentIndex = _props.currentIndex,
        restProps = objectWithoutProperties(_props, ['size', 'fullWidth', 'children', 'className', 'onIndexChange', 'currentIndex']);


    var mappedChildren = React.Children.map(children, function (child, i) {
      var _cx;

      return React.cloneElement(child, {
        size: size,
        fullWidth: fullWidth,
        kind: 'secondary',
        type: 'button',
        onClick: function onClick(event) {
          _this2.handleClick(i, event);
          if (child.props.onClick) {
            child.props.onClick(event);
          }
        },
        className: cx((_cx = {}, _cx[className] = !!className, _cx[styles$2.active] = i === index, _cx))
      });
    });

    return React.createElement(
      'div',
      _extends({ role: 'group', className: styles$2[baseClass$3] }, restProps),
      mappedChildren
    );
  };

  return ButtonGroup;
}(React.Component);

process.env.NODE_ENV !== "production" ? ButtonGroup.propTypes = {
  /**
   * If `true`, the buttons in group will take up the full width of its container
   */
  fullWidth: PropTypes.bool,

  /**
   * Additionall class name for buttons components
   */
  className: PropTypes.string,

  /**
   * Callback fired when the value of `currentIndex` changes
   */
  onIndexChange: PropTypes.func,

  /**
   * The index of button in group which is currently active
   */
  currentIndex: PropTypes.number,

  /**
   * Size of buttons in group
   */
  size: PropTypes.string,

  /**
   * One or more `Button` components
   */
  children: PropTypes.oneOfType([PropTypes.node, PropTypes.arrayOf(PropTypes.node)])
} : void 0;

var styles$3 = { "banner": "lc-banner", "banner--small": "lc-banner--small", "banner__content": "lc-banner__content", "banner__content-text": "lc-banner__content-text", "banner--medium": "lc-banner--medium", "banner--large": "lc-banner--large", "banner__close-icon": "lc-banner__close-icon", "banner--info": "lc-banner--info", "banner--warning": "lc-banner--warning", "banner--success": "lc-banner--success", "banner--error": "lc-banner--error", "banner__icon": "lc-banner__icon" };

var baseClass$4 = 'banner__icon';

var BannerIcon = function BannerIcon(props) {
    var type = props.type;


    switch (type) {
        case 'info':
            return React.createElement(InformationOutlineIcon, { fill: '#4384f5', width: '20px', height: '20px', className: styles$3[baseClass$4] });
        case 'warning':
            return React.createElement(AlertIcon, { fill: '#fb9d01', width: '20px', height: '20px', className: styles$3[baseClass$4] });
        case 'success':
            return React.createElement(CheckCircleIcon, { fill: '#38c776', width: '20px', height: '20px', className: styles$3[baseClass$4] });
        case 'error':
            return React.createElement(BlockHelperIcon, { fill: '#d64646', width: '20px', height: '20px', className: styles$3[baseClass$4] });
    }
};

process.env.NODE_ENV !== "production" ? BannerIcon.propTypes = {
    type: PropTypes.oneOf(['info', 'warning', 'success', 'error']).isRequired
} : void 0;

var cx$6 = classNames.bind(styles$3);

var baseClass$5 = 'banner';

var Banner = function Banner(props) {
  var _cx;

  var children = props.children,
      className = props.className,
      onClose = props.onClose,
      size = props.size,
      type = props.type,
      restProps = objectWithoutProperties(props, ['children', 'className', 'onClose', 'size', 'type']);


  var mergedWrapperClassNames = getMergedClassNames(cx$6((_cx = {}, _cx[baseClass$5 + '--' + type] = type, _cx[baseClass$5 + '--' + size] = size, _cx['' + baseClass$5] = true, _cx)), className);

  return React.createElement(
    'div',
    _extends({ className: mergedWrapperClassNames }, restProps),
    React.createElement(
      'div',
      { className: styles$3[baseClass$5 + '__content'] },
      React.createElement(BannerIcon, { type: type }),
      React.createElement(
        'div',
        { className: styles$3[baseClass$5 + '__content-text'] },
        children
      )
    ),
    onClose && React.createElement(
      'button',
      { type: 'button', onClick: onClose, className: styles$3[baseClass$5 + '__close-icon'] },
      React.createElement(CloseIcon, { fill: '#424d57' })
    )
  );
};
process.env.NODE_ENV !== "production" ? Banner.propTypes = {
  children: PropTypes.node.isRequired,
  onClose: PropTypes.func,
  size: PropTypes.oneOf(['small', 'medium', 'large']),
  type: PropTypes.oneOf(['info', 'warning', 'success', 'error']).isRequired
} : void 0;

Banner.defaultProps = {
  size: 'small',
  type: 'info'
};

var styles$4 = { "card": "lc-card", "card__title": "lc-card__title", "card__text": "lc-card__text", "card__img": "lc-card__img" };

var baseClass$6 = 'card';

var Card = function Card(props) {
  var img = props.img,
      title = props.title,
      children = props.children,
      restProps = objectWithoutProperties(props, ['img', 'title', 'children']);

  var mergedClassNames = getMergedClassNames(styles$4[baseClass$6]);

  return React.createElement(
    'div',
    _extends({}, restProps, { className: mergedClassNames }),
    (img || title) && React.createElement(
      'div',
      { className: styles$4[baseClass$6 + '__title'] },
      img && React.createElement('img', { src: img, className: styles$4[baseClass$6 + '__img'] }),
      title && React.createElement(
        'div',
        { className: styles$4[baseClass$6 + '__text'] },
        title
      )
    ),
    children
  );
};

process.env.NODE_ENV !== "production" ? Card.propTypes = {
  title: PropTypes.oneOfType([PropTypes.string, PropTypes.element]),
  children: PropTypes.node.isRequired,
  img: PropTypes.string
} : void 0;

var styles$5 = { "tab": "lc-tab", "tab__description": "lc-tab__description", "tab--selected": "lc-tab--selected", "tabs": "lc-tabs", "tabs__list": "lc-tabs__list" };

var TabsWrapper = function TabsWrapper(_ref) {
  var _cx;

  var children = _ref.children,
      className = _ref.className,
      restProps = objectWithoutProperties(_ref, ['children', 'className']);
  return React.createElement(
    'div',
    _extends({}, restProps, { className: cx(styles$5.tabs, (_cx = {}, _cx[className] = className, _cx)) }),
    children
  );
};

process.env.NODE_ENV !== "production" ? TabsWrapper.propTypes = {
  children: PropTypes.node.isRequired,
  className: PropTypes.string
} : void 0;

var TabsList = function TabsList(_ref) {
  var _cx;

  var children = _ref.children,
      className = _ref.className,
      restProps = objectWithoutProperties(_ref, ['children', 'className']);
  return React.createElement(
    'div',
    _extends({}, restProps, {
      className: cx(styles$5.tabs__list, (_cx = {}, _cx[className] = className, _cx))
    }),
    children
  );
};

process.env.NODE_ENV !== "production" ? TabsList.propTypes = {
  children: PropTypes.node.isRequired,
  className: PropTypes.string
} : void 0;

var cx$7 = classNames.bind(styles$5);

var Tab = function Tab(_ref) {
  var children = _ref.children,
      className = _ref.className,
      description = _ref.description,
      href = _ref.href,
      isSelected = _ref.isSelected,
      restProps = objectWithoutProperties(_ref, ['children', 'className', 'description', 'href', 'isSelected']);

  var Component = function Component(props) {
    return href ? React.createElement('a', props) : React.createElement('button', props);
  };

  var mergedClassNames = getMergedClassNames(cx$7({
    tab: true,
    'tab--selected': isSelected
  }), className);

  var isDescriptionProvided = description !== null;

  return React.createElement(
    Component,
    _extends({}, restProps, { href: href, className: mergedClassNames }),
    children,
    isDescriptionProvided && React.createElement(
      'span',
      { className: styles$5.tab__description },
      '(',
      description,
      ')'
    )
  );
};

process.env.NODE_ENV !== "production" ? Tab.propTypes = {
  children: PropTypes.node.isRequired,
  className: PropTypes.string,
  description: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.node]),
  href: PropTypes.string,
  isSelected: PropTypes.bool
} : void 0;

Tab.defaultProps = {
  description: null,
  href: null,
  isSelected: false
};

var DIRECTION = {
  Top: 'top',
  Bottom: 'bottom',
  Left: 'left',
  Right: 'right'
};

var ALIGMENT = {
  Top: 'top',
  Center: 'center',
  Bottom: 'bottom',
  Left: 'left',
  Right: 'right'
};

var ARROW_POSITION = {
  Top: 'top',
  Bottom: 'bottom',
  Left: 'left',
  Right: 'right'
};

var TOOLTIP_MARGIN = 4;

var getTooltipPosition = function getTooltipPosition(opts) {
  var direction = opts.direction,
      align = opts.align,
      offset = opts.offset,
      tooltipRefRect = opts.tooltipRefRect,
      tooltipBoxRefRect = opts.tooltipBoxRefRect;


  var tooltipXPosition = void 0;
  var tooltipYPosition = void 0;

  switch (direction) {
    case DIRECTION.Top:
      tooltipYPosition = tooltipRefRect.top - tooltipBoxRefRect.height - offset;
      switch (align) {
        case ALIGMENT.Center:
        default:
          tooltipXPosition = tooltipRefRect.left + (tooltipRefRect.width / 2 - tooltipBoxRefRect.width / 2);
          break;
        case ALIGMENT.Left:
          tooltipXPosition = tooltipRefRect.left - TOOLTIP_MARGIN;
          break;
        case ALIGMENT.Right:
          tooltipXPosition = tooltipRefRect.left + tooltipRefRect.width - tooltipBoxRefRect.width + TOOLTIP_MARGIN;
          break;
      }
      break;

    case DIRECTION.Bottom:
      tooltipYPosition = tooltipRefRect.top + tooltipRefRect.height + offset;
      switch (align) {
        case ALIGMENT.Center:
        default:
          tooltipXPosition = tooltipRefRect.left + (tooltipRefRect.width / 2 - tooltipBoxRefRect.width / 2);
          break;
        case ALIGMENT.Left:
          tooltipXPosition = tooltipRefRect.left - TOOLTIP_MARGIN;
          break;
        case ALIGMENT.Right:
          tooltipXPosition = tooltipRefRect.left + tooltipRefRect.width - tooltipBoxRefRect.width + TOOLTIP_MARGIN;
          break;
      }
      break;

    case DIRECTION.Right:
      tooltipXPosition = tooltipRefRect.left + tooltipRefRect.width + offset;
      switch (align) {
        case ALIGMENT.Center:
        default:
          tooltipYPosition = tooltipRefRect.top + tooltipRefRect.height / 2 - tooltipBoxRefRect.height / 2;
          break;
        case ALIGMENT.Top:
          tooltipYPosition = tooltipRefRect.top - TOOLTIP_MARGIN;
          break;
        case ALIGMENT.Bottom:
          tooltipYPosition = tooltipRefRect.top + tooltipRefRect.height - tooltipBoxRefRect.height + TOOLTIP_MARGIN;
          break;
      }
      break;

    case DIRECTION.Left:
      tooltipXPosition = tooltipRefRect.left - tooltipBoxRefRect.width - offset;
      switch (align) {
        case ALIGMENT.Center:
        default:
          tooltipYPosition = tooltipRefRect.top + tooltipRefRect.height / 2 - tooltipBoxRefRect.height / 2;
          break;
        case ALIGMENT.Top:
          tooltipYPosition = tooltipRefRect.top - TOOLTIP_MARGIN;
          break;
        case ALIGMENT.Bottom:
          tooltipYPosition = tooltipRefRect.top + tooltipRefRect.height - tooltipBoxRefRect.height + TOOLTIP_MARGIN;
          break;
      }
      break;

    default:
      tooltipXPosition = 0;
      tooltipYPosition = 0;
      break;
  }

  return {
    tooltipXPosition: tooltipXPosition,
    tooltipYPosition: tooltipYPosition
  };
};

var getArrowOffsetStyle = function getArrowOffsetStyle(arrowOffset, arrowPosition, arrowAlign) {
  if (!arrowOffset) {
    return {};
  }

  switch (arrowPosition) {
    case ARROW_POSITION.Left:
    case ARROW_POSITION.Right:
      if (arrowAlign === ALIGMENT.Bottom) {
        return { bottom: arrowOffset + 'px', top: 'auto' };
      }
      return { top: arrowOffset + 'px', bottom: 'auto' };
    case ARROW_POSITION.Top:
    case ARROW_POSITION.Bottom:
      if (arrowAlign === ALIGMENT.Right) {
        return { right: arrowOffset + 'px', left: 'auto' };
      }
      return { left: arrowOffset + 'px', right: 'auto' };
    default:
      return {};
  }
};

var styles$6 = { "tooltip": "lc-tooltip", "tooltip--inline": "lc-tooltip--inline", "tooltip__content": "lc-tooltip__content", "tooltip__arrow": "lc-tooltip__arrow", "tooltip__arrow--left": "lc-tooltip__arrow--left", "tooltip__arrow--right": "lc-tooltip__arrow--right", "tooltip__arrow--top": "lc-tooltip__arrow--top", "tooltip__arrow--bottom": "lc-tooltip__arrow--bottom", "tooltip__box": "lc-tooltip__box", "tooltip__box--visible": "lc-tooltip__box--visible", "tooltip__box-content": "lc-tooltip__box-content" };

var cx$8 = classNames.bind(styles$6);

var TooltipContent = function TooltipContent(_ref) {
  var _cx;

  var backgroundColor = _ref.backgroundColor,
      className = _ref.className,
      fontColor = _ref.fontColor,
      arrowPosition = _ref.arrowPosition,
      children = _ref.children,
      arrowOffset = _ref.arrowOffset,
      arrowAlign = _ref.arrowAlign;

  var mergedClassNames = getMergedClassNames(cx$8({
    tooltip__content: true
  }), className);

  noticeAboutDeprecation('deprecated component - Tooltip, please use CSSTooltip or PopperTooltip instead');

  return React.createElement(
    'div',
    {
      className: mergedClassNames,
      style: {
        backgroundColor: backgroundColor,
        color: fontColor,
        borderColor: backgroundColor
      }
    },
    React.createElement('div', {
      className: cx$8((_cx = {
        tooltip__arrow: true
      }, _cx['tooltip__arrow--' + arrowPosition] = true, _cx)),
      style: getArrowOffsetStyle(arrowOffset, arrowPosition, arrowAlign)
    }),
    children
  );
};

process.env.NODE_ENV !== "production" ? TooltipContent.propTypes = {
  backgroundColor: PropTypes.string,
  className: PropTypes.string,
  fontColor: PropTypes.string,
  children: PropTypes.node.isRequired,
  arrowPosition: PropTypes.oneOf([ARROW_POSITION.Left, ARROW_POSITION.Right, ARROW_POSITION.Top, ARROW_POSITION.Bottom]),
  arrowAlign: PropTypes.oneOf([ALIGMENT.Top, ALIGMENT.Bottom, ALIGMENT.Left, ALIGMENT.Right, ALIGMENT.Center]),
  arrowOffset: PropTypes.number
} : void 0;

TooltipContent.defaultProps = {
  arrowPosition: ARROW_POSITION.Left,
  className: ''
};

var noop = function noop() {};
var cx$9 = classNames.bind(styles$6);

var TooltipBox = function TooltipBox(_ref) {
  var isVisible = _ref.isVisible,
      xPosition = _ref.xPosition,
      yPosition = _ref.yPosition,
      contentRef = _ref.contentRef,
      onContentMouseEnter = _ref.onContentMouseEnter,
      onContentMouseLeave = _ref.onContentMouseLeave,
      children = _ref.children;

  noticeAboutDeprecation('deprecated component - Tooltip, please use CSSTooltip or PopperTooltip instead');

  return React.createElement(
    'div',
    {
      className: cx$9({
        tooltip__box: true,
        'tooltip__box--visible': isVisible
      }),
      style: { top: yPosition + 'px', left: xPosition + 'px' },
      onMouseEnter: onContentMouseEnter,
      onMouseLeave: onContentMouseLeave,
      ref: contentRef
    },
    React.createElement(
      'div',
      { className: styles$6['tooltip__box-content'] },
      children
    )
  );
};

process.env.NODE_ENV !== "production" ? TooltipBox.propTypes = {
  children: PropTypes.node.isRequired,
  isVisible: PropTypes.bool.isRequired,
  xPosition: PropTypes.number.isRequired,
  yPosition: PropTypes.number.isRequired,
  onContentMouseEnter: PropTypes.func,
  onContentMouseLeave: PropTypes.func,
  contentRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func, PropTypes.string]).isRequired
} : void 0;

TooltipBox.defaultProps = {
  onContentMouseEnter: noop,
  onContentMouseLeave: noop
};

var Tooltip = function (_React$Component) {
  inherits(Tooltip, _React$Component);

  function Tooltip(props) {
    classCallCheck(this, Tooltip);

    noticeAboutDeprecation('deprecated component - Tooltip, please use CSSTooltip or PopperTooltip instead');

    var _this = possibleConstructorReturn(this, _React$Component.call(this, props));

    _this.onViewportChange = function () {
      if (_this.state.isVisible) {
        _this.setState({ isVisible: false });
      }
    };

    _this.onMouseEnter = function () {
      if (_this.props.trigger === 'hover') {
        _this.setState({ isVisible: true });
      }
    };

    _this.onMouseLeave = function () {
      if (_this.props.trigger === 'hover') {
        _this.setState({ isVisible: false });
      }
    };

    _this.onContentMouseEnter = function () {
      if (_this.props.trigger === 'hover') {
        _this.setState({
          isVisible: _this.props.keepContentVisibleOnHover || false
        });
      }
    };

    _this.onContentMouseLeave = function () {
      if (_this.props.trigger === 'hover') {
        _this.setState({ isVisible: false });
      }
    };

    _this.calculatePosition = function (direction) {
      if (!_this.tooltipRef.current) {
        return true;
      }
      var tooltipRefRect = _this.tooltipRef.current.getBoundingClientRect();
      var tooltipBoxRefRect = _this.tooltipBoxRef.current.getBoundingClientRect();

      _this.lastTooltipRefTop = tooltipRefRect.top;
      _this.lastTooltipRefLeft = tooltipRefRect.left;
      var align = _this.getAlignment(direction);
      var offset = _this.state.offset;

      var _getTooltipPosition = getTooltipPosition({
        direction: direction,
        align: align,
        offset: offset,
        tooltipRefRect: tooltipRefRect,
        tooltipBoxRefRect: tooltipBoxRefRect
      }),
          tooltipXPosition = _getTooltipPosition.tooltipXPosition,
          tooltipYPosition = _getTooltipPosition.tooltipYPosition;

      _this.setState({ xPosition: tooltipXPosition, yPosition: tooltipYPosition });

      return true;
    };

    _this.tooltipRef = React.createRef();
    _this.tooltipBoxRef = React.createRef();


    _this.state = {
      isVisible: false,
      offset: props.offset ? props.offset : 0,
      xPosition: 0,
      yPosition: 0
    };

    _this.viewportListener = dataUtils.throttle(50, _this.onViewportChange);
    return _this;
  }

  Tooltip.getDerivedStateFromProps = function getDerivedStateFromProps(props) {
    if (props.trigger === 'custom') {
      return { isVisible: props.isTooltipVisible };
    }
    return null;
  };

  Tooltip.prototype.componentDidUpdate = function componentDidUpdate(_prevProps, prevState) {
    if (this.state.isVisible && !prevState.isVisible) {
      this.addEventHandlers();
    }

    if (!this.state.isVisible && prevState.isVisible) {
      this.removeEventHandlers();
    }

    if (this.state.isVisible && this.tooltipRef.current) {
      var tooltipRefRect = this.tooltipRef.current.getBoundingClientRect();

      if (tooltipRefRect.top !== this.lastTooltipRefTop || tooltipRefRect.left !== this.lastTooltipRefLeft) {
        this.recalculatePosition();
      }
    }
  };

  Tooltip.prototype.componentWillUnmount = function componentWillUnmount() {
    this.removeEventHandlers();
  };

  Tooltip.prototype.getAlignment = function getAlignment(direction) {
    var _supportedAlignments;

    var supportedAlignments = (_supportedAlignments = {}, _supportedAlignments[DIRECTION.Left] = [ALIGMENT.Center, ALIGMENT.Top, ALIGMENT.Bottom], _supportedAlignments[DIRECTION.Right] = [ALIGMENT.Center, ALIGMENT.Top, ALIGMENT.Bottom], _supportedAlignments[DIRECTION.Top] = [ALIGMENT.Center, ALIGMENT.Left, ALIGMENT.Right], _supportedAlignments[DIRECTION.Bottom] = [ALIGMENT.Center, ALIGMENT.Left, ALIGMENT.Right], _supportedAlignments);

    if (supportedAlignments[direction].indexOf(this.props.align) > -1) {
      return this.props.align;
    }

    return ALIGMENT.Center;
  };

  Tooltip.prototype.addEventHandlers = function addEventHandlers() {
    window.addEventListener('scroll', this.viewportListener);
    window.addEventListener('resize', this.viewportListener);
  };

  Tooltip.prototype.removeEventHandlers = function removeEventHandlers() {
    window.removeEventListener('scroll', this.viewportListener);
    window.removeEventListener('resize', this.viewportListener);
  };

  Tooltip.prototype.recalculatePosition = function recalculatePosition() {
    var directionsChecked = [];
    var tooltipDirection = this.tooltipDirection(directionsChecked);

    while (!this.calculatePosition(tooltipDirection)) {
      directionsChecked.push(tooltipDirection);
      tooltipDirection = this.tooltipDirection(directionsChecked);
    }
  };

  Tooltip.prototype.tooltipDirection = function tooltipDirection(directionsChecked) {
    var defaultQueue = [DIRECTION.Top, DIRECTION.Bottom, DIRECTION.Left, DIRECTION.Right];
    var propsQueue = this.props.directions;

    var _propsQueue$filter = propsQueue.filter(function (direction) {
      return directionsChecked.indexOf(direction) === -1;
    }),
        propsDirection = _propsQueue$filter[0];

    var _defaultQueue$filter = defaultQueue.filter(function (direction) {
      return directionsChecked.indexOf(direction) === -1;
    }),
        defaultDirection = _defaultQueue$filter[0];

    if (propsDirection) {
      return propsDirection;
    } else if (defaultDirection) {
      return defaultDirection;
    }
    return DIRECTION.Top;
  };

  Tooltip.prototype.tooltipClassNames = function tooltipClassNames() {
    var _classNames;

    return cx(styles$6.tooltip, (_classNames = {}, _classNames[styles$6.tooltip + '--inline'] = this.props.inline, _classNames), this.props.className);
  };

  Tooltip.prototype.render = function render() {
    return React.createElement(
      'div',
      {
        className: this.tooltipClassNames(),
        ref: this.tooltipRef,
        onMouseEnter: this.onMouseEnter,
        onMouseLeave: this.onMouseLeave
      },
      this.props.children,
      React.createElement(
        TooltipBox,
        {
          contentRef: this.tooltipBoxRef,
          isVisible: this.props.trigger === 'custom' && this.props.isTooltipVisible || this.state.isVisible,
          xPosition: this.state.xPosition,
          yPosition: this.state.yPosition,
          onContentMouseEnter: this.onContentMouseEnter,
          onContentMouseLeave: this.onContentMouseLeave
        },
        this.props.content
      )
    );
  };

  return Tooltip;
}(React.Component);

process.env.NODE_ENV !== "production" ? Tooltip.propTypes = {
  children: PropTypes.node.isRequired,
  content: PropTypes.node.isRequired,
  className: PropTypes.string,
  keepContentVisibleOnHover: PropTypes.bool,
  isTooltipVisible: PropTypes.bool,
  offset: PropTypes.number,
  trigger: PropTypes.oneOf(['hover', 'click', 'custom']),
  align: PropTypes.oneOf(['top', 'center', 'bottom', 'left', 'right']),
  inline: PropTypes.bool,
  directions: function directions(props, propName, componentName) {
    var values = function values(obj) {
      return Object.keys(obj).map(function (key) {
        return obj[key];
      });
    };

    var validationError = new Error('Invalid prop `' + propName + '` supplied to `' + componentName + '`.\n      Prop should be equal to array with some of values ' + values(DIRECTION).join(', ') + '. Validation failed.');

    if (!Array.isArray(props[propName])) {
      return validationError;
    }

    var check = props[propName].filter(function (v) {
      return values(DIRECTION).some(function (value) {
        return value === v;
      });
    });
    if (check.length !== props[propName].length) {
      return validationError;
    }

    return null;
  }
} : void 0;

Tooltip.defaultProps = {
  className: null,
  keepContentVisibleOnHover: false,
  isTooltipVisible: false,
  offset: 0,
  trigger: 'hover',
  align: 'top',
  inline: false,
  directions: ['bottom']
};

var HORIZONTAL_POSITION = ['left', 'center', 'right'];

var VERTICAL_POSITION = ['top', 'bottom'];

var ANIMATION_TIME = 200;

var INFO = 'info';
var SUCCESS = 'success';
var WARNING = 'warning';
var ERROR = 'error';
var NOTIFICATION = 'notification';

var VARIANTS = [SUCCESS, WARNING, ERROR, INFO, NOTIFICATION];

var styles$7 = { "toast": "lc-toast", "toast__content": "lc-toast__content", "toast__close": "lc-toast__close", "toast__icon": "lc-toast__icon", "toast__actions": "lc-toast__actions", "toast__actions-close": "lc-toast__actions-close", "toast__actions-custom": "lc-toast__actions-custom", "toast--success": "lc-toast--success", "toast--warning": "lc-toast--warning", "toast--error": "lc-toast--error", "toast--info": "lc-toast--info", "toast-wrapper": "lc-toast-wrapper", "toast-wrapper--fixed": "lc-toast-wrapper--fixed", "toast-wrapper--block": "lc-toast-wrapper--block", "toast-wrapper--horizontal-center": "lc-toast-wrapper--horizontal-center", "toast-wrapper--horizontal-left": "lc-toast-wrapper--horizontal-left", "toast-wrapper--horizontal-right": "lc-toast-wrapper--horizontal-right", "toast-wrapper--vertical-top": "lc-toast-wrapper--vertical-top", "toast-appear--slide": "lc-toast-appear--slide", "toast-appear-active--slide": "lc-toast-appear-active--slide", "toast-exit--slide": "lc-toast-exit--slide", "toast-exit-active--slide": "lc-toast-exit-active--slide", "toast-wrapper--vertical-bottom": "lc-toast-wrapper--vertical-bottom", "toast-appear--fade": "lc-toast-appear--fade", "toast-appear-active--fade": "lc-toast-appear-active--fade", "toast-exit--fade": "lc-toast-exit--fade", "toast-exit-active--fade": "lc-toast-exit-active--fade" };

var ToastIcon = function ToastIcon(_ref) {
  var variant = _ref.variant;

  switch (variant) {
    case SUCCESS:
      return React.createElement(CheckCircleIcon, null);
    case WARNING:
      return React.createElement(AlertIcon, null);
    case ERROR:
      return React.createElement(AlertCircleIcon, null);
    default:
      return React.createElement(InformationIcon, null);
  }
};

process.env.NODE_ENV !== "production" ? ToastIcon.propTypes = {
  variant: PropTypes.string
} : void 0;

var callAll = function callAll() {
  for (var _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }

  return function () {
    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return fns.forEach(function (fn) {
      return fn && fn.apply(undefined, args);
    });
  };
};

var cx$a = classNames.bind(styles$7);

var Toast = function Toast(props) {
  var _cx;

  var children = props.children,
      className = props.className,
      variant = props.variant,
      onClose = props.onClose,
      action = props.action,
      removable = props.removable,
      id = props.id,
      restProps = objectWithoutProperties(props, ['children', 'className', 'variant', 'onClose', 'action', 'removable', 'id']);


  var mergedClassNames = getMergedClassNames(cx$a((_cx = {
    toast: true
  }, _cx['toast--' + variant] = VARIANTS.some(function (option) {
    return option === variant;
  }), _cx)), className);

  var onActionClick = function onActionClick(actionProp) {
    if (actionProp && actionProp.closeOnClick && onClose) {
      return callAll(actionProp.handler, onClose);
    }
    return action.handler;
  };

  return React.createElement(
    'div',
    _extends({}, restProps, { className: mergedClassNames, id: id }),
    React.createElement(
      'div',
      { className: styles$7.toast__icon },
      React.createElement(ToastIcon, { variant: variant })
    ),
    React.createElement(
      'div',
      { className: styles$7.toast__content },
      children
    ),
    (action || removable) && React.createElement(
      'div',
      { className: styles$7.toast__actions },
      action && action.label && action.handler && React.createElement(
        'button',
        {
          className: styles$7['toast__actions-custom'],
          onClick: onActionClick(action)
        },
        action.label
      ),
      removable && React.createElement(
        'div',
        {
          className: styles$7['toast__actions-close'],
          'aria-label': 'Close toast',
          onClick: onClose
        },
        React.createElement(CloseIcon, null)
      )
    )
  );
};

process.env.NODE_ENV !== "production" ? Toast.propTypes = {
  children: PropTypes.node.isRequired,
  variant: PropTypes.oneOf(VARIANTS),
  onClose: PropTypes.func,
  removable: PropTypes.bool,
  action: PropTypes.shape({
    handler: PropTypes.func.isRequired,
    label: PropTypes.string.isRequired,
    closeOnClick: PropTypes.bool
  })
} : void 0;

var cx$b = classNames.bind(styles$7);

var ToastWrapper = function ToastWrapper(props) {
  var verticalPosition = props.verticalPosition,
      horizontalPosition = props.horizontalPosition,
      fixed = props.fixed,
      block = props.block,
      toasts = props.toasts,
      animationType = props.animationType,
      className = props.className,
      restProps = objectWithoutProperties(props, ['verticalPosition', 'horizontalPosition', 'fixed', 'block', 'toasts', 'animationType', 'className']);


  var baseClass = 'toast-wrapper';

  var getWrapperClassNames = function getWrapperClassNames() {
    var _cx;

    var wrapperClassNames = cx$b((_cx = {}, _cx[baseClass] = true, _cx[baseClass + '--fixed'] = fixed, _cx[baseClass + '--block'] = !fixed && block, _cx[baseClass + '--horizontal-' + horizontalPosition] = HORIZONTAL_POSITION.some(function (s) {
      return s === horizontalPosition;
    }), _cx[baseClass + '--vertical-' + verticalPosition] = VERTICAL_POSITION.some(function (s) {
      return s === verticalPosition;
    }), _cx[className] = className, _cx));

    return wrapperClassNames;
  };

  return React.createElement(
    'div',
    _extends({}, restProps, { className: getWrapperClassNames() }),
    React.createElement(
      reactTransitionGroup.TransitionGroup,
      { component: null },
      toasts.map(function (_ref) {
        var id = _ref.id,
            variant = _ref.variant,
            content = _ref.content,
            onClose = _ref.onClose,
            removable = _ref.removable,
            action = _ref.action;
        return React.createElement(
          reactTransitionGroup.CSSTransition,
          {
            key: id,
            classNames: {
              enter: 'lc-toast-appear--' + animationType,
              enterActive: 'lc-toast-appear-active--' + animationType,
              exit: 'lc-toast-exit--' + animationType,
              exitActive: 'lc-toast-exit-active--' + animationType
            },
            timeout: ANIMATION_TIME
          },
          React.createElement(
            Toast,
            {
              variant: variant,
              onClose: onClose,
              removable: removable,
              action: action,
              className: styles$7.toast__single
            },
            content
          )
        );
      })
    )
  );
};

process.env.NODE_ENV !== "production" ? ToastWrapper.propTypes = {
  className: PropTypes.string,
  toasts: PropTypes.arrayOf(PropTypes.shape({
    id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    content: PropTypes.node,
    variant: PropTypes.oneOf(VARIANTS),
    autoHideDelayTime: PropTypes.number,
    removable: PropTypes.bool
  })),
  fixed: PropTypes.bool,
  block: PropTypes.bool,
  animationType: PropTypes.string,
  verticalPosition: PropTypes.string,
  horizontalPosition: PropTypes.string
} : void 0;

ToastWrapper.defaultProps = {
  toasts: [],
  fixed: true,
  block: false,
  animationType: 'slide',
  verticalPosition: 'top',
  horizontalPosition: 'center'
};

var generateNotificationUniqueId = function generateNotificationUniqueId(notifications) {
  return dataUtils.generateUniqueId(notifications);
};

var NotificationContext = React.createContext({});

var NotificationQueueManager = function () {
  function NotificationQueueManager(itemsLimit, queueLimit) {
    classCallCheck(this, NotificationQueueManager);

    this.queue = [];
    this.queueLimit = queueLimit;
    this.itemsLimit = itemsLimit;
  }

  NotificationQueueManager.prototype.shouldAddToQueue = function shouldAddToQueue(currentItems) {
    if (currentItems.length >= this.itemsLimit && this.queue.length <= this.queueLimit) {
      return true;
    }
    return false;
  };

  NotificationQueueManager.prototype.shouldPickFromQueue = function shouldPickFromQueue(currentItems) {
    return this.itemsLimit && this.queue.length > 0 && currentItems.length < this.itemsLimit;
  };

  NotificationQueueManager.prototype.addToQueue = function addToQueue(toast) {
    this.queue = [].concat(this.queue, [toast]);
    return toast.id;
  };

  NotificationQueueManager.prototype.pickFromQueue = function pickFromQueue() {
    var _queue = this.queue,
        picked = _queue[0],
        restQueued = _queue.slice(1);

    this.queue = restQueued;

    return picked;
  };

  NotificationQueueManager.prototype.clearQueue = function clearQueue() {
    this.queue = [];
  };

  return NotificationQueueManager;
}();

var initialState = {
  notifications: {}
};

var NotificationProvider = function (_React$Component) {
  inherits(NotificationProvider, _React$Component);

  function NotificationProvider(props) {
    classCallCheck(this, NotificationProvider);

    var _this = possibleConstructorReturn(this, _React$Component.call(this, props));

    _this.setRemoveDelay = function (notification) {
      if (notification.autoHideDelayTime) {
        _this.timeouts[notification.id] = setTimeout(function () {
          _this.remove(notification.id);
        }, notification.autoHideDelayTime);
      }
    };

    _this.add = function (opts) {
      var _babelHelpers$extends;

      var defaults$$1 = {
        type: 'toast',
        autoHideDelayTime: null,
        payload: {}
      };

      var notifications = _this.state.notifications;


      var notificationId = generateNotificationUniqueId(notifications);

      var notification = _extends({}, defaults$$1, opts, {
        id: notificationId
      });

      if (_this.queueManager && _this.queueManager.shouldAddToQueue(Object.keys(notifications))) {
        return _this.queueManager.addToQueue(notification);
      }

      if (Object.keys(notifications).length >= _this.props.itemsLimit) {
        return null;
      }

      _this.setState({
        notifications: _extends({}, notifications, (_babelHelpers$extends = {}, _babelHelpers$extends[notificationId] = _extends({}, notification), _babelHelpers$extends))
      }, function () {
        return _this.setRemoveDelay(notification);
      });
      return notificationId;
    };

    _this.remove = function (notificationId) {
      var _this$state$notificat = _this.state.notifications,
          removedNotification = _this$state$notificat[notificationId],
          restNotifications = objectWithoutProperties(_this$state$notificat, [notificationId]);


      var newState = { notifications: _extends({}, restNotifications) };
      var notificationFromQueue = void 0;

      if (_this.queueManager && _this.queueManager.shouldPickFromQueue(Object.keys(restNotifications))) {
        var _babelHelpers$extends2;

        notificationFromQueue = _this.queueManager.pickFromQueue();
        newState = {
          notifications: _extends({}, restNotifications, (_babelHelpers$extends2 = {}, _babelHelpers$extends2[notificationFromQueue.id] = notificationFromQueue, _babelHelpers$extends2))
        };
      }

      _this.clearDelayTimeout(notificationId);

      if (!notificationFromQueue) {
        _this.setState(newState);
        return null;
      }

      _this.setState(newState, function () {
        return _this.setRemoveDelay(notificationFromQueue);
      });
      return notificationFromQueue.id;
    };

    _this.removeAll = function () {
      var notificationsIds = Object.keys(_this.state.notifications);
      _this.setState(initialState);
      if (_this.queueManager) {
        _this.queueManager.clearQueue();
      }
      return notificationsIds;
    };

    _this.clearDelayTimeout = function (id) {
      var _this$timeouts = _this.timeouts,
          timeoutToClear = _this$timeouts[id],
          restTimeouts = objectWithoutProperties(_this$timeouts, [id]);

      clearTimeout(timeoutToClear);
      _this.timeouts = restTimeouts;
    };

    _this.state = initialState;
    _this.timeouts = {};
    if (props.queueLimit) {
      _this.queueManager = new NotificationQueueManager(props.itemsLimit, props.queueLimit);
    }
    return _this;
  }

  NotificationProvider.prototype.componentWillUnmount = function componentWillUnmount() {
    var _this2 = this;

    Object.keys(this.timeouts).forEach(function (t) {
      return clearTimeout(_this2.timeouts[t]);
    });
  };

  NotificationProvider.prototype.render = function render() {
    var notifications = this.state.notifications;


    return React.createElement(
      NotificationContext.Provider,
      {
        value: {
          add: this.add,
          remove: this.remove,
          removeAll: this.removeAll,
          notifications: Object.keys(notifications).map(function (id) {
            return _extends({}, notifications[id]);
          })
        }
      },
      this.props.children
    );
  };

  return NotificationProvider;
}(React.Component);

process.env.NODE_ENV !== "production" ? NotificationProvider.propTypes = {
  children: PropTypes.node,
  itemsLimit: PropTypes.number,
  queueLimit: PropTypes.number
} : void 0;

NotificationProvider.defaultProps = {
  itemsLimit: 1
};

var ToastConsumer = function (_React$Component) {
  inherits(ToastConsumer, _React$Component);

  function ToastConsumer() {
    var _temp, _this, _ret;

    classCallCheck(this, ToastConsumer);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.validateToast = function (_ref) {
      var payload = _ref.payload;

      if (!VARIANTS.some(function (v) {
        return v === payload.variant;
      })) {
        return false;
      }

      if ((_this.props.name || payload.consumerName) && _this.props.name !== payload.consumerName) {
        return false;
      }

      if (_this.props.verticalPosition !== payload.verticalPosition || _this.props.horizontalPosition !== payload.horizontalPosition) {
        return false;
      }

      return true;
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  ToastConsumer.prototype.render = function render() {
    var _this2 = this;

    var _props = this.props,
        verticalPosition = _props.verticalPosition,
        horizontalPosition = _props.horizontalPosition,
        fixed = _props.fixed,
        name = _props.name,
        animationType = _props.animationType,
        restProps = objectWithoutProperties(_props, ['verticalPosition', 'horizontalPosition', 'fixed', 'name', 'animationType']);


    return React.createElement(
      NotificationContext.Consumer,
      null,
      function (notificationSystem) {
        return React.createElement(ToastWrapper, _extends({}, restProps, {
          fixed: fixed,
          verticalPosition: verticalPosition,
          horizontalPosition: horizontalPosition,
          animationType: animationType,
          toasts: notificationSystem.notifications.filter(_this2.validateToast).map(function (el) {
            return {
              content: el.payload.content,
              variant: el.payload.variant,
              id: el.id,
              removable: el.payload.removable,
              onClose: callAll(el.payload.onClose, function () {
                return notificationSystem.remove(el.id);
              }),
              action: el.payload.action
            };
          })
        }));
      }
    );
  };

  return ToastConsumer;
}(React.Component);

process.env.NODE_ENV !== "production" ? ToastConsumer.propTypes = {
  /**
   * fixed position of toasts
   */
  name: PropTypes.string,
  fixed: PropTypes.bool,
  animationType: PropTypes.string,
  verticalPosition: PropTypes.string.isRequired,
  horizontalPosition: PropTypes.string.isRequired
} : void 0;

ToastConsumer.defaultProps = {
  animationType: 'slide',
  fixed: true
};

var notificationConnect = function notificationConnect(Component) {
  return function ComponentWithNotifications(props) {
    return React.createElement(
      NotificationContext.Consumer,
      null,
      function (_ref) {
        var add = _ref.add,
            remove = _ref.remove,
            removeAll = _ref.removeAll;
        return React.createElement(Component, _extends({}, props, {
          notificationSystem: { add: add, remove: remove, removeAll: removeAll }
        }));
      }
    );
  };
};

var styles$8 = { "modal-base": "lc-modal-base", "modal-base__overlay": "lc-modal-base__overlay", "modal-base__close": "lc-modal-base__close", "modal-base__overlay--visible": "lc-modal-base__overlay--visible", "modal__header": "lc-modal__header", "modal__heading": "lc-modal__heading", "modal__body": "lc-modal__body", "modal__footer": "lc-modal__footer", "action-modal": "lc-action-modal", "action-modal__heading": "lc-action-modal__heading", "action-modal__content": "lc-action-modal__content", "action-modal__actions": "lc-action-modal__actions", "action-modal__icon": "lc-action-modal__icon" };

var KeyCodes = {
  enter: 13,
  arrowUp: 38,
  arrowDown: 40,
  esc: 27,
  space: 32,
  backspace: 8
};

var KeyNames = {
  enter: 'Enter',
  arrowUp: 'ArrowUp',
  arrowDown: 'ArrowDown',
  esc: 'Escape',
  space: ' '
};

var baseClass$7 = 'modal-base__close';

var ModalCloseButton = function ModalCloseButton(props) {
  return React.createElement(
    'button',
    {
      title: 'Close modal',
      className: styles$8['' + baseClass$7],
      onClick: props.onClick,
      type: 'button'
    },
    React.createElement(CloseIcon, { width: '24px', height: '24px', fill: '#424D57' })
  );
};

process.env.NODE_ENV !== "production" ? ModalCloseButton.propTypes = {
  onClick: PropTypes.func
} : void 0;

var baseClass$8 = 'modal-base';

var cx$c = classNames.bind(styles$8);

var ModalBase = function (_React$Component) {
  inherits(ModalBase, _React$Component);

  function ModalBase() {
    var _temp, _this, _ret;

    classCallCheck(this, ModalBase);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.onOverlayClick = function (event) {
      if (event.target === event.currentTarget) {
        _this.handleCloseModal();
      }
    }, _this.onCloseButtonClick = function (event) {
      event.preventDefault();
      event.stopPropagation();
      _this.handleCloseModal();
    }, _this.onKeyUp = function (event) {
      if (event.keyCode === KeyCodes.esc) {
        _this.handleCloseModal();
      }
    }, _this.addEventListeners = function () {
      if (_this.props.closeOnEscPress) {
        document.addEventListener('keyup', _this.onKeyUp, true);
      }
    }, _this.removeEventListeners = function () {
      document.removeEventListener('keyup', _this.onKeyUp, true);
    }, _this.handleCloseModal = function () {
      _this.props.onClose();
    }, _this.modalRef = React.createRef(), _temp), possibleConstructorReturn(_this, _ret);
  }

  ModalBase.prototype.componentDidMount = function componentDidMount() {
    this.addEventListeners();
  };

  ModalBase.prototype.componentWillUnmount = function componentWillUnmount() {
    this.removeEventListeners();
  };

  ModalBase.prototype.render = function render() {
    var _props = this.props,
        className = _props.className,
        children = _props.children,
        onClose = _props.onClose,
        closeOnEscPress = _props.closeOnEscPress,
        restProps = objectWithoutProperties(_props, ['className', 'children', 'onClose', 'closeOnEscPress']);


    var mergedClassNames = getMergedClassNames(styles$8['' + baseClass$8], className);

    return React.createElement(
      'div',
      {
        onMouseDown: this.onOverlayClick,
        className: cx$c(baseClass$8 + '__overlay', baseClass$8 + '__overlay--visible')
      },
      React.createElement(
        'div',
        _extends({ className: mergedClassNames }, restProps, { ref: this.modalRef }),
        React.createElement(ModalCloseButton, { onClick: this.onCloseButtonClick }),
        children
      )
    );
  };

  return ModalBase;
}(React.Component);

ModalBase.defaultProps = {
  closeOnEscPress: true
};


process.env.NODE_ENV !== "production" ? ModalBase.propTypes = {
  className: PropTypes.string,
  children: PropTypes.node,
  onClose: PropTypes.func.isRequired,
  closeOnEscPress: PropTypes.bool
} : void 0;

var ModalPortal = function (_React$Component) {
  inherits(ModalPortal, _React$Component);

  function ModalPortal(props) {
    classCallCheck(this, ModalPortal);

    var _this = possibleConstructorReturn(this, _React$Component.call(this, props));

    _this.modalContainer = document.createElement('div');
    if (props.className) {
      _this.modalContainer.className = props.className;
    }
    if (props.zIndex != null) {
      _this.modalContainer.style.zIndex = props.zIndex;
    }
    return _this;
  }

  ModalPortal.prototype.componentDidMount = function componentDidMount() {
    document.querySelector(this.props.parentElementName).appendChild(this.modalContainer);
  };

  ModalPortal.prototype.componentWillUnmount = function componentWillUnmount() {
    document.querySelector(this.props.parentElementName).removeChild(this.modalContainer);
  };

  ModalPortal.prototype.render = function render() {
    return ReactDOM.createPortal(this.props.children, this.modalContainer);
  };

  return ModalPortal;
}(React.Component);

ModalPortal.defaultProps = {
  parentElementName: 'body'
};


process.env.NODE_ENV !== "production" ? ModalPortal.propTypes = {
  className: PropTypes.string,
  children: PropTypes.node.isRequired,
  zIndex: PropTypes.number,
  parentElementName: PropTypes.string
} : void 0;

var baseClass$9 = 'modal';

var ModalHeader = function ModalHeader(props) {
  var mergedClassNames = getMergedClassNames(styles$8[baseClass$9 + '__header'], props.className);

  return React.createElement(
    'div',
    { className: mergedClassNames },
    React.createElement(
      'div',
      { className: styles$8[baseClass$9 + '__heading'] },
      props.children
    )
  );
};

process.env.NODE_ENV !== "production" ? ModalHeader.propTypes = {
  className: PropTypes.string,
  children: PropTypes.node
} : void 0;

var baseClass$a = 'modal__body';

var ModalBody = function ModalBody(props) {
  var className = props.className,
      children = props.children,
      restProps = objectWithoutProperties(props, ['className', 'children']);

  var mergedClassNames = getMergedClassNames(styles$8['' + baseClass$a], props.className);

  return React.createElement(
    'div',
    _extends({}, restProps, { className: mergedClassNames }),
    props.children
  );
};

process.env.NODE_ENV !== "production" ? ModalBody.propTypes = {
  className: PropTypes.string,
  children: PropTypes.node
} : void 0;

var baseClass$b = 'modal__footer';

var ModalFooter = function ModalFooter(props) {
  var mergedClassNames = getMergedClassNames(styles$8['' + baseClass$b], props.className);

  return React.createElement(
    'div',
    { className: mergedClassNames },
    props.children
  );
};

process.env.NODE_ENV !== "production" ? ModalFooter.propTypes = {
  className: PropTypes.string,
  children: PropTypes.node
} : void 0;

var baseClass$c = 'modal';

var Modal = function Modal(props) {
  var heading = props.heading,
      footer = props.footer,
      children = props.children,
      className = props.className,
      restProps = objectWithoutProperties(props, ['heading', 'footer', 'children', 'className']);


  var mergedClassNames = getMergedClassNames(styles$8['' + baseClass$c], className);

  return React.createElement(
    ModalBase,
    _extends({ className: mergedClassNames }, restProps),
    heading && React.createElement(
      ModalHeader,
      null,
      heading
    ),
    React.createElement(
      ModalBody,
      null,
      children
    ),
    footer && React.createElement(
      ModalFooter,
      null,
      footer
    )
  );
};

process.env.NODE_ENV !== "production" ? Modal.propTypes = _extends({}, ModalBase.propTypes, {
  heading: PropTypes.node,
  footer: PropTypes.node
}) : void 0;

var baseClass$d = 'action-modal__heading';

var ActionModalHeading = function ActionModalHeading(props) {
  var className = props.className,
      children = props.children,
      restProps = objectWithoutProperties(props, ['className', 'children']);

  var mergedClassNames = getMergedClassNames(styles$8['' + baseClass$d], props.className);

  return React.createElement(
    'h2',
    _extends({}, restProps, { className: mergedClassNames }),
    props.children
  );
};

process.env.NODE_ENV !== "production" ? ActionModalHeading.propTypes = {
  className: PropTypes.string,
  children: PropTypes.node
} : void 0;

var baseClass$e = 'action-modal__actions';

var ActionModalActions = function ActionModalActions(props) {
  var className = props.className,
      children = props.children,
      restProps = objectWithoutProperties(props, ['className', 'children']);

  var mergedClassNames = getMergedClassNames(styles$8['' + baseClass$e], props.className);

  return React.createElement(
    'div',
    _extends({}, restProps, { className: mergedClassNames }),
    props.children
  );
};

process.env.NODE_ENV !== "production" ? ActionModalActions.propTypes = {
  className: PropTypes.string,
  children: PropTypes.node
} : void 0;

var baseClass$f = 'action-modal__content';

var ActionModalContent = function ActionModalContent(props) {
  var className = props.className,
      children = props.children,
      restProps = objectWithoutProperties(props, ['className', 'children']);

  var mergedClassNames = getMergedClassNames(styles$8['' + baseClass$f], props.className);

  return React.createElement(
    'div',
    _extends({}, restProps, { className: mergedClassNames }),
    props.children
  );
};

process.env.NODE_ENV !== "production" ? ActionModalContent.propTypes = {
  className: PropTypes.string,
  children: PropTypes.node
} : void 0;

var baseClass$g = 'action-modal__icon';

var ActionModalIcon = function ActionModalIcon(props) {
  var className = props.className,
      children = props.children,
      restProps = objectWithoutProperties(props, ['className', 'children']);

  var mergedClassNames = getMergedClassNames(styles$8['' + baseClass$g], props.className);

  return React.createElement(
    'div',
    _extends({}, restProps, { className: mergedClassNames }),
    props.children
  );
};

process.env.NODE_ENV !== "production" ? ActionModalIcon.propTypes = {
  className: PropTypes.string,
  children: PropTypes.node
} : void 0;

var baseClass$h = 'action-modal';

var ActionModal = function ActionModal(props) {
  var heading = props.heading,
      actions = props.actions,
      icon = props.icon,
      children = props.children,
      className = props.className,
      restProps = objectWithoutProperties(props, ['heading', 'actions', 'icon', 'children', 'className']);


  var mergedClassNames = getMergedClassNames(styles$8['' + baseClass$h], className);

  return React.createElement(
    ModalBase,
    _extends({ className: mergedClassNames }, restProps),
    icon && React.createElement(
      ActionModalIcon,
      null,
      icon
    ),
    heading && React.createElement(
      ActionModalHeading,
      null,
      heading
    ),
    React.createElement(
      ActionModalContent,
      null,
      children
    ),
    actions && React.createElement(
      ActionModalActions,
      null,
      actions
    )
  );
};

process.env.NODE_ENV !== "production" ? ActionModal.propTypes = _extends({}, ModalBase.propTypes, {
  icon: PropTypes.node,
  heading: PropTypes.node,
  actions: PropTypes.node
}) : void 0;

var styles$9 = { "text-field": "lc-text-field", "text-field--inline": "lc-text-field--inline", "text-field__wrapper--inline": "lc-text-field__wrapper--inline", "text-field__label": "lc-text-field__label", "text-field__label--inline": "lc-text-field__label--inline", "text-field__label--no-text": "lc-text-field__label--no-text", "text-field__label-wrapper": "lc-text-field__label-wrapper", "text-field__label-adornment": "lc-text-field__label-adornment", "text-field__label-right-node": "lc-text-field__label-right-node", "text-field__label-right-node--inline": "lc-text-field__label-right-node--inline", "text-field__row-break": "lc-text-field__row-break", "text-field__content": "lc-text-field__content" };

var styles$a = { "field-label": "lc-field-label" };

var FieldLabel = function FieldLabel(_ref) {
  var className = _ref.className,
      restProps = objectWithoutProperties(_ref, ['className']);

  var mergedClassNames = getMergedClassNames(styles$a['field-label'], className);

  return React.createElement('label', _extends({ className: mergedClassNames }, restProps));
};

var styles$b = { "field-error": "lc-field-error" };

var FieldError = function FieldError(_ref) {
  var children = _ref.children,
      className = _ref.className;

  var mergedClassNames = getMergedClassNames(styles$b['field-error'], className);

  return React.createElement(
    'span',
    { className: mergedClassNames },
    children
  );
};

process.env.NODE_ENV !== "production" ? FieldError.propTypes = {
  children: PropTypes.node,
  className: PropTypes.string
} : void 0;

var styles$c = { "field-description": "lc-field-description" };

var FieldDescription = function FieldDescription(_ref) {
  var children = _ref.children,
      className = _ref.className;

  var mergedClassNames = getMergedClassNames(styles$c['field-description'], className);

  return React.createElement(
    'span',
    { className: mergedClassNames },
    children
  );
};

process.env.NODE_ENV !== "production" ? FieldDescription.propTypes = {
  children: PropTypes.node,
  className: PropTypes.string
} : void 0;

var cx$d = classNames.bind(styles$9);

var TextField = function TextField(props) {
  var _cx;

  var inline = props.inline,
      error = props.error,
      description = props.description,
      labelText = props.labelText,
      labelAdornment = props.labelAdornment,
      className = props.className,
      htmlFor = props.htmlFor,
      children = props.children,
      labelRightNode = props.labelRightNode;


  var baseClass = "text-field";
  var mergedClassNames = getMergedClassNames(cx$d((_cx = {}, _cx[baseClass] = true, _cx[baseClass + "--inline"] = inline, _cx)), className);

  return React.createElement(
    "div",
    { className: mergedClassNames },
    labelRightNode && inline && React.createElement(
      React.Fragment,
      null,
      React.createElement(
        "div",
        { className: cx$d([baseClass + "__label-right-node", baseClass + "__label-right-node--inline"]) },
        labelRightNode
      ),
      React.createElement("div", { className: cx$d(baseClass + "__row-break") })
    ),
    React.createElement(
      "div",
      { className: cx$d([baseClass + "__wrapper", inline && baseClass + "__wrapper--inline"]) },
      (labelText || labelRightNode) && React.createElement(
        "div",
        { className: cx$d([baseClass + "__label", inline && baseClass + "__label--inline", !labelText && baseClass + "__label--no-text"]) },
        labelText && React.createElement(
          "div",
          {
            className: cx$d(baseClass + "__label-wrapper")
          },
          React.createElement(
            FieldLabel,
            { htmlFor: htmlFor },
            labelText
          ),
          labelAdornment && React.createElement(
            "div",
            { className: cx$d(baseClass + "__label-adornment") },
            labelAdornment
          )
        ),
        labelRightNode && !inline && React.createElement(
          "div",
          { className: cx$d(baseClass + "__label-right-node") },
          labelRightNode
        )
      ),
      React.createElement(
        "div",
        { className: cx$d(baseClass + "__content") },
        children,
        error && React.createElement(
          FieldError,
          null,
          error
        ),
        description && React.createElement(
          FieldDescription,
          null,
          description
        )
      )
    )
  );
};

process.env.NODE_ENV !== "production" ? TextField.propTypes = {
  labelText: PropTypes.string,
  /**  specifies additional decorative element rendered at the end of the label */
  labelAdornment: PropTypes.node,
  htmlFor: PropTypes.string.isRequired,
  className: PropTypes.string,
  inline: PropTypes.bool,
  error: PropTypes.string,
  description: PropTypes.node,
  children: PropTypes.node,
  labelRightNode: PropTypes.node
} : void 0;

var styles$d = { "input": "lc-input", "input--error": "lc-input--error" };

var cx$e = classNames.bind(styles$d);

var Input = React.forwardRef(function (props, ref) {
  var error = props.error,
      className = props.className,
      width = props.width,
      style = props.style,
      restProps = objectWithoutProperties(props, ['error', 'className', 'width', 'style']);


  var mergedClassNames = getMergedClassNames(cx$e({
    input: true,
    'input--error': error
  }), className);

  var mergedStyle = style || width ? _extends({
    width: width
  }, style || {}) : void 0;

  return React.createElement('input', _extends({ ref: ref, className: mergedClassNames, style: mergedStyle }, restProps));
});

process.env.NODE_ENV !== "production" ? Input.propTypes = {
  error: PropTypes.string,
  className: PropTypes.string,
  type: PropTypes.string,
  maxLength: PropTypes.number,
  width: PropTypes.string
} : void 0;

Input.defaultProps = {
  type: 'text'
};

var InputField = React.forwardRef(function (props, ref) {
  var inline = props.inline,
      error = props.error,
      description = props.description,
      labelText = props.labelText,
      labelAdornment = props.labelAdornment,
      className = props.className,
      id = props.id,
      fieldClassName = props.fieldClassName,
      labelRightNode = props.labelRightNode,
      inputWidth = props.inputWidth,
      maxLength = props.maxLength,
      restProps = objectWithoutProperties(props, ['inline', 'error', 'description', 'labelText', 'labelAdornment', 'className', 'id', 'fieldClassName', 'labelRightNode', 'inputWidth', 'maxLength']);


  return React.createElement(
    TextField,
    {
      inline: inline,
      error: error,
      description: description,
      labelText: labelText,
      labelAdornment: labelAdornment,
      className: className,
      htmlFor: id,
      labelRightNode: labelRightNode
    },
    React.createElement(Input, _extends({}, restProps, {
      ref: ref,
      width: inputWidth,
      className: fieldClassName,
      id: id,
      error: error,
      maxLength: maxLength
    }))
  );
});

process.env.NODE_ENV !== "production" ? InputField.propTypes = {
  labelText: PropTypes.string,
  /**  specifies additional decorative element rendered at the end of the label */
  labelAdornment: PropTypes.node,
  id: PropTypes.string.isRequired,
  onChange: PropTypes.func.isRequired,
  className: PropTypes.string,
  fieldClassName: PropTypes.string,
  inline: PropTypes.bool,
  error: PropTypes.string,
  description: PropTypes.node,
  labelRightNode: PropTypes.node,
  /** use to easily setup input width - by default the input takes 100% of its container width */
  inputWidth: PropTypes.string,
  maxLength: PropTypes.number
} : void 0;

var styles$e = { "textarea": "lc-textarea", "textarea--error": "lc-textarea--error" };

var cx$f = classNames.bind(styles$e);

var TextArea = React.forwardRef(function (props, ref) {
  var _cx;

  var error = props.error,
      className = props.className,
      width = props.width,
      style = props.style,
      restProps = objectWithoutProperties(props, ['error', 'className', 'width', 'style']);


  var baseClass = 'textarea';
  var mergedClassNames = getMergedClassNames(cx$f((_cx = {}, _cx[baseClass] = true, _cx[baseClass + '--error'] = error, _cx)), className);
  var mergedStyle = style || width ? _extends({
    width: width
  }, style || {}) : void 0;

  return React.createElement('textarea', _extends({ ref: ref, className: mergedClassNames, style: mergedStyle }, restProps));
});

process.env.NODE_ENV !== "production" ? TextArea.propTypes = {
  error: PropTypes.string,
  className: PropTypes.string
} : void 0;

var TextAreaField = React.forwardRef(function (props, ref) {
  var inline = props.inline,
      error = props.error,
      description = props.description,
      labelText = props.labelText,
      labelAdornment = props.labelAdornment,
      className = props.className,
      textareaWidth = props.textareaWidth,
      id = props.id,
      fieldClassName = props.fieldClassName,
      labelRightNode = props.labelRightNode,
      restProps = objectWithoutProperties(props, ['inline', 'error', 'description', 'labelText', 'labelAdornment', 'className', 'textareaWidth', 'id', 'fieldClassName', 'labelRightNode']);


  return React.createElement(
    TextField,
    {
      inline: inline,
      error: error,
      description: description,
      labelText: labelText,
      labelAdornment: labelAdornment,
      className: className,
      htmlFor: id,
      labelRightNode: labelRightNode
    },
    React.createElement(TextArea, _extends({
      id: id,
      ref: ref,
      width: textareaWidth
    }, restProps, {
      className: fieldClassName,
      error: error
    }))
  );
});

process.env.NODE_ENV !== "production" ? TextAreaField.propTypes = {
  labelText: PropTypes.string,
  /**  specifies additional decorative element rendered at the end of the label */
  labelAdornment: PropTypes.node,
  id: PropTypes.string.isRequired,
  className: PropTypes.string,
  inline: PropTypes.bool,
  /** use to easily setup textarea width - by default the element takes 100% of its container width */
  textareaWidth: PropTypes.string,
  error: PropTypes.string,
  description: PropTypes.node,
  fieldClassName: PropTypes.string,
  labelRightNode: PropTypes.node
} : void 0;

var styles$f = { "radio": "lc-radio", "radio__label": "lc-radio__label", "radio__circle": "lc-radio__circle", "radio__inner-circle": "lc-radio__inner-circle", "radio--selected": "lc-radio--selected", "radio__text": "lc-radio__text", "radio__input": "lc-radio__input", "radio--disabled": "lc-radio--disabled", "radio__helper": "lc-radio__helper" };

var cx$g = classNames.bind(styles$f);

var RadioButton = function RadioButton(props) {
  var _cx;

  var className = props.className,
      children = props.children,
      checked = props.checked,
      disabled = props.disabled,
      description = props.description,
      restProps = objectWithoutProperties(props, ['className', 'children', 'checked', 'disabled', 'description']);


  var baseClass = 'radio';
  var mergedClassNames = getMergedClassNames(cx$g((_cx = {}, _cx[baseClass] = true, _cx[baseClass + '--selected'] = checked, _cx[baseClass + '--disabled'] = disabled, _cx)), className);

  return React.createElement(
    'div',
    { className: mergedClassNames },
    React.createElement(
      'label',
      { className: styles$f[baseClass + '__label'] },
      React.createElement(
        'div',
        { className: styles$f[baseClass + '__circle'] },
        React.createElement('span', { className: styles$f[baseClass + '__inner-circle'] }),
        React.createElement('input', _extends({
          className: styles$f[baseClass + '__input']
        }, restProps, {
          type: 'radio',
          checked: checked,
          disabled: disabled
        }))
      ),
      React.createElement(
        'div',
        { className: styles$f[baseClass + '__text'] },
        children
      )
    ),
    description && React.createElement(
      FieldDescription,
      { className: styles$f[baseClass + '__helper'] },
      description
    )
  );
};

process.env.NODE_ENV !== "production" ? RadioButton.propTypes = {
  className: PropTypes.string,
  onChange: PropTypes.func,
  checked: PropTypes.bool,
  children: PropTypes.node.isRequired,
  description: PropTypes.string,
  disabled: PropTypes.bool
} : void 0;

RadioButton.defaultProps = {
  onChange: function onChange() {}
};

var styles$g = { "checkbox": "lc-checkbox", "checkbox__label": "lc-checkbox__label", "checkbox__square": "lc-checkbox__square", "checkbox__checkmark": "lc-checkbox__checkmark", "checkbox--selected": "lc-checkbox--selected", "checkbox__text": "lc-checkbox__text", "checkbox__input": "lc-checkbox__input", "checkbox--disabled": "lc-checkbox--disabled", "checkbox__helper": "lc-checkbox__helper" };

var baseClass$i = 'checkbox';

var Checkbox = function Checkbox(props) {
  var className = props.className,
      restProps = objectWithoutProperties(props, ['className']);

  var mergedClassNames = getMergedClassNames(styles$g[baseClass$i + '__square'], className);
  return React.createElement(
    'div',
    null,
    React.createElement('input', _extends({
      className: styles$g[baseClass$i + '__input']
    }, restProps, {
      type: 'checkbox'
    })),
    React.createElement(
      'div',
      { className: mergedClassNames },
      React.createElement(CheckIcon, { className: styles$g[baseClass$i + '__checkmark'] })
    )
  );
};

var cx$h = classNames.bind(styles$g);

var CheckboxField = function CheckboxField(props) {
  var _cx;

  var className = props.className,
      children = props.children,
      checked = props.checked,
      disabled = props.disabled,
      description = props.description,
      restProps = objectWithoutProperties(props, ['className', 'children', 'checked', 'disabled', 'description']);


  var baseClass = 'checkbox';
  var mergedClassNames = getMergedClassNames(cx$h((_cx = {}, _cx[baseClass] = true, _cx[baseClass + '--selected'] = checked, _cx[baseClass + '--disabled'] = disabled, _cx)), className);

  return React.createElement(
    'div',
    { className: mergedClassNames },
    React.createElement(
      'label',
      { className: styles$g[baseClass + '__label'] },
      React.createElement(Checkbox, _extends({}, restProps, { checked: checked, disabled: disabled })),
      React.createElement(
        'div',
        { className: styles$g[baseClass + '__text'] },
        children
      )
    ),
    description && React.createElement(
      FieldDescription,
      { className: styles$g[baseClass + '__helper'] },
      description
    )
  );
};

process.env.NODE_ENV !== "production" ? CheckboxField.propTypes = {
  className: PropTypes.string,
  onClick: PropTypes.func,
  onChange: PropTypes.func,
  checked: PropTypes.bool.isRequired,
  children: PropTypes.node.isRequired,
  description: PropTypes.string,
  disabled: PropTypes.bool
} : void 0;

CheckboxField.defaultProps = {
  onChange: function onChange() {}
};

var styles$h = { "form": "lc-form", "form__footer": "lc-form__footer", "form__header": "lc-form__header", "form__label": "lc-form__label", "form__helper": "lc-form__helper" };

var Form = function Form(_ref) {
  var className = _ref.className,
      children = _ref.children,
      labelText = _ref.labelText,
      helperText = _ref.helperText,
      formFooter = _ref.formFooter,
      restProps = objectWithoutProperties(_ref, ['className', 'children', 'labelText', 'helperText', 'formFooter']);
  return React.createElement(
    'form',
    _extends({ className: cx(styles$h.form, className) }, restProps),
    (labelText || helperText) && React.createElement(
      'div',
      { className: styles$h.form__header },
      labelText && React.createElement(
        'h3',
        { className: styles$h.form__label },
        labelText
      ),
      helperText && React.createElement(
        'p',
        { className: styles$h.form__helper },
        helperText
      )
    ),
    children,
    formFooter && React.createElement(
      'div',
      { className: styles$h.form__footer },
      formFooter
    )
  );
};

process.env.NODE_ENV !== "production" ? Form.propTypes = {
  /**
   * Provide children to be rendered inside of the <form> element
   */
  children: PropTypes.node.isRequired,
  labelText: PropTypes.string,
  helperText: PropTypes.string,
  formFooter: PropTypes.node,
  /**
   * Provide a custom className to be applied on the containing <form> node
   */
  className: PropTypes.string
} : void 0;

var styles$i = { "form-group": "lc-form-group", "form-group__header": "lc-form-group__header", "form-group__helper": "lc-form-group__helper", "form-group__label": "lc-form-group__label" };

var FormGroup = function FormGroup(props) {
  var className = props.className,
      children = props.children,
      labelText = props.labelText,
      helperText = props.helperText;


  var baseClass = 'form-group';
  var mergedClassNames = getMergedClassNames(styles$i[baseClass], className);

  return React.createElement(
    'div',
    { role: 'group', 'aria-label': labelText, className: mergedClassNames },
    React.createElement(
      'div',
      { className: styles$i[baseClass + '__header'] },
      React.createElement(
        'div',
        { className: styles$i[baseClass + '__label'] },
        labelText
      ),
      helperText && React.createElement(
        'div',
        { className: styles$i[baseClass + '__helper'] },
        helperText
      )
    ),
    children
  );
};

process.env.NODE_ENV !== "production" ? FormGroup.propTypes = {
  className: PropTypes.string,
  labelText: PropTypes.string,
  helperText: PropTypes.string,
  children: PropTypes.node.isRequired
} : void 0;

var styles$j = { "field-group": "lc-field-group", "field-group--inline": "lc-field-group--inline", "field-group--stretched": "lc-field-group--stretched" };

var cx$i = classNames.bind(styles$j);

var FieldGroup = function FieldGroup(props) {
  var _cx;

  var className = props.className,
      children = props.children,
      inline = props.inline,
      stretch = props.stretch,
      error = props.error,
      description = props.description,
      restProps = objectWithoutProperties(props, ['className', 'children', 'inline', 'stretch', 'error', 'description']);


  var baseClass = 'field-group';
  var mergedClassNames = getMergedClassNames(cx$i((_cx = {}, _cx[baseClass] = true, _cx[baseClass + '--inline'] = inline, _cx[baseClass + '--stretched'] = stretch, _cx)), className);

  return React.createElement(
    'div',
    _extends({}, restProps, { className: mergedClassNames }),
    children,
    error && React.createElement(
      FieldError,
      null,
      error
    ),
    description && React.createElement(
      FieldDescription,
      null,
      description
    )
  );
};

process.env.NODE_ENV !== "production" ? FieldGroup.propTypes = {
  children: PropTypes.node.isRequired,
  className: PropTypes.string,
  description: PropTypes.node,
  error: PropTypes.string,
  inline: PropTypes.bool,
  stretch: PropTypes.bool
} : void 0;

var styles$k = { "select": "lc-select", "select-head": "lc-select-head", "select-head--focused": "lc-select-head--focused", "select-head--disabled": "lc-select-head--disabled", "select-head__clear": "lc-select-head__clear", "select-head__clear--visible": "lc-select-head__clear--visible", "select-head__search": "lc-select-head__search", "select-head__search--visible": "lc-select-head__search--visible", "select-head__input": "lc-select-head__input", "select-body": "lc-select-body", "select-body--visible": "lc-select-body--visible", "select-body__list": "lc-select-body__list", "select-body__list__header": "lc-select-body__list__header", "select-body__item": "lc-select-body__item", "select-body__item-content": "lc-select-body__item-content", "select-body__item--selected": "lc-select-body__item--selected", "select-body__checkmark": "lc-select-body__checkmark", "select-body__item--focused": "lc-select-body__item--focused", "select-head__item": "lc-select-head__item", "select-head__item-content": "lc-select-head__item-content", "select-head__item--visible": "lc-select-head__item--visible", "select-head__item-placeholder": "lc-select-head__item-placeholder", "select--error": "lc-select--error" };

var baseClass$j = 'select-body';
var cx$j = classNames.bind(styles$k);

var SelectItem = function SelectItem(props) {
  var _cx;

  var isSelected = props.isSelected,
      children = props.children,
      isFocused = props.isFocused,
      restProps = objectWithoutProperties(props, ['isSelected', 'children', 'isFocused']);

  return React.createElement(
    'li',
    _extends({
      className: cx$j((_cx = {}, _cx[baseClass$j + '__item'] = true, _cx[baseClass$j + '__item--selected'] = isSelected, _cx[baseClass$j + '__item--focused'] = isFocused, _cx)),
      'data-testid': 'select-body-item'
    }, restProps),
    React.createElement(
      'div',
      { className: styles$k[baseClass$j + '__item-content'] },
      children
    ),
    React.createElement(CheckIcon, {
      width: '15px',
      height: '15px',
      className: styles$k[baseClass$j + '__checkmark'],
      'data-testid': 'select-body-item-check-icon'
    })
  );
};

process.env.NODE_ENV !== "production" ? SelectItem.propTypes = {
  isSelected: PropTypes.bool,
  isFocused: PropTypes.bool,
  children: PropTypes.node
} : void 0;

var baseClass$k = 'select-body';

var SelectList = function (_React$PureComponent) {
  inherits(SelectList, _React$PureComponent);

  function SelectList() {
    var _temp, _this, _ret;

    classCallCheck(this, SelectList);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args))), _this), _this.onKeydown = function (event) {
      var keyCode = event.keyCode;


      if (keyCode === 9 || keyCode === 27) {
        if (_this.props.listRef.current) {
          _this.props.listRef.current.scrollTop = 0;
        }
        _this.props.onListClose();
      }

      if (keyCode === KeyCodes.arrowDown || keyCode === KeyCodes.arrowUp) {
        _this.handleArrowKeyUse(event);
      }

      if (keyCode === KeyCodes.enter) {
        _this.handleEnterKeyUse(event);
      }
    }, _this.getHoveredItemCallback = function (itemKey) {
      if (!_this.hoverCallbacks[itemKey]) {
        _this.hoverCallbacks[itemKey] = function () {
          if (_this.props.listRef.current && !_this.props.listRef.current.classList.contains('disable-hover')) {
            _this.props.onFocusedItemChange(itemKey);
          }
        };
      }

      return _this.hoverCallbacks[itemKey];
    }, _this.getFocusedItemIndex = function (itemKey) {
      return _this.props.items.map(function (item) {
        return item.key;
      }).indexOf(itemKey);
    }, _this.scrollItems = function () {
      if (!_this.props.listRef.current) {
        return;
      }
      var focusedElement = _this.props.listRef.current.querySelector('.lc-' + baseClass$k + '__item--focused');

      if (focusedElement) {
        _this.props.listRef.current.classList.add('disable-hover');

        var _this$props$listRef$c = _this.props.listRef.current.getBoundingClientRect(),
            ulHeight = _this$props$listRef$c.height,
            ulTop = _this$props$listRef$c.top;

        var _focusedElement$getBo = focusedElement.getBoundingClientRect(),
            itemHeigth = _focusedElement$getBo.height,
            itemTop = _focusedElement$getBo.top;

        var relativeTop = itemTop + itemHeigth - ulTop;
        var itemOfsetTop = focusedElement.offsetTop;

        if (relativeTop > ulHeight) {
          _this.props.listRef.current.scrollTop = itemOfsetTop - ulHeight + itemHeigth;
        } else if (itemTop < ulTop) {
          _this.props.listRef.current.scrollTop = itemOfsetTop - itemOfsetTop % itemHeigth;
        }
        _this.timerId = setTimeout(function () {
          return _this.props.listRef.current.classList.remove('disable-hover');
        }, 100);
      }
    }, _this.handleEnterKeyUse = function () {
      var _this$props = _this.props,
          isOpen = _this$props.isOpen,
          focusedItemKey = _this$props.focusedItemKey,
          onEnterKey = _this$props.onEnterKey;


      if (isOpen && focusedItemKey !== null) {
        if (_this.props.listRef.current) {
          _this.props.listRef.current.scrollTop = 0;
        }
        onEnterKey(focusedItemKey);
      }
    }, _this.handleArrowKeyUse = function (event) {
      event.preventDefault();
      var _this$props2 = _this.props,
          items = _this$props2.items,
          focusedItemKey = _this$props2.focusedItemKey,
          onFocusedItemChange = _this$props2.onFocusedItemChange;
      var keyCode = event.keyCode;


      var currentItemIndex = _this.getFocusedItemIndex(focusedItemKey);

      if (keyCode === KeyCodes.arrowUp && currentItemIndex > 0) {
        onFocusedItemChange(items[currentItemIndex - 1].key);
      }

      if (keyCode === KeyCodes.arrowDown && currentItemIndex + 1 < items.length) {
        onFocusedItemChange(items[currentItemIndex + 1].key);
      }

      _this.scrollItems();
    }, _this.isItemSelected = function (itemKey) {
      if (_this.props.selectedItem === null) {
        return false;
      }
      return _this.props.selectedItem === itemKey;
    }, _this.isItemFocused = function (itemKey) {
      return _this.props.focusedItemKey === itemKey;
    }, _this.timerId = null, _this.hoverCallbacks = [], _temp), possibleConstructorReturn(_this, _ret);
  }

  SelectList.prototype.componentDidMount = function componentDidMount() {
    if (this.props.isOpen) {
      document.addEventListener('keydown', this.onKeydown);
    }
  };

  SelectList.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (!prevProps.isOpen && this.props.isOpen) {
      if (this.props.listRef.current) {
        this.props.listRef.current.scrollTop = 0;
      }
      document.addEventListener('keydown', this.onKeydown);
    } else if (prevProps.isOpen && !this.props.isOpen) {
      document.removeEventListener('keydown', this.onKeydown);
      if (this.timerId) {
        clearTimeout(this.timerId);
      }
    }
  };

  SelectList.prototype.componentWillUnmount = function componentWillUnmount() {
    document.removeEventListener('keydown', this.onKeydown);
    this.hoverCallbacks = [];
    if (this.timerId) {
      clearTimeout(this.timerId);
    }
  };

  SelectList.prototype.render = function render() {
    var _this2 = this;

    var _props = this.props,
        items = _props.items,
        getItemBody = _props.getItemBody,
        getItemSelectedHandler = _props.getItemSelectedHandler,
        selectHeader = _props.selectHeader;


    return React.createElement(
      'ul',
      { ref: this.props.listRef, className: styles$k[baseClass$k + '__list'], 'data-testid': 'select-list' },
      selectHeader && React.createElement(
        SelectItem,
        { className: styles$k[baseClass$k + '__list__header'] },
        selectHeader
      ),
      items.filter(function (v) {
        return !v.props.hidden;
      }).map(function (item) {
        return React.createElement(
          SelectItem,
          {
            isSelected: _this2.isItemSelected(item.key),
            isFocused: _this2.isItemFocused(item.key),
            key: item.key,
            onClick: getItemSelectedHandler(item.key),
            onMouseEnter: _this2.getHoveredItemCallback(item.key)
          },
          getItemBody(item.props)
        );
      })
    );
  };

  return SelectList;
}(React.PureComponent);

process.env.NODE_ENV !== "production" ? SelectList.propTypes = {
  getItemBody: PropTypes.func,
  isOpen: PropTypes.bool,
  items: PropTypes.arrayOf(PropTypes.shape({
    key: PropTypes.string,
    props: PropTypes.object
  })),
  onListClose: PropTypes.func,
  selectedItem: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  getItemSelectedHandler: PropTypes.func,
  onEnterKey: PropTypes.func,
  focusedItemKey: PropTypes.string,
  onFocusedItemChange: PropTypes.func,
  listRef: PropTypes.shape({
    current: PropTypes.instanceOf(typeof Element === 'undefined' ? function () {} : Element)
  }),
  selectHeader: PropTypes.string
} : void 0;

var cx$k = classNames.bind(styles$k);

var baseClass$l = 'select-head';

var SelectHead = React.forwardRef(function (props, ref) {
  var _cx;

  var isFocused = props.isFocused,
      disabled = props.disabled,
      children = props.children,
      restProps = objectWithoutProperties(props, ['isFocused', 'disabled', 'children']);


  return React.createElement(
    'div',
    _extends({
      ref: ref,
      className: cx$k((_cx = {}, _cx['' + baseClass$l] = true, _cx[baseClass$l + '--focused'] = isFocused, _cx[baseClass$l + '--disabled'] = disabled, _cx)),
      disabled: disabled,
      'data-testid': 'select-head'
    }, restProps, {
      tabIndex: disabled ? -1 : 0
    }),
    children
  );
});

process.env.NODE_ENV !== "production" ? SelectHead.propTypes = {
  children: PropTypes.node,
  disabled: PropTypes.bool,
  isFocused: PropTypes.bool
} : void 0;

var baseClass$m = 'select-head__item';
var cx$l = classNames.bind(styles$k);

var SelectHeadItem = function SelectHeadItem(props) {
  var _cx;

  var isVisible = props.isVisible,
      selectedItem = props.selectedItem,
      placeholder = props.placeholder,
      getSelectedItemBody = props.getSelectedItemBody;

  return React.createElement(
    'div',
    {
      className: cx$l((_cx = {}, _cx['' + baseClass$m] = true, _cx[baseClass$m + '--visible'] = isVisible, _cx)),
      'data-testid': 'select-head-item'
    },
    selectedItem ? React.createElement(
      'div',
      { className: styles$k[baseClass$m + '-content'] },
      getSelectedItemBody(selectedItem.props)
    ) : React.createElement(
      'div',
      { className: styles$k[baseClass$m + '-placeholder'], 'data-testid': 'select-head-item-pladceholder' },
      placeholder
    )
  );
};

process.env.NODE_ENV !== "production" ? SelectHeadItem.propTypes = {
  isVisible: PropTypes.bool,
  selectedItem: PropTypes.shape({
    key: PropTypes.string,
    props: PropTypes.object
  }),
  placeholder: PropTypes.string,
  getSelectedItemBody: PropTypes.func
} : void 0;

var baseClass$n = 'select-head';
var cx$m = classNames.bind(styles$k);

var ClearButton = React.forwardRef(function (props, ref) {
  var _cx;

  var isVisible = props.isVisible,
      clearSelectedOption = props.clearSelectedOption;

  return React.createElement(
    'div',
    {
      ref: ref,
      className: cx$m((_cx = {}, _cx[baseClass$n + '__clear'] = true, _cx[baseClass$n + '__clear--visible'] = isVisible, _cx)),
      'data-testid': 'select-clear-button'
    },
    React.createElement(CloseIcon, {
      width: '20px',
      height: '20px',
      fill: '#4384f5',
      'data-testid': 'select-clear-icon',
      onClick: clearSelectedOption
    })
  );
});

process.env.NODE_ENV !== "production" ? ClearButton.propTypes = {
  clearSelectedOption: PropTypes.func,
  isVisible: PropTypes.bool
} : void 0;

var baseClass$o = 'select-head';
var cx$n = classNames.bind(styles$k);

var Search = function Search(props) {
  var _cx;

  var inputRef = props.inputRef,
      isVisible = props.isVisible,
      placeholder = props.placeholder,
      value = props.value,
      onChange = props.onChange,
      disabled = props.disabled;

  var onKeyDown = function onKeyDown(event) {
    if (event.keyCode === KeyCodes.enter) {
      event.preventDefault();
    }
  };

  return React.createElement(
    'div',
    {
      className: cx$n((_cx = {}, _cx[baseClass$o + '__search'] = true, _cx[baseClass$o + '__search--visible'] = isVisible, _cx))
    },
    React.createElement('input', {
      ref: inputRef,
      className: styles$k[baseClass$o + '__input'],
      type: 'text',
      placeholder: placeholder,
      name: 'select-box-input',
      'data-testid': 'select-search-input',
      value: value,
      onChange: onChange,
      onKeyDown: onKeyDown,
      autoComplete: 'off',
      disabled: disabled
    })
  );
};

process.env.NODE_ENV !== "production" ? Search.propTypes = {
  inputRef: PropTypes.shape({
    current: PropTypes.instanceOf(typeof Element === 'undefined' ? function () {} : Element)
  }),
  isVisible: PropTypes.bool,
  placeholder: PropTypes.string,
  value: PropTypes.string,
  onChange: PropTypes.func,
  disabled: PropTypes.bool
} : void 0;

var cx$o = classNames.bind(styles$k);

var baseClass$p = 'select';

var Select = function (_React$PureComponent) {
  inherits(Select, _React$PureComponent);

  function Select(props) {
    classCallCheck(this, Select);

    var _this = possibleConstructorReturn(this, _React$PureComponent.call(this, props));

    _initialiseProps.call(_this);

    _this.state = {
      isOpen: props.openedOnInit || props.isOpen || false,
      searchPhrase: '',
      focusedItemKey: _this.props.items[0] ? _this.props.items[0].key : null,
      isFocused: false
    };

    _this.timerId = null;
    _this.containerRef = React.createRef();
    _this.searchInputRef = React.createRef();
    _this.headRef = React.createRef();
    _this.clearButtonRef = React.createRef();
    _this.listRef = React.createRef();
    return _this;
  }

  Select.prototype.componentDidMount = function componentDidMount() {
    if (this.state.isOpen) {
      this.props.onDropdownToggle(true);
      this.onBodyOpen();
    }
  };

  Select.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    var hasIsOpenChanged = this.getIsOpen(prevProps, prevState) !== this.getIsOpen();

    if (this.getIsOpen() && hasIsOpenChanged) {
      this.onBodyOpen();
    } else if (!this.getIsOpen() && hasIsOpenChanged) {
      this.onBodyClose();
    }
  };

  Select.prototype.componentWillUnmount = function componentWillUnmount() {
    this.onBodyClose();
    document.removeEventListener('keydown', this.onArrowPress);
  };

  Select.prototype.render = function render() {
    var _cx, _cx2;

    var _props = this.props,
        className = _props.className,
        disabled = _props.disabled,
        error = _props.error,
        getItemBody = _props.getItemBody,
        getSelectedItemBody = _props.getSelectedItemBody,
        id = _props.id,
        items = _props.items,
        placeholder = _props.placeholder,
        required = _props.required,
        search = _props.search,
        searchEmptyState = _props.searchEmptyState,
        searchPlaceholder = _props.searchPlaceholder,
        selected = _props.selected,
        dataTestId = _props.dataTestId,
        selectHeader = _props.selectHeader;
    var _state = this.state,
        searchPhrase = _state.searchPhrase,
        focusedItemKey = _state.focusedItemKey,
        isFocused = _state.isFocused;

    var selectedItemModel = items.find(function (item) {
      return item.key === selected;
    });
    var filteredItems = items.filter(this.filterItem);
    var mergedClassNames = getMergedClassNames(cx$o((_cx = {}, _cx[baseClass$p] = true, _cx[baseClass$p + '--error'] = error, _cx)), className);

    var isOpen = this.getIsOpen();
    var shouldRenderClearButton = !!selectedItemModel && !isOpen && !required;

    return React.createElement(
      'div',
      { ref: this.containerRef, className: mergedClassNames, id: id, 'data-testid': dataTestId },
      React.createElement(
        SelectHead,
        {
          isFocused: isOpen || isFocused,
          disabled: disabled,
          ref: this.headRef,
          onClick: this.onSelectHeadClick,
          onFocus: this.onSelectHeadFocus,
          onBlur: this.onSelectHeadBlur
        },
        React.createElement(SelectHeadItem, {
          getSelectedItemBody: getSelectedItemBody,
          selectedItem: selectedItemModel,
          isVisible: !(isOpen && search),
          placeholder: placeholder
        }),
        React.createElement(Search, {
          isVisible: !search ? false : isOpen,
          inputRef: this.searchInputRef,
          placeholder: searchPlaceholder || 'Search...',
          value: searchPhrase,
          onChange: this.onSearchChange,
          disabled: disabled
        }),
        React.createElement(ClearButton, {
          isVisible: shouldRenderClearButton,
          ref: this.clearButtonRef,
          clearSelectedOption: this.clearSelectedOption
        }),
        React.createElement(MenuDownIcon, { width: '24px', height: '24px', fill: '#424d57', 'data-testid': 'select-down-icon' })
      ),
      React.createElement(
        'div',
        {
          className: cx$o((_cx2 = {}, _cx2[baseClass$p + '-body'] = true, _cx2[baseClass$p + '-body--visible'] = this.shouldShowSelectBody(filteredItems), _cx2)),
          'data-testid': 'select-body'
        },
        filteredItems.length === 0 && searchEmptyState,
        React.createElement(SelectList, {
          listRef: this.listRef,
          getItemBody: getItemBody,
          isOpen: isOpen,
          onListClose: this.hideSelectBody,
          items: filteredItems,
          getSelectedItemBody: getSelectedItemBody,
          selectedItem: selected,
          getItemSelectedHandler: this.getItemSelectedHandler,
          onEnterKey: this.handleEnterKeyUse,
          onFocusedItemChange: this.changeFocusedItem,
          focusedItemKey: focusedItemKey,
          selectHeader: selectHeader
        })
      )
    );
  };

  return Select;
}(React.PureComponent);

var _initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this.onDocumentClick = function (event) {
    if (_this2.getIsOpen() && _this2.containerRef.current && !_this2.containerRef.current.contains(event.target)) {
      _this2.listRef.current.scrollTop = 0;
      _this2.hideSelectBody();
    }
  };

  this.onSearchChange = function (event) {
    _this2.setState({
      searchPhrase: event.target.value
    }, function () {
      var filteredItems = _this2.props.items.filter(function (v) {
        return _this2.filterItem(v) && _this2.props.selected !== v.key;
      });
      var focusedItemKey = filteredItems.length > 0 ? filteredItems[0].key : null;

      _this2.setState({
        focusedItemKey: focusedItemKey
      });

      if (_this2.props.onSearchPhraseChange) {
        _this2.props.onSearchPhraseChange(_this2.state.searchPhrase);
      }
    });
  };

  this.onBodyOpen = function () {
    document.addEventListener('click', _this2.onDocumentClick);
    if (_this2.props.search && _this2.searchInputRef.current) {
      _this2.timerId = setTimeout(function () {
        _this2.searchInputRef.current.focus();
      }, 150);
    }
  };

  this.onBodyClose = function () {
    document.removeEventListener('click', _this2.onDocumentClick);
    if (_this2.timerId) {
      clearTimeout(_this2.timerId);
    }
  };

  this.onSelectHeadClick = function (event) {
    event.preventDefault();
    if (_this2.props.disabled) {
      return;
    }
    if (_this2.clearButtonRef.current && _this2.clearButtonRef.current.contains(event.target)) {
      return;
    }
    if (!_this2.getIsOpen()) {
      _this2.showSelectBody();
    } else {
      _this2.hideSelectBody();
    }
  };

  this.onSelectHeadFocus = function () {
    _this2.setState({
      isFocused: true
    });
    if (!_this2.state.isOpen) {
      document.addEventListener('keydown', _this2.onArrowPress);
    }
  };

  this.onSelectHeadBlur = function () {
    _this2.setState({
      isFocused: false
    });
    document.removeEventListener('keydown', _this2.onArrowPress);
  };

  this.onArrowPress = function (e) {
    if (e.keyCode === KeyCodes.arrowDown || e.keyCode === KeyCodes.arrowUp) {
      e.preventDefault();
      _this2.showSelectBody();
    }
  };

  this.getItemSelectedHandler = function (itemKey) {
    return function (event) {
      event.preventDefault();

      _this2.props.onItemSelect(itemKey);
      _this2.hideSelectBody();
    };
  };

  this.getIsOpen = function () {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this2.props;
    var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this2.state;

    if (props.disabled) {
      return false;
    }
    return _this2.isIsOpenControlled() ? props.isOpen : state.isOpen;
  };

  this.handleEnterKeyUse = function (itemKey) {
    _this2.props.onItemSelect(itemKey);
    _this2.hideSelectBody();
  };

  this.showSelectBody = function () {
    _this2.setState({
      isOpen: true,
      searchPhrase: ''
    }, function () {
      _this2.props.onDropdownToggle(true);
    });
  };

  this.shouldShowSelectBody = function (filteredItems) {
    var searchEmptyState = _this2.props.searchEmptyState;
    var searchPhrase = _this2.state.searchPhrase;

    var isOpen = _this2.getIsOpen();

    return isOpen && filteredItems.length > 0 || searchEmptyState && searchPhrase.length > 0 && filteredItems.length === 0;
  };

  this.hideSelectBody = function () {
    _this2.setState({
      isOpen: false,
      focusedItemKey: _this2.props.items[0] ? _this2.props.items[0].key : null,
      searchPhrase: ''
    }, function () {
      _this2.props.onDropdownToggle(false);
      if (_this2.headRef.current) {
        _this2.headRef.current.focus();
      }
    });
  };

  this.changeFocusedItem = function (itemKey) {
    if (typeof itemKey === 'undefined' || itemKey === null) {
      return _this2.setState({
        focusedItemKey: _this2.props.items[0] ? _this2.props.items[0].key : null
      });
    }
    return _this2.setState({
      focusedItemKey: itemKey
    });
  };

  this.clearSelectedOption = function (e) {
    e.preventDefault();
    e.stopPropagation();
    _this2.props.onItemSelect(null);
  };

  this.filterItem = function (item) {
    var searchProperty = _this2.props.searchProperty;
    var searchPhrase = _this2.state.searchPhrase;


    if (searchPhrase) {
      if (typeof searchProperty === 'string') {
        if (!(searchProperty in item.props)) {
          return false;
        }

        return item.props[searchProperty].toLocaleLowerCase().includes(searchPhrase.toLocaleLowerCase());
      } else if (Array.isArray(searchProperty) && searchProperty.length > 0) {
        var validSearchProperties = searchProperty.filter(function (p) {
          return item.props[p];
        });

        if (validSearchProperties.length === 0) {
          return false;
        }
        return validSearchProperties.some(function (p) {
          return item.props[p].toLocaleLowerCase().includes(searchPhrase.toLocaleLowerCase());
        });
      }
    }

    return true;
  };

  this.isIsOpenControlled = function () {
    return _this2.props.isOpen !== undefined;
  };
};

process.env.NODE_ENV !== "production" ? Select.propTypes = {
  className: PropTypes.string,
  error: PropTypes.string,
  id: PropTypes.string,
  dataTestId: PropTypes.string,
  /**
   * Use when you need to control multiselect dropdown visibility in its parent component
   * Remember to pass `onDropdownToggle` method as props, thanks to that you will be able to
   * update your state
   */
  isOpen: PropTypes.bool,
  getItemBody: PropTypes.func.isRequired,
  getSelectedItemBody: PropTypes.func,
  onItemSelect: PropTypes.func.isRequired,
  /**
   * Pass a ReactNode to specify SelectList placeholder
   * (visible when items list is empty and typed search phrase is not empty)
   */
  searchEmptyState: PropTypes.node,
  items: PropTypes.arrayOf(PropTypes.shape({
    key: PropTypes.string,
    props: PropTypes.object
  })),
  searchPlaceholder: PropTypes.string,
  searchProperty: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),
  selected: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  search: PropTypes.bool,
  required: PropTypes.bool,
  placeholder: PropTypes.string,
  disabled: PropTypes.bool,
  openedOnInit: PropTypes.bool,
  onDropdownToggle: PropTypes.func,
  /**
   * Searching is controlled by Select component itself. Use this props to get current value of search phrase.
   * It would be useful, for instance, if you need to save searchPhrase as new item.
   * (searchPhrase) => {}
   */
  onSearchPhraseChange: PropTypes.func,
  /**
   * Pass a string to display a tip in items list
   */
  selectHeader: PropTypes.string
} : void 0;

Select.defaultProps = {
  items: [],
  selected: null,
  onDropdownToggle: function onDropdownToggle() {}
};

var SelectField = function SelectField(props) {
  var inline = props.inline,
      error = props.error,
      description = props.description,
      labelText = props.labelText,
      labelAdornment = props.labelAdornment,
      className = props.className,
      id = props.id,
      fieldClassName = props.fieldClassName,
      restProps = objectWithoutProperties(props, ['inline', 'error', 'description', 'labelText', 'labelAdornment', 'className', 'id', 'fieldClassName']);


  return React.createElement(
    TextField,
    {
      inline: inline,
      error: error,
      description: description,
      labelText: labelText,
      labelAdornment: labelAdornment,
      className: className,
      htmlFor: id
    },
    React.createElement(Select, _extends({}, restProps, { className: fieldClassName, id: id, error: error }))
  );
};

process.env.NODE_ENV !== "production" ? SelectField.propTypes = {
  labelText: PropTypes.string,
  /**  specifies additional decorative element rendered at the end of the label */
  labelAdornment: PropTypes.node,
  id: PropTypes.string.isRequired,
  className: PropTypes.string,
  fieldClassName: PropTypes.string,
  inline: PropTypes.bool,
  error: PropTypes.string,
  description: PropTypes.node
} : void 0;

var styles$l = { "multiselect": "lc-multiselect", "multiselect-head": "lc-multiselect-head", "multiselect-head--focused": "lc-multiselect-head--focused", "multiselect-head--disabled": "lc-multiselect-head--disabled", "multiselect-head__clear": "lc-multiselect-head__clear", "multiselect-head__clear--visible": "lc-multiselect-head__clear--visible", "multiselect-head__search": "lc-multiselect-head__search", "multiselect-head__search--expanded": "lc-multiselect-head__search--expanded", "multiselect-body": "lc-multiselect-body", "multiselect-body--visible": "lc-multiselect-body--visible", "multiselect-body__list": "lc-multiselect-body__list", "multiselect-body__item": "lc-multiselect-body__item", "multiselect-body__item-content": "lc-multiselect-body__item-content", "multiselect-body__item--selected": "lc-multiselect-body__item--selected", "multiselect-body__checkmark": "lc-multiselect-body__checkmark", "multiselect-body__item--focused": "lc-multiselect-body__item--focused", "multiselect-body__item--toggle": "lc-multiselect-body__item--toggle", "multiselect-head__items": "lc-multiselect-head__items", "multiselect-head__items-empty": "lc-multiselect-head__items-empty", "multiselect__placeholder": "lc-multiselect__placeholder", "multiselect-head__item": "lc-multiselect-head__item", "multiselect-head__item-content": "lc-multiselect-head__item-content", "multiselect-head__item-remove-icon": "lc-multiselect-head__item-remove-icon", "multiselect__dropdown-icon": "lc-multiselect__dropdown-icon", "multiselect--error": "lc-multiselect--error" };

var baseClass$q = 'multiselect-body';
var cx$p = classNames.bind(styles$l);

var SelectItem$1 = function SelectItem(props) {
  var _cx;

  var isSelected = props.isSelected,
      children = props.children,
      isFocused = props.isFocused,
      isToggleItem = props.isToggleItem,
      restProps = objectWithoutProperties(props, ['isSelected', 'children', 'isFocused', 'isToggleItem']);

  return React.createElement(
    'li',
    _extends({
      className: cx$p((_cx = {}, _cx[baseClass$q + '__item'] = true, _cx[baseClass$q + '__item--selected'] = isSelected, _cx[baseClass$q + '__item--focused'] = isFocused, _cx[baseClass$q + '__item--toggle'] = isToggleItem, _cx)),
      'data-testid': 'multiselect-body-item'
    }, restProps),
    React.createElement(
      'div',
      { className: styles$l[baseClass$q + '__item-content'] },
      children
    ),
    React.createElement(CheckIcon, {
      width: '15px',
      height: '15px',
      className: styles$l[baseClass$q + '__checkmark'],
      'data-testid': 'multiselect-body-item-check-icon'
    })
  );
};

process.env.NODE_ENV !== "production" ? SelectItem$1.propTypes = {
  isSelected: PropTypes.bool,
  isFocused: PropTypes.bool,
  isToggleItem: PropTypes.bool,
  children: PropTypes.node
} : void 0;

var baseClass$r = 'multiselect-body';

var MultiSelectList = function (_React$PureComponent) {
  inherits(MultiSelectList, _React$PureComponent);

  function MultiSelectList() {
    var _temp, _this, _ret;

    classCallCheck(this, MultiSelectList);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args))), _this), _this.onKeydown = function (event) {
      var keyCode = event.keyCode;


      if (keyCode === 9 || keyCode === 27) {
        if (_this.props.listRef.current) {
          _this.props.listRef.current.scrollTop = 0;
        }
        _this.props.onListClose();
      }

      if (keyCode === KeyCodes.arrowDown || keyCode === KeyCodes.arrowUp) {
        _this.handleArrowKeyUse(event);
      }

      if (keyCode === KeyCodes.enter) {
        _this.handleEnterKeyUse(event);
      }
    }, _this.onToggleAllOptionHover = function () {
      _this.props.onFocusedItemChange(null);
    }, _this.getHoveredItemCallback = function (itemKey) {
      if (!_this.hoverCallbacks[itemKey]) {
        _this.hoverCallbacks[itemKey] = function () {
          if (_this.props.listRef.current && !_this.props.listRef.current.classList.contains('disable-hover')) {
            _this.props.onFocusedItemChange(itemKey);
          }
        };
      }

      return _this.hoverCallbacks[itemKey];
    }, _this.getFocusedItemIndex = function (itemKey) {
      return _this.props.items.map(function (item) {
        return item.key;
      }).indexOf(itemKey);
    }, _this.scrollItems = function () {
      if (!_this.props.listRef.current) {
        return;
      }
      var focusedElement = _this.props.listRef.current.querySelector('.lc-' + baseClass$r + '__item--focused');

      if (focusedElement) {
        _this.props.listRef.current.classList.add('disable-hover');

        var _this$props$listRef$c = _this.props.listRef.current.getBoundingClientRect(),
            ulHeight = _this$props$listRef$c.height,
            ulTop = _this$props$listRef$c.top;

        var _focusedElement$getBo = focusedElement.getBoundingClientRect(),
            itemHeigth = _focusedElement$getBo.height,
            itemTop = _focusedElement$getBo.top;

        var relativeTop = itemTop + itemHeigth - ulTop;
        var itemOfsetTop = focusedElement.offsetTop;

        if (relativeTop > ulHeight) {
          _this.props.listRef.current.scrollTop = itemOfsetTop - ulHeight + itemHeigth;
        } else if (itemTop < ulTop) {
          _this.props.listRef.current.scrollTop = itemOfsetTop - itemOfsetTop % itemHeigth;
        }
        _this.timerId = setTimeout(function () {
          return _this.props.listRef.current.classList.remove('disable-hover');
        }, 100);
      }
    }, _this.handleEnterKeyUse = function () {
      var _this$props = _this.props,
          isOpen = _this$props.isOpen,
          focusedItemKey = _this$props.focusedItemKey,
          onEnterKey = _this$props.onEnterKey,
          toggleAllOptions = _this$props.toggleAllOptions;


      if (toggleAllOptions && focusedItemKey === null) {
        _this.handleToggleAll();
      } else if (isOpen && focusedItemKey !== null) {
        onEnterKey(focusedItemKey);
      }
    }, _this.handleArrowKeyUse = function (event) {
      event.preventDefault();
      var _this$props2 = _this.props,
          items = _this$props2.items,
          focusedItemKey = _this$props2.focusedItemKey,
          onFocusedItemChange = _this$props2.onFocusedItemChange,
          toggleAllOptions = _this$props2.toggleAllOptions;
      var keyCode = event.keyCode;


      var currentItemIndex = _this.getFocusedItemIndex(focusedItemKey);

      if (keyCode === KeyCodes.arrowUp) {
        if (currentItemIndex > 0) {
          onFocusedItemChange(items[currentItemIndex - 1].key);
        } else if (toggleAllOptions) {
          onFocusedItemChange(null);
        }
      }

      if (keyCode === KeyCodes.arrowDown && currentItemIndex + 1 < items.length) {
        onFocusedItemChange(items[currentItemIndex + 1].key);
      }

      _this.scrollItems();
    }, _this.isItemSelected = function (itemKey) {
      if (!_this.props.selectedItems) {
        return false;
      }
      return _this.props.selectedItems.some(function (item) {
        return item === itemKey;
      });
    }, _this.isItemFocused = function (itemKey) {
      return _this.props.focusedItemKey === itemKey;
    }, _this.isAllItemsSelected = function () {
      if (!_this.props.selectedItems) {
        return false;
      }
      return _this.props.selectedItems.length === _this.props.items.length;
    }, _this.handleToggleAll = function () {
      if (_this.isAllItemsSelected()) {
        return _this.props.toggleAllOptions.onToggleAll(null);
      }
      return _this.props.toggleAllOptions.onToggleAll(_this.props.items.map(function (item) {
        return item.key;
      }));
    }, _this.timerId = null, _this.hoverCallbacks = [], _temp), possibleConstructorReturn(_this, _ret);
  }

  MultiSelectList.prototype.componentDidMount = function componentDidMount() {
    if (this.props.isOpen) {
      document.addEventListener('keydown', this.onKeydown);
    }
  };

  MultiSelectList.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (!prevProps.isOpen && this.props.isOpen) {
      if (this.props.listRef.current) {
        this.props.listRef.current.scrollTop = 0;
      }
      document.addEventListener('keydown', this.onKeydown);
    } else if (prevProps.isOpen && !this.props.isOpen) {
      document.removeEventListener('keydown', this.onKeydown);
      if (this.timerId) {
        clearTimeout(this.timerId);
      }
    }
  };

  MultiSelectList.prototype.componentWillUnmount = function componentWillUnmount() {
    document.removeEventListener('keydown', this.onKeydown);
    this.hoverCallbacks = [];
    if (this.timerId) {
      clearTimeout(this.timerId);
    }
  };

  MultiSelectList.prototype.render = function render() {
    var _this2 = this;

    var _props = this.props,
        items = _props.items,
        getItemBody = _props.getItemBody,
        getItemSelectedHandler = _props.getItemSelectedHandler,
        toggleAllOptions = _props.toggleAllOptions;


    return React.createElement(
      'ul',
      { ref: this.props.listRef, className: styles$l[baseClass$r + '__list'], 'data-testid': 'multiselect-body-list' },
      toggleAllOptions && React.createElement(
        SelectItem$1,
        {
          isFocused: this.isItemFocused(null),
          onClick: this.handleToggleAll,
          isToggleItem: true,
          onMouseEnter: this.onToggleAllOptionHover
        },
        this.isAllItemsSelected() ? toggleAllOptions.clearLabel || 'Deselect all' : toggleAllOptions.selectLabel || 'Select all'
      ),
      items.filter(function (v) {
        return !v.props.hidden;
      }).map(function (item) {
        return React.createElement(
          SelectItem$1,
          {
            isSelected: _this2.isItemSelected(item.key),
            isFocused: _this2.isItemFocused(item.key),
            key: item.key,
            onClick: getItemSelectedHandler(item.key),
            onMouseEnter: _this2.getHoveredItemCallback(item.key)
          },
          getItemBody(item.props)
        );
      })
    );
  };

  return MultiSelectList;
}(React.PureComponent);

process.env.NODE_ENV !== "production" ? MultiSelectList.propTypes = {
  getItemBody: PropTypes.func,
  isOpen: PropTypes.bool,
  items: PropTypes.arrayOf(PropTypes.shape({
    key: PropTypes.string,
    props: PropTypes.object
  })),
  onListClose: PropTypes.func,
  selectedItems: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.number])),
  getItemSelectedHandler: PropTypes.func,
  onEnterKey: PropTypes.func,
  focusedItemKey: PropTypes.string,
  onFocusedItemChange: PropTypes.func,
  listRef: PropTypes.shape({
    current: PropTypes.instanceOf(typeof Element === 'undefined' ? function () {} : Element)
  }),
  toggleAllOptions: PropTypes.shape({
    onToggleAll: PropTypes.func.isRequired,
    selectLabel: PropTypes.string,
    clearLabel: PropTypes.string
  })
} : void 0;

var cx$q = classNames.bind(styles$l);

var baseClass$s = 'multiselect-head';

var MultiSelectHead = React.forwardRef(function (props, ref) {
  var _cx;

  var isFocused = props.isFocused,
      disabled = props.disabled,
      children = props.children,
      restProps = objectWithoutProperties(props, ['isFocused', 'disabled', 'children']);


  return React.createElement(
    'div',
    _extends({
      ref: ref,
      className: cx$q((_cx = {}, _cx['' + baseClass$s] = true, _cx[baseClass$s + '--focused'] = isFocused, _cx[baseClass$s + '--disabled'] = disabled, _cx)),
      'data-testid': 'multiselect-head'
    }, restProps, {
      disabled: disabled,
      tabIndex: disabled ? -1 : 0
    }),
    children
  );
});

process.env.NODE_ENV !== "production" ? MultiSelectHead.propTypes = {
  children: PropTypes.node,
  disabled: PropTypes.bool,
  isFocused: PropTypes.bool
} : void 0;

var baseClass$t = 'multiselect-head__item';

var MultiSelectHeadItem = function MultiSelectHeadItem(props) {
  var item = props.item,
      getSelectedItemBody = props.getSelectedItemBody;

  return React.createElement(
    'div',
    { className: styles$l['' + baseClass$t], 'data-testid': 'multiselect-head-item' },
    React.createElement(CloseIcon, {
      width: '14px',
      height: '14px',
      fill: '#fff',
      'data-testid': 'multiselect-remove-icon',
      onClick: function onClick(e) {
        return props.onRemove(e, item.key);
      },
      className: styles$l[baseClass$t + '-remove-icon']
    }),
    React.createElement(
      'div',
      { className: styles$l[baseClass$t + '-content'] },
      getSelectedItemBody(item.props)
    )
  );
};

process.env.NODE_ENV !== "production" ? MultiSelectHeadItem.propTypes = {
  item: PropTypes.shape({
    key: PropTypes.string,
    props: PropTypes.object
  }),
  getSelectedItemBody: PropTypes.func,
  onRemove: PropTypes.func
} : void 0;

var baseClass$u = 'multiselect-head';
var cx$r = classNames.bind(styles$l);

var Search$1 = function Search(props) {
  var _cx;

  var inputRef = props.inputRef,
      size = props.size,
      placeholder = props.placeholder,
      value = props.value,
      onChange = props.onChange,
      disabled = props.disabled,
      isDropdownOpen = props.isDropdownOpen;

  var onKeyDown = function onKeyDown(event) {
    if (event.keyCode === KeyCodes.enter) {
      event.preventDefault();
    }
  };

  return React.createElement('input', {
    ref: inputRef,
    className: cx$r((_cx = {}, _cx[baseClass$u + '__search'] = true, _cx[baseClass$u + '__search--expanded'] = placeholder || isDropdownOpen && value !== '', _cx)),
    type: 'text',
    size: size,
    placeholder: placeholder,
    name: 'select-box-input',
    'data-testid': 'multiselect-search-input',
    value: value,
    onChange: onChange,
    onKeyDown: onKeyDown,
    autoComplete: 'off',
    disabled: disabled
  });
};

process.env.NODE_ENV !== "production" ? Search$1.propTypes = {
  inputRef: PropTypes.shape({
    current: PropTypes.instanceOf(typeof Element === 'undefined' ? function () {} : Element)
  }),
  placeholder: PropTypes.string,
  value: PropTypes.string,
  onChange: PropTypes.func,
  disabled: PropTypes.bool,
  isDropdownOpen: PropTypes.bool,
  size: PropTypes.number
} : void 0;

var cx$s = classNames.bind(styles$l);

var baseClass$v = 'multiselect';

var MultiSelect = function (_React$PureComponent) {
  inherits(MultiSelect, _React$PureComponent);

  function MultiSelect(props) {
    classCallCheck(this, MultiSelect);

    var _this = possibleConstructorReturn(this, _React$PureComponent.call(this, props));

    _initialiseProps$1.call(_this);

    _this.state = {
      isOpen: props.openedOnInit || props.isOpen || false,
      searchPhrase: '',
      focusedItemKey: null,
      isFocused: false
    };

    _this.timeouts = [];
    _this.containerRef = React.createRef();
    _this.searchInputRef = React.createRef();
    _this.headRef = React.createRef();
    _this.listRef = React.createRef();
    _this.selectedItemsContainerRef = React.createRef();
    return _this;
  }

  MultiSelect.prototype.componentDidMount = function componentDidMount() {
    if (this.state.isOpen) {
      this.props.onDropdownToggle(true);
      this.onBodyOpen();
    }
  };

  MultiSelect.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    var hasIsOpenChanged = this.getIsOpen(prevProps, prevState) !== this.getIsOpen();

    if (this.getIsOpen() && hasIsOpenChanged) {
      this.onBodyOpen();
    } else if (!this.getIsOpen() && hasIsOpenChanged) {
      this.onBodyClose();
    }

    if (this.shouldScrollItemsContainer(prevProps) && this.selectedItemsContainerRef.current) {
      this.selectedItemsContainerRef.current.scrollTop = this.selectedItemsContainerRef.current.scrollHeight;
    }
  };

  MultiSelect.prototype.componentWillUnmount = function componentWillUnmount() {
    this.onBodyClose();
    document.removeEventListener('keydown', this.onArrowKeydown);
    document.removeEventListener('keydown', this.onBackspaceKeydown);
    this.timeouts.forEach(function (timerId) {
      clearTimeout(timerId);
    });
  };

  MultiSelect.prototype.render = function render() {
    var _cx,
        _this2 = this,
        _cx2;

    var _props = this.props,
        id = _props.id,
        className = _props.className,
        error = _props.error,
        items = _props.items,
        getItemBody = _props.getItemBody,
        getSelectedItemBody = _props.getSelectedItemBody,
        search = _props.search,
        disabled = _props.disabled,
        toggleAllOptions = _props.toggleAllOptions,
        maxItemsContainerHeight = _props.maxItemsContainerHeight,
        dataTestId = _props.dataTestId;

    var selectedItems = this.getSelectedItems();
    var _state = this.state,
        searchPhrase = _state.searchPhrase,
        focusedItemKey = _state.focusedItemKey,
        isFocused = _state.isFocused;

    var isOpen = this.getIsOpen();
    var selectedItemsModels = this.getSelectedItemsModels();
    var filteredItems = items.filter(this.filterItem);

    var mergedClassNames = getMergedClassNames(cx$s((_cx = {}, _cx[baseClass$v] = true, _cx[baseClass$v + '--error'] = error, _cx)), className);
    var headItemsStyles = selectedItems && selectedItems.length > 0 ? baseClass$v + '-head__items' : baseClass$v + '-head__items-empty';
    return React.createElement(
      'div',
      { ref: this.containerRef, className: mergedClassNames, id: id, 'data-testid': dataTestId },
      React.createElement(
        MultiSelectHead,
        {
          isFocused: isOpen || isFocused,
          ref: this.headRef,
          onClick: this.onSelectHeadClick,
          onFocus: this.onSelectHeadFocus,
          onBlur: this.onSelectHeadBlur,
          disabled: disabled
        },
        React.createElement(
          'div',
          {
            className: styles$l[headItemsStyles],
            style: { maxHeight: maxItemsContainerHeight },
            ref: this.selectedItemsContainerRef
          },
          selectedItemsModels && selectedItemsModels.map(function (item) {
            return React.createElement(MultiSelectHeadItem, {
              key: item.key,
              getSelectedItemBody: getSelectedItemBody,
              item: item,
              onRemove: _this2.handleItemRemove
            });
          }),
          search ? React.createElement(Search$1, {
            isDropdownOpen: isOpen,
            inputRef: this.searchInputRef,
            placeholder: this.getSearchPlaceholder(selectedItems),
            size: this.getInputSize(selectedItems),
            value: searchPhrase,
            onChange: this.onSearchChange,
            disabled: disabled
          }) : this.getSelectedItemsPlaceholder(selectedItems)
        ),
        React.createElement(MenuDownIcon, {
          'data-testid': 'multiselect-down-icon',
          className: styles$l[baseClass$v + '__dropdown-icon'],
          width: '24px',
          height: '24px',
          fill: '#424d57'
        })
      ),
      React.createElement(
        'div',
        {
          className: cx$s((_cx2 = {}, _cx2[baseClass$v + '-body'] = true, _cx2[baseClass$v + '-body--visible'] = isOpen && filteredItems.length > 0, _cx2))
        },
        React.createElement(MultiSelectList, {
          listRef: this.listRef,
          getItemBody: getItemBody,
          isOpen: isOpen,
          toggleAllOptions: toggleAllOptions,
          onListClose: this.hideSelectBody,
          items: filteredItems,
          getSelectedItemBody: getSelectedItemBody,
          selectedItems: selectedItems,
          getItemSelectedHandler: this.getItemSelectedHandler,
          onEnterKey: this.handleEnterKeyUse,
          onFocusedItemChange: this.changeFocusedItem,
          focusedItemKey: focusedItemKey
        })
      )
    );
  };

  return MultiSelect;
}(React.PureComponent);

var _initialiseProps$1 = function _initialiseProps() {
  var _this3 = this;

  this.onDocumentClick = function (event) {
    if (_this3.getIsOpen() && _this3.containerRef.current && !_this3.containerRef.current.contains(event.target)) {
      _this3.listRef.current.scrollTop = 0;
      _this3.hideSelectBody();
    }
  };

  this.onSearchChange = function (event) {
    _this3.setState({
      isOpen: true,
      searchPhrase: event.target.value
    }, function () {
      _this3.props.onDropdownToggle(true);
      var filteredItems = _this3.props.items.filter(function (v) {
        return _this3.filterItem(v) && _this3.props.selected !== v.key;
      });
      var focusedItemKey = filteredItems.length > 0 ? filteredItems[0].key : null;

      _this3.setState({
        focusedItemKey: focusedItemKey
      });
    });
  };

  this.onBodyOpen = function () {
    document.addEventListener('click', _this3.onDocumentClick);
    document.addEventListener('keydown', _this3.onBackspaceKeydown);
    _this3.delayedInputFocus();
  };

  this.onBodyClose = function () {
    document.removeEventListener('click', _this3.onDocumentClick);
    if (!_this3.state.isFocused) {
      document.removeEventListener('keydown', _this3.onBackspaceKeydown);
    }
  };

  this.onSelectHeadClick = function (event) {
    event.preventDefault();
    if (_this3.props.disabled) {
      return;
    }
    if (!_this3.getIsOpen()) {
      _this3.delayedInputFocus();
      _this3.showSelectBody();
    } else {
      _this3.hideSelectBody();
    }
  };

  this.onSelectHeadFocus = function () {
    _this3.setState({
      isFocused: true
    });
    document.addEventListener('keydown', _this3.onBackspaceKeydown);
    if (!_this3.state.isOpen) {
      document.addEventListener('keydown', _this3.onArrowKeydown);
    }
  };

  this.onSelectHeadBlur = function () {
    _this3.setState({
      isFocused: false
    });
    document.removeEventListener('keydown', _this3.onArrowKeydown);
    if (!_this3.state.isOpen) {
      document.removeEventListener('keydown', _this3.onBackspaceKeydown);
    }
  };

  this.onArrowKeydown = function (e) {
    if (e.keyCode === KeyCodes.arrowDown || e.keyCode === KeyCodes.arrowUp) {
      e.preventDefault();
      if (!_this3.state.isOpen) {
        _this3.showSelectBody();
      }
    }
  };

  this.onBackspaceKeydown = function (e) {
    var isCorrectKeyCode = e.keyCode === KeyCodes.backspace;
    var isSearchPhraseEmpty = _this3.state.searchPhrase === '';
    var isAnyItemsToRemove = _this3.props.selected && _this3.props.selected.length > 0;
    if (isCorrectKeyCode && isSearchPhraseEmpty && isAnyItemsToRemove) {
      e.preventDefault();
      var lastItemKey = _this3.props.selected[_this3.props.selected.length - 1];
      _this3.delayedItemRemove(lastItemKey);
    }
  };

  this.getItemSelectedHandler = function (itemKey) {
    return function (event) {
      event.preventDefault();
      _this3.handleItemSelect(itemKey);
      _this3.delayedInputFocus();
    };
  };

  this.getSelectedItems = function () {
    var selected = _this3.props.selected;

    if (selected === null) {
      return null;
    }
    return selected;
  };

  this.getSelectedItemsModels = function () {
    var _props2 = _this3.props,
        selected = _props2.selected,
        items = _props2.items;

    if (selected === null) {
      return null;
    }

    return selected.reduce(function (acc, selectedItemId) {
      var selectedItemModel = items.find(function (item) {
        return item.key === selectedItemId;
      });
      if (selectedItemModel) {
        return [].concat(acc, [selectedItemModel]);
      }
      return acc;
    }, []);
  };

  this.getDefaultInputSize = function (selectedItems) {
    if ((!selectedItems || selectedItems.length === 0) && _this3.props.placeholder) return _this3.props.placeholder.length;
    return 1;
  };

  this.getInputSize = function (selectedItems) {
    var defaultInputSize = _this3.getDefaultInputSize(selectedItems);

    if (_this3.state.searchPhrase.length > defaultInputSize) {
      return _this3.state.searchPhrase.length;
    }
    return defaultInputSize;
  };

  this.getSearchPlaceholder = function (selectedItems) {
    if ((!selectedItems || selectedItems.length === 0) && _this3.props.placeholder) {
      return _this3.props.placeholder;
    }
    return '';
  };

  this.getSelectedItemsPlaceholder = function (selectedItems) {
    if ((!selectedItems || selectedItems.length === 0) && _this3.props.placeholder) {
      return React.createElement(
        'div',
        { className: styles$l[baseClass$v + '__placeholder'] },
        _this3.props.placeholder
      );
    }
    return null;
  };

  this.getIsOpen = function () {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this3.props;
    var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this3.state;

    if (props.disabled) {
      return false;
    }
    return _this3.isIsOpenControlled() ? props.isOpen : state.isOpen;
  };

  this.shouldScrollItemsContainer = function (prevProps) {
    if (_this3.props.selected === null || !_this3.selectedItemsContainerRef.current) {
      return false;
    }
    return prevProps.selected === null && _this3.props.selected || prevProps.selected.length < _this3.props.selected.length;
  };

  this.handleItemSelect = function (itemKey) {
    _this3.setState({
      searchPhrase: ''
    });
    _this3.props.onItemSelect(itemKey);
    if (_this3.props.shouldCloseOnSelect) {
      _this3.hideSelectBody();
    }
  };

  this.handleEnterKeyUse = function (itemKey) {
    return _this3.handleItemSelect(itemKey);
  };

  this.handleItemRemove = function (e, itemKey) {
    e.preventDefault();
    e.stopPropagation();
    _this3.delayedItemRemove(itemKey);
  };

  this.showSelectBody = function () {
    _this3.setState({
      isOpen: true,
      searchPhrase: ''
    }, function () {
      _this3.props.onDropdownToggle(true);
    });
  };

  this.hideSelectBody = function () {
    _this3.setState({
      isOpen: false,
      searchPhrase: '',
      focusedItemKey: _this3.props.toggleAllOptions || !_this3.props.items[0] ? null : _this3.props.items[0].key
    }, function () {
      _this3.props.onDropdownToggle(false);
      if (_this3.headRef.current) {
        _this3.headRef.current.focus();
      }
    });
  };

  this.delayedInputFocus = function () {
    if (_this3.props.search && _this3.searchInputRef.current) {
      var timerId = setTimeout(function () {
        _this3.searchInputRef.current.focus();
      }, 0);
      _this3.timeouts = [].concat(_this3.timeouts, [timerId]);
    }
  };

  this.delayedItemRemove = function (itemKey) {
    var timerId = setTimeout(function () {
      _this3.props.onItemRemove(itemKey);
    }, 0);
    _this3.timeouts = [].concat(_this3.timeouts, [timerId]);
  };

  this.changeFocusedItem = function (itemKey) {
    if (_this3.props.toggleAllOptions && !itemKey) {
      return _this3.setState({
        focusedItemKey: null
      });
    }
    if (!itemKey) {
      return _this3.setState({
        focusedItemKey: _this3.props.items[0] ? _this3.props.items[0].key : null
      });
    }
    return _this3.setState({
      focusedItemKey: itemKey
    });
  };

  this.isIsOpenControlled = function () {
    return _this3.props.isOpen !== undefined;
  };

  this.filterItem = function (item) {
    var searchProperty = _this3.props.searchProperty;
    var searchPhrase = _this3.state.searchPhrase;


    if (searchPhrase) {
      if (typeof searchProperty === 'string') {
        if (!(searchProperty in item.props)) {
          return false;
        }

        return item.props[searchProperty].toLocaleLowerCase().includes(searchPhrase.toLocaleLowerCase());
      } else if (Array.isArray(searchProperty) && searchProperty.length > 0) {
        var validSearchProperties = searchProperty.filter(function (p) {
          return item.props[p];
        });

        if (validSearchProperties.length === 0) {
          return false;
        }
        return validSearchProperties.some(function (p) {
          return item.props[p].toLocaleLowerCase().includes(searchPhrase.toLocaleLowerCase());
        });
      }
    }

    return true;
  };
};

process.env.NODE_ENV !== "production" ? MultiSelect.propTypes = {
  id: PropTypes.string,
  className: PropTypes.string,
  dataTestId: PropTypes.string,
  error: PropTypes.string,
  getItemBody: PropTypes.func.isRequired,
  getSelectedItemBody: PropTypes.func.isRequired,
  onItemSelect: PropTypes.func.isRequired,
  onItemRemove: PropTypes.func.isRequired,
  items: PropTypes.arrayOf(PropTypes.shape({
    key: PropTypes.string,
    props: PropTypes.object
  })),
  /**
   * Use when you need to control multiselect dropdown visibility in its parent component
   * Remember to pass `onDropdownToggle` method as props, thanks to that you will be able to
   * update your state
   */
  isOpen: PropTypes.bool,
  placeholder: PropTypes.string,
  searchProperty: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),
  selected: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.number])),
  search: PropTypes.bool,
  /**
   * If `true` multiselect dropdown will be closed after option select/deselect
   */
  shouldCloseOnSelect: PropTypes.bool,
  disabled: PropTypes.bool,
  openedOnInit: PropTypes.bool,
  toggleAllOptions: PropTypes.shape({
    onToggleAll: PropTypes.func.isRequired,
    selectLabel: PropTypes.string,
    clearLabel: PropTypes.string
  }),
  maxItemsContainerHeight: PropTypes.number.isRequired,
  onDropdownToggle: PropTypes.func
} : void 0;

MultiSelect.defaultProps = {
  items: [],
  selected: null,
  shouldCloseOnSelect: false,
  onDropdownToggle: function onDropdownToggle() {}
};

var MultiSelectField = function MultiSelectField(props) {
  var inline = props.inline,
      error = props.error,
      description = props.description,
      labelText = props.labelText,
      labelAdornment = props.labelAdornment,
      className = props.className,
      id = props.id,
      fieldClassName = props.fieldClassName,
      restProps = objectWithoutProperties(props, ['inline', 'error', 'description', 'labelText', 'labelAdornment', 'className', 'id', 'fieldClassName']);


  return React.createElement(
    TextField,
    {
      inline: inline,
      error: error,
      description: description,
      labelText: labelText,
      labelAdornment: labelAdornment,
      className: className,
      htmlFor: id
    },
    React.createElement(MultiSelect, _extends({}, restProps, {
      className: fieldClassName,
      id: id,
      error: error
    }))
  );
};

process.env.NODE_ENV !== "production" ? MultiSelectField.propTypes = {
  labelText: PropTypes.string,
  /**  specifies additional decorative element rendered at the end of the label */
  labelAdornment: PropTypes.node,
  id: PropTypes.string.isRequired,
  className: PropTypes.string,
  fieldClassName: PropTypes.string,
  inline: PropTypes.bool,
  error: PropTypes.string,
  description: PropTypes.node
} : void 0;

var styles$m = { "numeric-input": "lc-numeric-input", "numeric-input__decrement": "lc-numeric-input__decrement", "numeric-input__increment": "lc-numeric-input__increment", "numeric-input--disabled": "lc-numeric-input--disabled", "numeric-input--error": "lc-numeric-input--error", "numeric-input--no-controls": "lc-numeric-input--no-controls" };

var cx$t = classNames.bind(styles$m);
var baseClass$w = 'numeric-input';

var NumericInput = function (_React$PureComponent) {
  inherits(NumericInput, _React$PureComponent);

  function NumericInput() {
    var _temp, _this, _ret;

    classCallCheck(this, NumericInput);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args))), _this), _this.hasMin = function () {
      return _this.props.min !== undefined;
    }, _this.hasMax = function () {
      return _this.props.max !== undefined;
    }, _this.onKeyDown = function (e) {
      if (e.keyCode === KeyCodes.arrowDown) {
        e.preventDefault();
        _this.changeValue(-1);
      }
      if (e.keyCode === KeyCodes.arrowUp) {
        e.preventDefault();
        _this.changeValue(1);
      }
    }, _this.getComponentStyles = function () {
      if (_this.props.width) {
        return _extends({}, _this.props.style || {}, {
          width: _this.props.width
        });
      }

      return _this.props.style;
    }, _this.addKeyboardEventListeners = function () {
      document.addEventListener('keydown', _this.onKeyDown);
    }, _this.removeKeyboardEventListeners = function () {
      document.removeEventListener('keydown', _this.onKeyDown);
    }, _this.changeValue = function (val) {
      if (_this.props.value !== '' && _this.props.value !== '-') {
        _this.callOnChange(_this.calcValue(parseInt(_this.props.value, 10) + val));
      } else if (_this.hasMin() && val < _this.props.min) {
        _this.callOnChange(_this.props.min);
      } else if (_this.hasMax() && val > _this.props.max) {
        _this.callOnChange(_this.props.max);
      } else {
        _this.callOnChange(val);
      }
    }, _this.handleChange = function (e) {
      e.preventDefault();
      e.stopPropagation();
      var value = _this.props.value;

      var inputVal = e.target.value.replace(/((?!([-]|([-]?\d+))).)/, '');

      if (inputVal === '') {
        _this.callOnChange('');
        return;
      }

      if (inputVal === '-') {
        _this.callOnChange('-');
        return;
      }

      var val = parseInt(inputVal, 10);

      if (String(val) !== inputVal) {
        _this.callOnChange(value);
      } else {
        var calculatedValue = _this.calcValue(val);
        _this.callOnChange(calculatedValue);
      }
    }, _this.callOnChange = function (value) {
      return _this.props.onChange(String(value));
    }, _this.calcValue = function (val) {
      var _this$props = _this.props,
          max = _this$props.max,
          min = _this$props.min;


      if (_this.hasMax() && val > max) {
        return max;
      }

      if (_this.hasMin() && val < min) {
        return min;
      }
      return val;
    }, _this.hasReachedTheLimit = function (value, margin) {
      return margin !== undefined && parseInt(value, 10) === margin;
    }, _this.handleIncrementClick = function () {
      _this.changeValue(1);
    }, _this.handleDecrementClick = function () {
      _this.changeValue(-1);
    }, _this.handleFocus = function () {
      _this.addKeyboardEventListeners();
    }, _this.handleBlur = function () {
      _this.removeKeyboardEventListeners();
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  NumericInput.prototype.componentDidMount = function componentDidMount() {
    if (this.hasMax() && parseInt(this.props.value, 10) > this.props.max) {
      this.callOnChange(this.props.max);
    }

    if (this.hasMin() && parseInt(this.props.value, 10) < this.props.min) {
      this.callOnChange(this.props.min);
    }
  };

  NumericInput.prototype.componentWillUnmount = function componentWillUnmount() {
    this.removeKeyboardEventListeners();
  };

  NumericInput.prototype.render = function render() {
    var _cx;

    var _props = this.props,
        error = _props.error,
        className = _props.className,
        max = _props.max,
        min = _props.min,
        onChange = _props.onChange,
        noControls = _props.noControls,
        value = _props.value,
        width = _props.width,
        disabled = _props.disabled,
        style = _props.style,
        restProps = objectWithoutProperties(_props, ['error', 'className', 'max', 'min', 'onChange', 'noControls', 'value', 'width', 'disabled', 'style']);


    var mergedClassNames = getMergedClassNames(cx$t((_cx = {}, _cx[baseClass$w] = true, _cx[baseClass$w + '--error'] = error, _cx[baseClass$w + '--no-controls'] = noControls, _cx[baseClass$w + '--disabled'] = disabled, _cx)), className);

    return React.createElement(
      'div',
      { className: mergedClassNames, style: this.getComponentStyles() },
      React.createElement('input', _extends({
        type: 'text'
      }, restProps, {
        value: value,
        disabled: disabled,
        onChange: this.handleChange,
        onFocus: this.handleFocus,
        onBlur: this.handleBlur,
        min: min,
        max: max
      })),
      !noControls && React.createElement(
        React.Fragment,
        null,
        React.createElement('button', {
          tabIndex: '-1',
          disabled: disabled || this.hasReachedTheLimit(value, max),
          onClick: this.handleIncrementClick,
          'aria-label': 'Increment value',
          className: styles$m[baseClass$w + '__increment'],
          type: 'button'
        }),
        React.createElement('button', {
          tabIndex: '-1',
          disabled: disabled || this.hasReachedTheLimit(value, min),
          'aria-label': 'Decrement value',
          className: styles$m[baseClass$w + '__decrement'],
          onClick: this.handleDecrementClick,
          type: 'button'
        })
      )
    );
  };

  return NumericInput;
}(React.PureComponent);

process.env.NODE_ENV !== "production" ? NumericInput.propTypes = {
  id: PropTypes.string,
  className: PropTypes.string,
  error: PropTypes.string,
  value: PropTypes.string,
  max: PropTypes.number,
  min: PropTypes.number,
  disabled: PropTypes.bool,
  /**
   * When equal `true` the up and down arrows won't be displayed
   */
  noControls: PropTypes.bool,
  style: PropTypes.object,
  /**
   * Static value of input width i.e. "120px" or "100%"  
   */
  width: PropTypes.string,
  /**
   * It's called with string value: '', '-' or '{number}'
   */
  onChange: PropTypes.func.isRequired
} : void 0;

var NumericInputField = function NumericInputField(props) {
  var inline = props.inline,
      error = props.error,
      description = props.description,
      labelText = props.labelText,
      labelAdornment = props.labelAdornment,
      className = props.className,
      id = props.id,
      fieldClassName = props.fieldClassName,
      restProps = objectWithoutProperties(props, ['inline', 'error', 'description', 'labelText', 'labelAdornment', 'className', 'id', 'fieldClassName']);


  return React.createElement(
    TextField,
    {
      inline: inline,
      error: error,
      description: description,
      labelText: labelText,
      labelAdornment: labelAdornment,
      className: className,
      htmlFor: id
    },
    React.createElement(NumericInput, _extends({}, restProps, {
      className: fieldClassName,
      id: id,
      error: error
    }))
  );
};

process.env.NODE_ENV !== "production" ? NumericInputField.propTypes = {
  labelText: PropTypes.string,
  /**  specifies additional decorative element rendered at the end of the label */
  labelAdornment: PropTypes.node,
  id: PropTypes.string.isRequired,
  className: PropTypes.string,
  fieldClassName: PropTypes.string,
  inline: PropTypes.bool,
  error: PropTypes.string,
  description: PropTypes.node
} : void 0;

var styles$n = { "date-picker": "lc-date-picker", "date-picker__wrapper": "lc-date-picker__wrapper", "date-picker__months": "lc-date-picker__months", "date-picker__month": "lc-date-picker__month", "date-picker__nav-bar": "lc-date-picker__nav-bar", "date-picker__nav-button": "lc-date-picker__nav-button", "date-picker__nav-button--interaction-disabled": "lc-date-picker__nav-button--interaction-disabled", "date-picker__caption": "lc-date-picker__caption", "date-picker__weekdays": "lc-date-picker__weekdays", "date-picker__weekdays-row": "lc-date-picker__weekdays-row", "date-picker__weekday": "lc-date-picker__weekday", "date-picker__week-number": "lc-date-picker__week-number", "date-picker__body": "lc-date-picker__body", "date-picker__week": "lc-date-picker__week", "date-picker__day": "lc-date-picker__day", "date-picker__day-content": "lc-date-picker__day-content", "date-picker__day-wrapper": "lc-date-picker__day-wrapper", "date-picker__day--today": "lc-date-picker__day--today", "date-picker__day--selected": "lc-date-picker__day--selected", "date-picker__day--outside": "lc-date-picker__day--outside", "date-picker__day--disabled": "lc-date-picker__day--disabled", "date-picker--interaction-disabled": "lc-date-picker--interaction-disabled", "date-picker__footer": "lc-date-picker__footer", "date-picker__today-button": "lc-date-picker__today-button", "date-picker__input": "lc-date-picker__input", "date-picker__input-overlay-wrapper": "lc-date-picker__input-overlay-wrapper", "date-picker__input-overlay": "lc-date-picker__input-overlay", "date-picker--range": "lc-date-picker--range", "date-picker__day--start": "lc-date-picker__day--start", "date-picker__day--end": "lc-date-picker__day--end", "date-picker__day--single": "lc-date-picker__day--single", "date-picker__day--sunday": "lc-date-picker__day--sunday", "date-picker__day--monday": "lc-date-picker__day--monday", "date-picker--range__select-input": "lc-date-picker--range__select-input", "date-picker--range__calendars-wrapper": "lc-date-picker--range__calendars-wrapper" };

var DatePickerNavbar = function DatePickerNavbar(props) {
  var _cx, _cx2, _cx3, _cx4;

  var onPreviousClick = props.onPreviousClick,
      onMonthChange = props.onMonthChange,
      onNextClick = props.onNextClick,
      showNextButton = props.showNextButton,
      showPreviousButton = props.showPreviousButton,
      className = props.className,
      classNames$$1 = props.classNames,
      numberOfMonths = props.numberOfMonths,
      month = props.month,
      fromMonth = props.fromMonth,
      toMonth = props.toMonth;


  var handlePrevClick = function handlePrevClick() {
    return onPreviousClick();
  };
  var handleNextClick = function handleNextClick() {
    return onNextClick();
  };

  var handlePrevYearClick = function handlePrevYearClick() {
    if (!fromMonth) {
      var _newMonth = dateFns.subMonths(month, 12);
      return onMonthChange(_newMonth);
    }
    var diff = Math.abs(dateFns.differenceInCalendarMonths(month, fromMonth));
    var newMonth = dateFns.subMonths(month, !Number.isNaN(diff) && diff > 12 ? 12 : diff);
    return onMonthChange(newMonth);
  };

  var handleNextYearClick = function handleNextYearClick() {
    if (!toMonth) {
      var _newMonth2 = dateFns.addMonths(month, 12);
      return onMonthChange(_newMonth2);
    }
    var diff = Math.abs(dateFns.differenceInCalendarMonths(toMonth, month));
    var newMonth = dateFns.addMonths(month, !Number.isNaN(diff) && diff > 12 ? 12 : diff);

    if (numberOfMonths === 2 && dateFns.isSameMonth(newMonth, toMonth)) {
      return onMonthChange(dateFns.subMonths(newMonth, 1));
    }
    return onMonthChange(newMonth);
  };

  return React.createElement(
    'div',
    { className: className },
    React.createElement(
      'div',
      { style: { display: 'flex' } },
      React.createElement(
        'button',
        {
          className: cx((_cx = {}, _cx[classNames$$1.navButtonPrev] = true, _cx[classNames$$1.navButtonInteractionDisabled] = !showPreviousButton, _cx)),
          onClick: handlePrevYearClick
        },
        React.createElement(ChevronDoubleLeftIcon, { width: '20px', height: '20px', fill: '#4384f5' })
      ),
      React.createElement(
        'button',
        {
          className: cx((_cx2 = {}, _cx2[classNames$$1.navButtonPrev] = true, _cx2[classNames$$1.navButtonInteractionDisabled] = !showPreviousButton, _cx2)),
          onClick: handlePrevClick
        },
        React.createElement(ChevronLeftIcon, { width: '20px', height: '20px', fill: '#4384f5' })
      )
    ),
    React.createElement(
      'div',
      { style: { display: 'flex' } },
      React.createElement(
        'button',
        {
          className: cx((_cx3 = {}, _cx3[classNames$$1.navButtonNext] = true, _cx3[classNames$$1.navButtonInteractionDisabled] = !showNextButton, _cx3)),
          onClick: handleNextClick
        },
        React.createElement(ChevronRightIcon, { width: '20px', height: '20px', fill: '#4384f5' })
      ),
      React.createElement(
        'button',
        {
          className: cx((_cx4 = {}, _cx4[classNames$$1.navButtonNext] = true, _cx4[classNames$$1.navButtonInteractionDisabled] = !showNextButton, _cx4)),
          onClick: handleNextYearClick
        },
        React.createElement(ChevronDoubleRightIcon, { width: '20px', height: '20px', fill: '#4384f5' })
      )
    )
  );
};

process.env.NODE_ENV !== "production" ? DatePickerNavbar.propTypes = {
  className: PropTypes.string,
  month: PropTypes.instanceOf(Date),
  fromMonth: PropTypes.instanceOf(Date),
  toMonth: PropTypes.instanceOf(Date),
  showNextButton: PropTypes.bool,
  showPreviousButton: PropTypes.bool,
  classNames: PropTypes.objectOf(PropTypes.string),
  numberOfMonths: PropTypes.number,
  onPreviousClick: PropTypes.func,
  onMonthChange: PropTypes.func,
  onNextClick: PropTypes.func
} : void 0;

var baseClass$x = 'date-picker';
var cx$u = classNames.bind(styles$n);

var DatePicker = function (_React$PureComponent) {
  inherits(DatePicker, _React$PureComponent);

  function DatePicker(props) {
    classCallCheck(this, DatePicker);

    var _this = possibleConstructorReturn(this, _React$PureComponent.call(this, props));

    _this.getDatePickerClassNames = function () {
      var _cx;

      return _extends({
        container: cx$u((_cx = {}, _cx[baseClass$x] = true, _cx[baseClass$x + '--range'] = _this.props.range, _cx)),
        wrapper: styles$n[baseClass$x + '__wrapper'],
        interactionDisabled: styles$n[baseClass$x + '--interaction-disabled'],
        months: styles$n[baseClass$x + '__months'],
        month: styles$n[baseClass$x + '__month'],
        navBar: styles$n[baseClass$x + '__nav-bar'],
        navButtonPrev: getMergedClassNames(styles$n[baseClass$x + '__nav-button'], styles$n[baseClass$x + '__nav-button--prev']),
        navButtonNext: getMergedClassNames(styles$n[baseClass$x + '__nav-button'], styles$n[baseClass$x + '__nav-button--next']),
        navButtonInteractionDisabled: styles$n[baseClass$x + '__nav-button--interaction-disabled'],
        caption: styles$n[baseClass$x + '__caption'],
        weekdays: styles$n[baseClass$x + '__weekdays'],
        weekdaysRow: styles$n[baseClass$x + '__weekdays-row'],
        weekday: styles$n[baseClass$x + '__weekday'],
        body: styles$n[baseClass$x + '__body'],
        week: styles$n[baseClass$x + '__week'],
        weekNumber: styles$n[baseClass$x + '__week-number'],
        day: styles$n[baseClass$x + '__day'],
        footer: styles$n[baseClass$x + '__footer'],
        todayButton: styles$n[baseClass$x + '__today-button'],
        today: styles$n[baseClass$x + '__day--today'],
        selected: styles$n[baseClass$x + '__day--selected'],
        disabled: styles$n[baseClass$x + '__day--disabled'],
        outside: styles$n[baseClass$x + '__day--outside'],
        start: styles$n[baseClass$x + '__day--start'],
        end: styles$n[baseClass$x + '__day--end']
      }, _this.props.classNames);
    };

    _this.handleMonthChange = function (month) {
      if (_this.props.onMonthChange && _this.props.month) {
        _this.props.onMonthChange(month);
        return;
      }

      _this.setState({
        month: month
      });
    };

    _this.renderDay = function (day) {
      var date = day.getDate();

      return React.createElement(
        'div',
        { className: styles$n[baseClass$x + '__day-wrapper'] },
        React.createElement(
          'div',
          { className: styles$n[baseClass$x + '__day-content'] },
          date
        )
      );
    };

    _this.state = {
      month: props.month || new Date()
    };
    return _this;
  }

  DatePicker.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
    if (props.month && props.month !== state.month) {
      return {
        month: props.month
      };
    }

    return null;
  };

  DatePicker.prototype.render = function render() {
    var _props = this.props,
        className = _props.className,
        range = _props.range,
        toMonth = _props.toMonth,
        fromMonth = _props.fromMonth,
        firstDayOfWeek = _props.firstDayOfWeek,
        numberOfMonths = _props.numberOfMonths,
        navbarElement = _props.navbarElement,
        renderDay = _props.renderDay,
        classNames$$1 = _props.classNames,
        month = _props.month,
        restProps = objectWithoutProperties(_props, ['className', 'range', 'toMonth', 'fromMonth', 'firstDayOfWeek', 'numberOfMonths', 'navbarElement', 'renderDay', 'classNames', 'month']);


    var datePickerClassNames = this.getDatePickerClassNames();

    return React.createElement(ReactDayPicker, _extends({
      navbarElement: navbarElement || React.createElement(DatePickerNavbar, {
        classNames: datePickerClassNames,
        numberOfMonths: numberOfMonths,
        onMonthChange: this.handleMonthChange,
        toMonth: toMonth,
        fromMonth: fromMonth
      }),
      ref: this.props.innerRef,
      classNames: datePickerClassNames,
      numberOfMonths: numberOfMonths,
      toMonth: toMonth,
      fromMonth: fromMonth,
      firstDayOfWeek: firstDayOfWeek || 1,
      month: this.state.month,
      renderDay: renderDay || this.renderDay
    }, restProps));
  };

  return DatePicker;
}(React.PureComponent);

var DatePicker$1 = React.forwardRef(function (props, ref) {
  return React.createElement(DatePicker, _extends({ innerRef: ref }, props));
});

var baseClass$y = 'date-picker--range';

var DatePickerRangeSelectInputs = function DatePickerRangeSelectInputs(props) {
  var fromDate = props.fromDate,
      toDate = props.toDate,
      from = props.from,
      to = props.to,
      restProps = objectWithoutProperties(props, ['fromDate', 'toDate', 'from', 'to']);


  return React.createElement(
    'div',
    restProps,
    React.createElement(Input, _extends({}, from, {
      className: getMergedClassNames(styles$n[baseClass$y + '__select-input'], from.className),
      tabIndex: 0,
      size: from.size || 10,
      placeholder: from.placeholder || 'YYYY-MM-DD',
      onClick: callAll(function (e) {
        return e.stopPropagation();
      }, from.onClose)
    })),
    React.createElement(
      'span',
      null,
      ' \u2014 '
    ),
    React.createElement(Input, _extends({}, to, {
      className: getMergedClassNames(styles$n[baseClass$y + '__select-input'], to.className),
      size: to.size || 10,
      tabIndex: fromDate === undefined ? -1 : 0,
      disabled: to.disabled || fromDate === undefined,
      placeholder: to.placeholder || 'YYYY-MM-DD',
      onClick: callAll(function (e) {
        return e.stopPropagation();
      }, to.onClose)
    }))
  );
};

process.env.NODE_ENV !== "production" ? DatePickerRangeSelectInputs.propTypes = {
  from: PropTypes.shape({
    value: PropTypes.string.isRequired,
    placeholder: PropTypes.string,
    onChange: PropTypes.func.isRequired,
    size: PropTypes.number
  }).isRequired,
  to: PropTypes.shape({
    value: PropTypes.string.isRequired,
    placeholder: PropTypes.string,
    onChange: PropTypes.func.isRequired,
    size: PropTypes.number
  }).isRequired
} : void 0;

var baseClass$z = 'date-picker--range';

var DatePickerRangeCalendarsWrapper = function DatePickerRangeCalendarsWrapper(props) {
  var className = props.className,
      children = props.children,
      restProps = objectWithoutProperties(props, ['className', 'children']);


  return React.createElement(
    'div',
    _extends({}, restProps, {
      className: getMergedClassNames(styles$n[baseClass$z + '__calendars-wrapper'], className)
    }),
    children
  );
};

process.env.NODE_ENV !== "production" ? DatePickerRangeCalendarsWrapper.propTypes = {
  children: PropTypes.node,
  className: PropTypes.string
} : void 0;

/* eslint-disable no-useless-escape */

/**
 * Helper for checking if input value has format YYYY-MM-DD
 * @param {string} value
 * @returns {boolean}
 */
var isValidDateFormat = function isValidDateFormat(value) {
  if (value.match(/^(?:(19|20)[0-9]{2})[\-](0[1-9]|1[012])[\-](0[1-9]|[12][0-9]|3[01])$/)) {
    return true;
  }
  return false;
};
/* eslint-enable no-useless-escape */

var isDateWithinRange = function isDateWithinRange(date, range) {
  var from = range.from,
      to = range.to;

  if (to && !dateFns.isSameDay(date, to) && dateFns.isAfter(date, to)) {
    return false;
  }
  if (from && !dateFns.isSameDay(date, from) && !dateFns.isAfter(date, from)) {
    return false;
  }
  return true;
};

var RangeDatePicker = function (_React$Component) {
  inherits(RangeDatePicker, _React$Component);

  function RangeDatePicker(props) {
    classCallCheck(this, RangeDatePicker);

    var _this = possibleConstructorReturn(this, _React$Component.call(this, props));

    _initialiseProps$2.call(_this);

    _this.initialState = {
      selectedItem: null,
      fromInputValue: '',
      toInputValue: '',
      from: undefined,
      to: undefined,
      error: null,
      enteredTo: undefined,
      currentMonth: props.initialToDate ? _this.calculateDatepickerMonth(props.initialToDate, props.initialFromDate && !dateFns.isSameMonth(props.initialFromDate, props.initialToDate)) : dateFns.subMonths(props.toMonth, 1)
    };

    var initialStateFromProps = _this.getStateFromInitialPropsValues(props);

    _this.state = _extends({}, _this.initialState, initialStateFromProps);
    return _this;
  }

  RangeDatePicker.prototype.render = function render() {
    return this.props.children(this.getRangeDatePickerApi());
  };

  return RangeDatePicker;
}(React.Component);

var _initialiseProps$2 = function _initialiseProps() {
  var _this2 = this;

  this.getStateFromInitialPropsValues = function (props) {
    var state = {};

    if (props.initialSelectedItemKey) {
      var selectedItem = _this2.getSelectedOption(props.options, props.initialSelectedItemKey);

      if (!selectedItem) {
        return {};
      }

      state.selectedItem = props.initialSelectedItemKey;

      if (!selectedItem.isManual) {
        return state;
      }

      if (props.initialFromDate) {
        state.from = props.initialFromDate;
        state.fromInputValue = _this2.mapDateToInputValue(props.initialFromDate);
      }
      if (props.initialToDate) {
        state.to = props.initialToDate;
        state.enteredTo = props.initialToDate;
        state.toInputValue = _this2.mapDateToInputValue(props.initialToDate);
      }
    }
    return state;
  };

  this.getSelectedOption = memoizeOne(function (options, itemId) {
    return options.find(function (item) {
      return item.id === itemId;
    });
  });
  this.getModifiers = memoizeOne(function (from, enteredTo) {
    var _base;

    var base = (_base = {}, _base[styles$n['date-picker__day--monday']] = { daysOfWeek: [1] }, _base[styles$n['date-picker__day--sunday']] = { daysOfWeek: [0] }, _base[styles$n['date-picker__day--start']] = from, _base[styles$n['date-picker__day--end']] = from, _base);

    if (enteredTo) {
      var _babelHelpers$extends3;

      var diff = dateFns.differenceInCalendarDays(enteredTo, from);
      if (diff > 0) {
        var _babelHelpers$extends;

        return _extends({}, base, (_babelHelpers$extends = {}, _babelHelpers$extends[styles$n['date-picker__day--end']] = enteredTo, _babelHelpers$extends));
      } else if (diff < 0) {
        var _babelHelpers$extends2;

        return _extends({}, base, (_babelHelpers$extends2 = {}, _babelHelpers$extends2[styles$n['date-picker__day--start']] = enteredTo, _babelHelpers$extends2));
      }
      return _extends({}, base, (_babelHelpers$extends3 = {}, _babelHelpers$extends3[styles$n['date-picker__day--start']] = [from, enteredTo], _babelHelpers$extends3[styles$n['date-picker__day--end']] = [from, enteredTo], _babelHelpers$extends3));
    }

    return base;
  });

  this.getRangeDatePickerApi = function () {
    var modifiers = _this2.getModifiers(_this2.state.from, _this2.state.enteredTo);

    var selectedOption = _this2.getSelectedOption(_this2.props.options, _this2.state.selectedItem);

    return {
      select: {
        onItemSelect: _this2.handleItemSelect,
        error: _this2.state.error,
        selected: _this2.state.selectedItem
      },
      inputs: {
        fromDate: _this2.state.from,
        toDate: _this2.state.to,
        from: {
          onKeyDown: _this2.handleFromInputKeyDown,
          onChange: _this2.handleDateFromChange,
          value: _this2.state.fromInputValue,
          ref: _this2.fromInputRef
        },
        to: {
          onKeyDown: _this2.handleToInputKeyDown,
          onChange: _this2.handleDateToChange,
          value: _this2.state.toInputValue,
          ref: _this2.toInputRef
        }
      },
      datepicker: {
        range: true,
        month: _this2.state.currentMonth,
        numberOfMonths: 2,
        onDayClick: _this2.handleDayClick,
        selectedDays: [_this2.state.from, { from: _this2.state.from, to: _this2.state.enteredTo }],
        modifiers: modifiers,
        initialMonth: _this2.state.from || dateFns.subMonths(_this2.props.toMonth, 1),
        toMonth: _this2.props.toMonth,
        disabledDays: { after: _this2.props.toMonth },
        onDayMouseEnter: _this2.handleDayMouseEnter,
        onMonthChange: _this2.handleMonthChange
      },
      selectedOption: selectedOption
    };
  };

  this.mapDateToInputValue = function (date) {
    return dateFns.format(date, 'YYYY-MM-DD');
  };

  this.handleMonthChange = function (month) {
    _this2.setState({
      currentMonth: month
    });
  };

  this.handleDayClick = function (day) {
    var _state = _this2.state,
        from = _state.from,
        to = _state.to;

    if (!isDateWithinRange(day, { to: _this2.props.toMonth })) {
      return;
    }

    if (_this2.isSelectingFirstDay(from, to, day)) {
      _this2.handleSelectFirstDay(day);
    } else if (dateFns.isSameDay(day, _this2.state.from) || dateFns.isAfter(day, _this2.state.from)) {
      _this2.handleSelectSecondDayAsFrom(day);
    } else {
      _this2.handleSelectSecondDayAsTo(day);
    }
  };

  this.handleSelectFirstDay = function (day) {
    _this2.setState({
      from: day,
      to: undefined,
      fromInputValue: _this2.mapDateToInputValue(day),
      toInputValue: '',
      enteredTo: undefined,
      error: null
    }, function () {
      if (_this2.toInputRef.current) {
        _this2.toInputRef.current.focus();
      }
    });
  };

  this.handleSelectSecondDayAsFrom = function (day) {
    _this2.setState({
      to: day,
      toInputValue: _this2.mapDateToInputValue(day),
      enteredTo: day,
      error: null
    }, function () {
      var selectedOption = _this2.getSelectedOption(_this2.props.options, _this2.state.selectedItem);

      _this2.props.onChange(_extends({}, selectedOption, {
        value: {
          from: _this2.state.from,
          to: _this2.state.to
        }
      }));
    });
  };

  this.handleSelectSecondDayAsTo = function (day) {
    _this2.setState({
      from: day,
      to: _this2.state.from,
      fromInputValue: _this2.mapDateToInputValue(day),
      toInputValue: _this2.state.fromInputValue,
      enteredTo: _this2.state.from,
      error: null
    }, function () {
      var selectedOption = _this2.getSelectedOption(_this2.props.options, _this2.state.selectedItem);

      _this2.props.onChange(_extends({}, selectedOption, {
        value: {
          from: _this2.state.from,
          to: _this2.state.to
        }
      }));
    });
  };

  this.handleItemSelect = function (itemKey) {
    if (itemKey === null) {
      _this2.setState(_extends({}, _this2.initialState), function () {
        _this2.props.onChange(null);
      });
    } else {
      var selectedOption = _this2.getSelectedOption(_this2.props.options, itemKey);

      if (!selectedOption) {
        return;
      }

      _this2.setState(_extends({}, _this2.initialState, {
        selectedItem: itemKey
      }), function () {
        if (!selectedOption.isManual) {
          var optionsHash = _this2.props.options.reduce(function (acc, option) {
            var _babelHelpers$extends4;

            return _extends({}, acc, (_babelHelpers$extends4 = {}, _babelHelpers$extends4[option.id] = option, _babelHelpers$extends4));
          }, {});
          _this2.props.onChange(optionsHash[itemKey]);
        } else {
          _this2.props.onChange(_extends({}, selectedOption, {
            value: {
              from: _this2.state.from,
              to: _this2.state.to
            }
          }));
        }
      });
    }
  };

  this.handleDateFromChange = function (e) {
    var value = e.target.value;


    var newState = {
      fromInputValue: value,
      error: null,
      from: undefined,
      to: undefined,
      toInputValue: '',
      enteredTo: undefined
    };

    if (!/^[0-9.-]*$/.test(value)) {
      return false;
    }

    if (!isValidDateFormat(value)) {
      return _this2.setState(_extends({}, newState, {
        error: 'Invalid date format'
      }));
    }

    if (!isDateWithinRange(new Date(value), { to: _this2.props.toMonth })) {
      return _this2.setState(_extends({}, newState, {
        error: 'The date can\'t be later than ' + dateFns.format(_this2.props.toMonth, 'YYYY-MM-DD')
      }));
    }

    if (_this2.state.to === undefined) {
      return _this2.setState(_extends({}, newState, {
        error: 'Please choose the end date',
        from: new Date(value),
        currentMonth: _this2.calculateDatepickerMonth(new Date(value))
      }));
    }

    return _this2.setState(_extends({}, newState, {
      from: new Date(value),
      currentMonth: _this2.calculateDatepickerMonth(new Date(value))
    }), function () {
      var selectedOption = _this2.getSelectedOption(_this2.props.options, _this2.state.selectedItem);
      _this2.props.onChange(_extends({}, selectedOption, {
        value: {
          from: _this2.state.from,
          to: _this2.state.to
        }
      }));
    });
  };

  this.handleDateToChange = function (e) {
    var value = e.target.value;


    var newState = {
      error: null,
      to: undefined,
      toInputValue: value,
      enteredTo: undefined
    };

    if (!/^[0-9.-]*$/.test(value)) {
      return false;
    }

    if (!isValidDateFormat(value)) {
      return _this2.setState(_extends({}, newState, {
        error: 'Invalid date format'
      }));
    }

    if (_this2.props.toMonth && !isDateWithinRange(new Date(value), {
      to: _this2.props.toMonth
    })) {
      return _this2.setState(_extends({}, newState, {
        error: 'The date can\'t be later than ' + dateFns.format(_this2.props.toMonth, 'YYYY-MM-DD')
      }));
    }

    if (!isDateWithinRange(new Date(value), {
      from: _this2.state.from
    })) {
      return _this2.setState(_extends({}, newState, {
        error: "The end date can't be before the start date"
      }));
    }

    if (_this2.state.from === undefined) {
      return _this2.setState(_extends({}, newState, {
        error: 'Please choose the start date',
        to: new Date(value),
        enteredTo: new Date(value),
        currentMonth: _this2.calculateDatepickerMonth(new Date(value), !dateFns.isSameMonth(new Date(value), _this2.state.from))
      }));
    }

    return _this2.setState(_extends({}, newState, {
      to: new Date(value),
      enteredTo: new Date(value),
      currentMonth: _this2.calculateDatepickerMonth(new Date(value), !dateFns.isSameMonth(new Date(value), _this2.state.from))
    }), function () {
      var selectedOption = _this2.getSelectedOption(_this2.props.options, _this2.state.selectedItem);
      _this2.props.onChange(_extends({}, selectedOption, {
        value: {
          from: _this2.state.from,
          to: _this2.state.to
        }
      }));
    });
  };

  this.handleDayMouseEnter = function (day) {
    var _state2 = _this2.state,
        from = _state2.from,
        to = _state2.to;


    var isInRange = _this2.props.toMonth ? dateFns.differenceInCalendarDays(_this2.props.toMonth, day) >= 0 : true;

    if (!_this2.isSelectingFirstDay(from, to, day) && isInRange) {
      _this2.setState({
        enteredTo: day
      });
    }
  };

  this.handleFromInputKeyDown = function (e) {
    if (e.keyCode === KeyCodes.enter) {
      e.stopPropagation();
      var isValid = _this2.state.from && isDateWithinRange(_this2.state.from, {
        to: _this2.props.toMonth
      });

      if (isValid && _this2.toInputRef.current) {
        _this2.toInputRef.current.focus();
      }
    }
  };

  this.handleToInputKeyDown = function (e) {
    if (e.keyCode === KeyCodes.enter) {
      e.stopPropagation();
      var isValid = _this2.state.to && isDateWithinRange(_this2.state.to, {
        from: _this2.state.from,
        to: _this2.props.toMonth
      });

      if (isValid && _this2.toInputRef.current) {
        _this2.toInputRef.current.blur();
      }
    }
  };

  this.isSelectingFirstDay = function (from, to) {
    var isRangeSelected = from && to;
    return !from || isRangeSelected;
  };

  this.calculateDatepickerMonth = function (date) {
    var forcePreviousMonth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (forcePreviousMonth || _this2.props.toMonth && dateFns.isSameMonth(date, _this2.props.toMonth)) {
      return dateFns.subMonths(date, 1);
    }
    return date;
  };

  this.toInputRef = React.createRef();
  this.fromInputRef = React.createRef();
};

process.env.NODE_ENV !== "production" ? RangeDatePicker.propTypes = {
  onChange: PropTypes.func,
  children: PropTypes.func,
  options: PropTypes.arrayOf(PropTypes.shape({
    label: PropTypes.string.isRequired,
    id: PropTypes.string.isRequired,
    isManual: PropTypes.bool,
    value: PropTypes.shape({
      from: PropTypes.instanceOf(Date),
      to: PropTypes.instanceOf(Date)
    })
  })).isRequired,
  initialSelectedItemKey: PropTypes.string,
  initialFromDate: PropTypes.instanceOf(Date),
  initialToDate: PropTypes.instanceOf(Date),
  toMonth: PropTypes.instanceOf(Date)
} : void 0;

RangeDatePicker.defaultProps = {
  toMonth: new Date()
};

var styles$o = { "switch": "lc-switch", "switch__track--enabled": "lc-switch__track--enabled", "switch__track--disabled": "lc-switch__track--disabled", "switch--basic": "lc-switch--basic", "switch--compact": "lc-switch--compact", "switch__input": "lc-switch__input", "switch__container": "lc-switch__container", "switch__track": "lc-switch__track", "switch__slider": "lc-switch__slider", "switch__slider--basic": "lc-switch__slider--basic", "switch__slider--basic--enabled": "lc-switch__slider--basic--enabled", "switch__slider--basic--disabled": "lc-switch__slider--basic--disabled", "switch__slider--compact": "lc-switch__slider--compact", "switch__slider--compact--enabled": "lc-switch__slider--compact--enabled", "switch__slider--compact--disabled": "lc-switch__slider--compact--disabled" };

var acceptedSizes$1 = ['basic', 'compact'];
var baseClass$A = 'switch';
var cx$v = classNames.bind(styles$o);
var noop$1 = function noop() {};

var SwitchComponent = function (_React$PureComponent) {
  inherits(SwitchComponent, _React$PureComponent);

  function SwitchComponent() {
    var _temp, _this, _ret;

    classCallCheck(this, SwitchComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args))), _this), _this.state = {
      enabled: _this.isControlledByProps() ? _this.props.on : _this.props.defaultOn,
      prevPropsOn: _this.props.on // eslint-disable-line react/no-unused-state
    }, _this.handleChange = function (e) {
      var hasCb = _this.props.onChange !== noop$1;
      if (hasCb) {
        _this.props.onChange(e, _this.state.enabled);
        return;
      }
      e.stopPropagation();
      _this.setState(function (prevState) {
        return {
          enabled: !prevState.enabled
        };
      });
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  SwitchComponent.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
    if (props.on !== state.prevPropsOn) {
      return {
        enabled: props.on,
        prevPropsOn: props.on
      };
    }
    return null;
  };

  SwitchComponent.prototype.isControlledByProps = function isControlledByProps() {
    return this.props.on !== undefined;
  };

  SwitchComponent.prototype.render = function render() {
    var _cx;

    var _props = this.props,
        className = _props.className,
        defaultOn = _props.defaultOn,
        onChange = _props.onChange,
        innerRef = _props.innerRef,
        on = _props.on,
        size = _props.size,
        name = _props.name,
        restProps = objectWithoutProperties(_props, ['className', 'defaultOn', 'onChange', 'innerRef', 'on', 'size', 'name']);
    var enabled = this.state.enabled;

    var mergedClassNames = getMergedClassNames(cx$v((_cx = {}, _cx[baseClass$A] = true, _cx[baseClass$A + '--' + size] = acceptedSizes$1.some(function (s) {
      return s === size;
    }), _cx)), className);
    var valueStyles = enabled ? 'enabled' : 'disabled';

    return React.createElement(
      'span',
      { className: mergedClassNames },
      React.createElement('input', _extends({
        type: 'checkbox',
        className: styles$o[baseClass$A + '__input'],
        onChange: this.handleChange,
        checked: enabled,
        name: name,
        ref: innerRef
      }, restProps)),
      React.createElement(
        'span',
        { className: styles$o[baseClass$A + '__container'] },
        React.createElement('span', {
          className: classNames(styles$o[baseClass$A + '__track'], styles$o[baseClass$A + '__track--' + valueStyles])
        }),
        React.createElement('span', {
          className: classNames(styles$o[baseClass$A + '__slider'], styles$o[baseClass$A + '__slider--' + size], styles$o[baseClass$A + '__slider--' + size + '--' + valueStyles])
        })
      )
    );
  };

  return SwitchComponent;
}(React.PureComponent);

var basePropTypes = {
  className: PropTypes.string,
  defaultOn: PropTypes.bool,
  /**
   * HTML disabled property
   */
  disabled: PropTypes.bool,
  name: PropTypes.string,
  on: PropTypes.bool,
  onChange: PropTypes.func,
  size: PropTypes.oneOf(acceptedSizes$1)
};

/* eslint-disable react/default-props-match-prop-types */
var baseDefaultProps = {
  defaultOn: false,
  onChange: noop$1,
  size: 'basic',
  name: baseClass$A
};

process.env.NODE_ENV !== "production" ? SwitchComponent.propTypes = _extends({}, basePropTypes, {
  innerRef: PropTypes.instanceOf(typeof Element === 'undefined' ? function () {} : Element)
}) : void 0;

SwitchComponent.defaultProps = baseDefaultProps;

var Switch = React.forwardRef(function (props, ref) {
  return React.createElement(SwitchComponent, _extends({ innerRef: ref }, props));
});

Switch.propTypes = basePropTypes;

Switch.defaultProps = baseDefaultProps;

var styles$p = { "inapp-base": "lc-inapp-base", "inapp-base__overlay": "lc-inapp-base__overlay", "inapp-base__overlay--visible": "lc-inapp-base__overlay--visible", "inapp-base__container": "lc-inapp-base__container", "inapp-base__wrapper": "lc-inapp-base__wrapper", "inapp-base__with_footer": "lc-inapp-base__with_footer", "inapp__body": "lc-inapp__body", "inapp-base__content-container": "lc-inapp-base__content-container", "inapp-base__close": "lc-inapp-base__close", "inapp__header": "lc-inapp__header", "inapp__header__avatar": "lc-inapp__header__avatar", "inapp__heading": "lc-inapp__heading", "inapp__image": "lc-inapp__image", "inapp__footer": "lc-inapp__footer", "inapp__footer__single_button": "lc-inapp__footer__single_button" };

var baseClass$B = 'inapp__header__avatar';

var InAppMessageAvatar = function InAppMessageAvatar(props) {
  var alt = props.alt,
      restProps = objectWithoutProperties(props, ['alt']);

  return React.createElement('img', _extends({
    className: styles$p['' + baseClass$B],
    alt: alt || 'Avatar'
  }, restProps));
};

process.env.NODE_ENV !== "production" ? InAppMessageAvatar.propTypes = {
  src: PropTypes.string.isRequired,
  alt: PropTypes.string.isRequired
} : void 0;

var baseClass$C = 'inapp-base__close';

var InAppMessageCloseButton = function InAppMessageCloseButton(props) {
  return React.createElement(
    'div',
    { className: styles$p['' + baseClass$C] },
    React.createElement(
      'button',
      { title: 'Close', onClick: props.onClick },
      React.createElement(CloseIcon, { width: '24px', height: '24px', fill: '#424D57' })
    )
  );
};

process.env.NODE_ENV !== "production" ? InAppMessageCloseButton.propTypes = {
  onClick: PropTypes.func.isRequired
} : void 0;

var baseClass$D = 'inapp';

var InAppMessageHeader = React.forwardRef(function (props, ref) {
  var className = props.className,
      avatarProps = props.avatar,
      text = props.text,
      onCloseButtonClick = props.onCloseButtonClick;


  var mergedClassNames = getMergedClassNames(styles$p[baseClass$D + '__header'], className);

  return React.createElement(
    'div',
    { className: mergedClassNames, ref: ref },
    avatarProps && React.createElement(InAppMessageAvatar, avatarProps),
    text && React.createElement(
      'div',
      { className: styles$p[baseClass$D + '__heading'] },
      text
    ),
    React.createElement(InAppMessageCloseButton, { onClick: onCloseButtonClick })
  );
});

process.env.NODE_ENV !== "production" ? InAppMessageHeader.propTypes = {
  className: PropTypes.string,
  avatar: PropTypes.shape(_extends({}, InAppMessageAvatar.propTypes)),
  text: PropTypes.node,
  onCloseButtonClick: PropTypes.func.isRequired
} : void 0;

var baseClass$E = 'inapp__footer';

var InAppMessageFooter = function InAppMessageFooter(props) {
  var mergedClassNames = getMergedClassNames(styles$p['' + baseClass$E], !props.buttons.remind ? styles$p[baseClass$E + '__single_button'] : null, props.className);

  var RemindButton = function RemindButton() {
    return null;
  };

  if (props.buttons.remind) {
    var _props$buttons$remind = props.buttons.remind,
        remindChildren = _props$buttons$remind.children,
        remindProps = objectWithoutProperties(_props$buttons$remind, ['children']);

    RemindButton = function RemindButton() {
      return React.createElement(
        Button,
        _extends({ secondary: true, fullWidth: true }, remindProps),
        remindChildren
      );
    };
  }
  var _props$buttons$cta = props.buttons.cta,
      ctaChildren = _props$buttons$cta.children,
      ctaProps = objectWithoutProperties(_props$buttons$cta, ['children']);


  return React.createElement(
    'div',
    { className: mergedClassNames },
    React.createElement(RemindButton, null),
    React.createElement(
      Button,
      _extends({ fullWidth: true, primary: true }, ctaProps),
      ctaChildren
    )
  );
};

process.env.NODE_ENV !== "production" ? InAppMessageFooter.propTypes = {
  className: PropTypes.string,
  buttons: PropTypes.shape({
    cta: PropTypes.shape(_extends({}, Button.propTypes.isRequired)).isRequired,
    remind: PropTypes.shape(_extends({}, Button.propTypes))
  })
} : void 0;

var baseClass$F = 'inapp-base';

var cx$w = classNames.bind(styles$p);

var InAppMessageBase = function (_React$PureComponent) {
  inherits(InAppMessageBase, _React$PureComponent);

  function InAppMessageBase() {
    var _temp, _this, _ret;

    classCallCheck(this, InAppMessageBase);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args))), _this), _this.onOverlayClick = function (event) {
      if (event.target === event.currentTarget) {
        _this.handleCloseInAppMessage();
      }
    }, _this.onCloseButtonClick = function (event) {
      event.preventDefault();
      event.stopPropagation();
      _this.handleCloseInAppMessage();
    }, _this.onKeyUp = function (event) {
      if (event.key && event.key === KeyNames.esc || event.keyCode && event.keyCode === KeyCodes.esc) {
        _this.handleCloseInAppMessage();
      }
    }, _this.addEventListeners = function () {
      if (_this.props.closeOnEscPress) {
        document.addEventListener('keyup', _this.onKeyUp, true);
      }
      document.addEventListener('click', _this.onDocumentClick);
    }, _this.removeEventListeners = function () {
      document.removeEventListener('keyup', _this.onKeyUp, true);
      document.removeEventListener('click', _this.onDocumentClick);
    }, _this.handleCloseInAppMessage = function () {
      _this.props.onClose();
    }, _this.inAppMessageContentRef = React.createRef(), _temp), possibleConstructorReturn(_this, _ret);
  }

  InAppMessageBase.prototype.componentDidMount = function componentDidMount() {
    this.addEventListeners();
  };

  InAppMessageBase.prototype.componentWillUnmount = function componentWillUnmount() {
    this.removeEventListeners();
  };

  InAppMessageBase.prototype.render = function render() {
    var _cx;

    var _props = this.props,
        className = _props.className,
        children = _props.children,
        header = _props.header,
        footerButtons = _props.footerButtons,
        title = _props.title,
        onClose = _props.onClose,
        closeOnEscPress = _props.closeOnEscPress,
        restProps = objectWithoutProperties(_props, ['className', 'children', 'header', 'footerButtons', 'title', 'onClose', 'closeOnEscPress']);


    var mergedClassNames = getMergedClassNames(styles$p['' + baseClass$F], className);

    return React.createElement(
      'div',
      {
        className: cx$w(baseClass$F + '__overlay', baseClass$F + '__overlay--visible'),
        onMouseDown: this.onOverlayClick
      },
      React.createElement(
        'div',
        { className: cx$w(baseClass$F + '__container') },
        React.createElement(
          'div',
          {
            ref: this.inAppMessageContentRef,
            className: cx$w(baseClass$F + '__wrapper')
          },
          React.createElement(InAppMessageHeader, {
            avatar: header && header.avatar ? header.avatar : undefined,
            text: header && header.text ? header.text : undefined,
            onCloseButtonClick: this.onCloseButtonClick
          }),
          React.createElement(
            'div',
            _extends({
              className: cx$w((_cx = {}, _cx[mergedClassNames] = true, _cx[baseClass$F + '__with_footer'] = footerButtons, _cx))
            }, restProps),
            React.createElement(
              'div',
              { className: cx$w(baseClass$F + '__content-container') },
              children
            ),
            footerButtons && React.createElement(InAppMessageFooter, { buttons: footerButtons })
          )
        )
      )
    );
  };

  return InAppMessageBase;
}(React.PureComponent);

InAppMessageBase.defaultProps = {
  closeOnEscPress: true
};


process.env.NODE_ENV !== "production" ? InAppMessageBase.propTypes = {
  className: PropTypes.string,
  children: PropTypes.node,
  header: PropTypes.shape({
    avatar: InAppMessageHeader.propTypes.avatar,
    text: InAppMessageHeader.propTypes.text
  }),
  onClose: InAppMessageHeader.propTypes.onCloseButtonClick,
  closeOnEscPress: PropTypes.bool,
  footerButtons: InAppMessageFooter.propTypes.buttons
} : void 0;

var InAppMessagePortal = function (_React$Component) {
  inherits(InAppMessagePortal, _React$Component);

  function InAppMessagePortal(props) {
    classCallCheck(this, InAppMessagePortal);

    var _this = possibleConstructorReturn(this, _React$Component.call(this, props));

    _this.inAppMessageContainer = document.createElement('div');
    if (_this.props.className) {
      _this.inAppMessageContainer.className = _this.props.className;
    }
    return _this;
  }

  InAppMessagePortal.prototype.componentDidMount = function componentDidMount() {
    var element = document.querySelector(this.props.parentElementName);
    if (element) element.appendChild(this.inAppMessageContainer);
  };

  InAppMessagePortal.prototype.componentWillUnmount = function componentWillUnmount() {
    var element = document.querySelector(this.props.parentElementName);
    if (element) element.removeChild(this.inAppMessageContainer);
  };

  InAppMessagePortal.prototype.render = function render() {
    return ReactDOM.createPortal(this.props.children, this.inAppMessageContainer);
  };

  return InAppMessagePortal;
}(React.Component);

InAppMessagePortal.defaultProps = {
  parentElementName: 'body'
};


process.env.NODE_ENV !== "production" ? InAppMessagePortal.propTypes = {
  className: PropTypes.string,
  children: PropTypes.node.isRequired,
  parentElementName: PropTypes.string
} : void 0;

var baseClass$G = 'inapp__image';

var InAppMessageImage = function InAppMessageImage(props) {
  var alt = props.alt,
      restProps = objectWithoutProperties(props, ['alt']);

  return React.createElement(
    'div',
    { className: styles$p['' + baseClass$G] },
    React.createElement('img', _extends({ alt: alt || 'InAppMessage Image' }, restProps))
  );
};

process.env.NODE_ENV !== "production" ? InAppMessageImage.propTypes = {
  src: PropTypes.string,
  alt: PropTypes.string
} : void 0;

var baseClass$H = 'inapp__body';

var InAppMessageBody = function InAppMessageBody(props) {
  var className = props.className,
      children = props.children,
      restProps = objectWithoutProperties(props, ['className', 'children']);

  var mergedClassNames = getMergedClassNames(styles$p['' + baseClass$H], className);

  return React.createElement(
    'div',
    _extends({}, restProps, { className: mergedClassNames }),
    children
  );
};

process.env.NODE_ENV !== "production" ? InAppMessageBody.propTypes = {
  className: PropTypes.string,
  children: PropTypes.node
} : void 0;

var baseClass$I = 'inapp';

var InAppMessage = function InAppMessage(props) {
  var imageProps = props.image,
      children = props.children,
      className = props.className,
      restProps = objectWithoutProperties(props, ['image', 'children', 'className']);


  var mergedClassNames = getMergedClassNames(styles$p['' + baseClass$I], className);

  return React.createElement(
    InAppMessageBase,
    _extends({ className: mergedClassNames }, restProps),
    imageProps && React.createElement(InAppMessageImage, imageProps),
    React.createElement(
      InAppMessageBody,
      null,
      children
    )
  );
};

process.env.NODE_ENV !== "production" ? InAppMessage.propTypes = _extends({}, InAppMessageBase.propTypes, {
  image: PropTypes.shape(_extends({}, InAppMessageImage.propTypes))
}) : void 0;

var styles$q = { "badge": "lc-badge", "badge--secondary": "lc-badge--secondary" };

function Badge(_ref) {
  var _babelHelpers$extends, _ref2;

  var children = _ref.children,
      extraClassName = _ref.className,
      secondary = _ref.secondary,
      props = objectWithoutProperties(_ref, ['children', 'className', 'secondary']);

  var className = cx(styles$q.badge, _extends((_babelHelpers$extends = {}, _babelHelpers$extends[styles$q['badge--secondary']] = secondary, _babelHelpers$extends), extraClassName ? (_ref2 = {}, _ref2[extraClassName] = true, _ref2) : {}));

  return React.createElement(
    'span',
    _extends({ className: className }, props),
    children
  );
}

process.env.NODE_ENV !== "production" ? Badge.propTypes = {
  children: PropTypes.node.isRequired,
  secondary: PropTypes.bool
} : void 0;

var styles$r = { "dropdown": "lc-dropdown", "dropdown--visible": "lc-dropdown--visible", "dropdown__list": "lc-dropdown__list", "dropdown__arrow": "lc-dropdown__arrow", "dropdown__list-item": "lc-dropdown__list-item", "dropdown__list-item__icon": "lc-dropdown__list-item__icon", "dropdown__list-item__content": "lc-dropdown__list-item__content", "dropdown__list-item__title": "lc-dropdown__list-item__title", "dropdown__list-item--focused": "lc-dropdown__list-item--focused", "dropdown__list-item__checkmark": "lc-dropdown__list-item__checkmark", "dropdown__list-item--selected": "lc-dropdown__list-item--selected", "dropdown__list-item--disabled": "lc-dropdown__list-item--disabled", "dropdown__list-item--with-divider": "lc-dropdown__list-item--with-divider" };

var cx$x = classNames.bind(styles$r);

var Dropdown = function (_React$PureComponent) {
  inherits(Dropdown, _React$PureComponent);

  function Dropdown() {
    var _temp, _this, _ret;

    classCallCheck(this, Dropdown);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args))), _this), _this.getModifiers = memoizeOne(Dropdown.buildPopperModifiers), _this.setPopupRef = function (ref) {
      _this.popupRef = ref;
    }, _this.setTriggerRef = function (ref) {
      _this.triggerRef = ref;
    }, _this.setTriggerRef = function (ref) {
      _this.triggerRef = ref;
    }, _this.handleDocumentClick = function (event) {
      if (_this.props.isVisible && _this.props.onClose && _this.popupRef && _this.triggerRef && !_this.popupRef.contains(event.target) && !_this.triggerRef.contains(event.target)) {
        _this.props.onClose();
      }
    }, _this.handleKeyDown = function (event) {
      var keyCode = event.keyCode;
      var _this$props = _this.props,
          closeKeyCodes = _this$props.closeKeyCodes,
          closeOnEnterPress = _this$props.closeOnEnterPress,
          closeOnEscPress = _this$props.closeOnEscPress,
          onClose = _this$props.onClose;


      if (onClose) {
        var isEscKeyPressed = keyCode === KeyCodes.esc;
        var isEnterKeyPressed = keyCode === KeyCodes.enter;
        var isCustomCloseKeyPressed = closeKeyCodes && closeKeyCodes.includes(keyCode);

        if (closeOnEscPress && isEscKeyPressed || closeOnEnterPress && isEnterKeyPressed || isCustomCloseKeyPressed) {
          onClose();
          if (_this.triggerRef) {
            _this.triggerRef.focus();
          }
        }
      }
    }, _this.attachResizeObserver = function () {
      // to boost component performance resize observer should be optional
      if (_this.props.shouldUpdateOnResize && _this.popupRef) {
        _this.observer = new ResizeObserver(function () {
          if (_this.popperScheduleUpdate) {
            _this.popperScheduleUpdate();
          }
        });
        _this.observer.observe(_this.popupRef);
      }
    }, _this.detachResizeObserver = function () {
      if (_this.observer) {
        _this.observer.disconnect();
      }
    }, _this.addEventHandlers = function () {
      document.addEventListener('keydown', _this.handleKeyDown, true);
      document.addEventListener('click', _this.handleDocumentClick);
    }, _this.removeEventHandlers = function () {
      document.removeEventListener('keydown', _this.handleKeyDown, true);
      document.removeEventListener('click', _this.handleDocumentClick);
    }, _this.renderDropdownContent = function (_ref) {
      var ref = _ref.ref,
          style = _ref.style,
          placement = _ref.placement,
          arrowProps = _ref.arrowProps,
          scheduleUpdate = _ref.scheduleUpdate;
      var _this$props2 = _this.props,
          className = _this$props2.className,
          isVisible = _this$props2.isVisible,
          zIndex = _this$props2.zIndex,
          children = _this$props2.children,
          modifiers = _this$props2.modifiers;

      var mergedClassNames = getMergedClassNames(cx$x({
        dropdown: true,
        'dropdown--visible': isVisible
      }), className);

      var computedModifiers = _this.getModifiers(modifiers);

      // updating `popperScheduleUpdate` reference used in resize observer
      _this.popperScheduleUpdate = scheduleUpdate;

      return React.createElement(
        'div',
        {
          ref: ref,
          tabIndex: 0,
          style: _extends({}, style, { zIndex: zIndex }),
          'data-placement': placement,
          className: mergedClassNames
        },
        children,
        computedModifiers.arrow.enabled && React.createElement('div', {
          ref: arrowProps.ref,
          className: styles$r.dropdown__arrow,
          'data-placement': placement,
          style: arrowProps.style
        })
      );
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  Dropdown.buildPopperModifiers = function buildPopperModifiers(modifiers) {
    var offset = modifiers.offset,
        flip = modifiers.flip,
        hide = modifiers.hide,
        preventOverflow = modifiers.preventOverflow,
        arrow = modifiers.arrow,
        rest = objectWithoutProperties(modifiers, ['offset', 'flip', 'hide', 'preventOverflow', 'arrow']);

    return _extends({
      offset: _extends({
        offset: (arrow || {}).enabled ? '0, 12' : '0, 4'
      }, offset || {}),
      flip: _extends({ enabled: true, behavior: 'flip' }, flip || {}),
      arrow: _extends({ enabled: false }, arrow || {}),
      hide: _extends({ enabled: true }, hide || {}),
      preventOverflow: _extends({
        enabled: true,
        escapeWithReference: true,
        boundariesElement: 'viewport'
      }, preventOverflow || {})
    }, rest);
  };

  Dropdown.prototype.componentDidMount = function componentDidMount() {
    if (this.props.isVisible) {
      this.addEventHandlers();
      this.attachResizeObserver();
    }
  };

  Dropdown.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
    var isShown = !prevProps.isVisible && this.props.isVisible;
    var isHidden = prevProps.isVisible && !this.props.isVisible;

    if (isShown) {
      this.addEventHandlers();
      this.attachResizeObserver();
      if (this.popupRef) {
        this.popupRef.focus({ preventScroll: true });
      }
    }

    if (isHidden) {
      this.removeEventHandlers();
      this.detachResizeObserver();
    }
  };

  Dropdown.prototype.componentWillUnmount = function componentWillUnmount() {
    this.removeEventHandlers();
    this.detachResizeObserver();
  };

  Dropdown.prototype.render = function render() {
    var _props = this.props,
        placement = _props.placement,
        triggerRenderer = _props.triggerRenderer,
        eventsEnabled = _props.eventsEnabled,
        positionFixed = _props.positionFixed,
        referenceElement = _props.referenceElement,
        isVisible = _props.isVisible;


    var computedModifiers = this.getModifiers(this.props.modifiers);

    return React.createElement(
      reactPopper.Manager,
      null,
      triggerRenderer && React.createElement(
        reactPopper.Reference,
        { innerRef: this.setTriggerRef },
        triggerRenderer
      ),
      isVisible && React.createElement(
        reactPopper.Popper,
        {
          innerRef: this.setPopupRef,
          placement: placement,
          modifiers: computedModifiers,
          eventsEnabled: eventsEnabled,
          positionFixed: positionFixed,
          referenceElement: referenceElement
        },
        this.renderDropdownContent
      )
    );
  };

  return Dropdown;
}(React.PureComponent);

process.env.NODE_ENV !== "production" ? Dropdown.propTypes = {
  children: PropTypes.node,
  className: PropTypes.string,
  closeOnEscPress: PropTypes.bool,
  closeOnEnterPress: PropTypes.bool,
  /**
   * you can specify which key press should trigger Dropdown close
   */
  closeKeyCodes: PropTypes.arrayOf(PropTypes.number),
  eventsEnabled: PropTypes.bool,
  isVisible: PropTypes.bool.isRequired,
  modifiers: PropTypes.object,
  placement: PropTypes.oneOf(['auto', 'auto-end', 'auto-start', 'bottom', 'bottom-end', 'bottom-start', 'left', 'left-end', 'left-start', 'right', 'right-end', 'right-start', 'top', 'top-end', 'top-start']),
  positionFixed: PropTypes.bool,
  referenceElement: PropTypes.shape({
    clientWidth: PropTypes.number.isRequired,
    clientHeight: PropTypes.number.isRequired
  }),
  /**
   * Pass `true` when it's possible that content of your dropdown will resize
   * (e.g removing list items on select)
   */
  shouldUpdateOnResize: PropTypes.bool,
  triggerRenderer: PropTypes.func,
  zIndex: PropTypes.number,
  onClose: PropTypes.func
} : void 0;

Dropdown.defaultProps = {
  modifiers: {},
  zIndex: 20,
  closeOnEscPress: true,
  closeOnEnterPress: false,
  placement: 'bottom-start',
  shouldUpdateOnResize: false
};

var cx$y = classNames.bind(styles$r);

var baseClass$J = 'dropdown__list-item';

var DropdownListItem = function (_React$PureComponent) {
  inherits(DropdownListItem, _React$PureComponent);

  function DropdownListItem() {
    var _temp, _this, _ret;

    classCallCheck(this, DropdownListItem);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args))), _this), _this.handleClick = function (event) {
      if (!_this.props.isDisabled && _this.props.onItemSelect) {
        event.nativeEvent.stopImmediatePropagation();
        _this.props.onItemSelect(_this.props.itemId, event);
      }
      if (_this.props.onClick) {
        _this.props.onClick(event);
      }
    }, _this.handleMouseOver = function (event) {
      if (!_this.props.isDisabled && _this.props.onMouseOverItem) {
        _this.props.onMouseOverItem(_this.props.itemId);
      }
      if (_this.props.onMouseOver) {
        _this.props.onMouseOver(event);
      }
    }, _this.handleMouseDown = function (event) {
      event.preventDefault();
      if (_this.props.onMouseDown) {
        _this.props.onMouseDown(event);
      }
      return false;
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  DropdownListItem.prototype.render = function render() {
    var _cx;

    var _props = this.props,
        className = _props.className,
        icon = _props.icon,
        itemId = _props.itemId,
        children = _props.children,
        isFocused = _props.isFocused,
        isSelected = _props.isSelected,
        onItemSelect = _props.onItemSelect,
        isDisabled = _props.isDisabled,
        onMouseOverItem = _props.onMouseOverItem,
        divider = _props.divider,
        restProps = objectWithoutProperties(_props, ['className', 'icon', 'itemId', 'children', 'isFocused', 'isSelected', 'onItemSelect', 'isDisabled', 'onMouseOverItem', 'divider']);


    var mergedClassNames = getMergedClassNames(cx$y((_cx = {}, _cx['' + baseClass$J] = true, _cx[baseClass$J + '--selected'] = isSelected, _cx[baseClass$J + '--focused'] = isFocused && !isDisabled, _cx[baseClass$J + '--disabled'] = isDisabled, _cx[baseClass$J + '--with-divider'] = divider, _cx)), className);

    return React.createElement(
      'li',
      _extends({}, restProps, {
        className: mergedClassNames,
        onClick: this.handleClick,
        onMouseOver: this.handleMouseOver,
        onMouseDown: this.handleMouseDown
      }),
      React.createElement(
        'div',
        { className: styles$r[baseClass$J + '__content'] },
        icon && React.createElement(
          'div',
          { className: styles$r[baseClass$J + '__icon'] },
          icon
        ),
        React.createElement(
          'div',
          { className: styles$r[baseClass$J + '__title'] },
          children
        )
      ),
      isSelected && React.createElement(CheckIcon, {
        width: '15px',
        height: '15px',
        className: styles$r[baseClass$J + '__checkmark']
      })
    );
  };

  return DropdownListItem;
}(React.PureComponent);

process.env.NODE_ENV !== "production" ? DropdownListItem.propTypes = {
  children: PropTypes.node.isRequired,
  className: PropTypes.string,
  icon: PropTypes.node,
  itemId: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,
  isFocused: PropTypes.bool,
  isSelected: PropTypes.bool,
  divider: PropTypes.bool,
  isDisabled: PropTypes.bool,
  onItemSelect: PropTypes.func,
  onClick: PropTypes.func,
  onMouseOver: PropTypes.func,
  onMouseOverItem: PropTypes.func,
  onMouseDown: PropTypes.func
} : void 0;

var findNextFocusableItem = function findNextFocusableItem(items, focusedItemId, keyCode) {
  if (keyCode !== KeyCodes.arrowUp && keyCode !== KeyCodes.arrowDown) {
    return undefined;
  }

  var currentItemIndex = items.map(function (item) {
    return item.itemId;
  }).indexOf(focusedItemId);

  var reorderedItems = currentItemIndex === -1 ? items : [].concat(items.slice(currentItemIndex, items.lenght), items.slice(0, currentItemIndex));

  var activeItems = reorderedItems.filter(function (item) {
    return !item.isDisabled && item.itemId !== focusedItemId;
  });

  if (keyCode === KeyCodes.arrowUp) {
    activeItems = activeItems.reverse();
  }

  return activeItems[0];
};

function getFirstFocusableItemId(items) {
  var focusableItem = items.find(function (item) {
    return !item.isDisabled;
  });

  if (!focusableItem) {
    return null;
  }
  return focusableItem.itemId;
}

var baseClass$K = 'dropdown';

var DropdownList = function (_React$PureComponent) {
  inherits(DropdownList, _React$PureComponent);

  function DropdownList(props) {
    classCallCheck(this, DropdownList);

    var _this = possibleConstructorReturn(this, _React$PureComponent.call(this, props));

    _this.onKeydown = function (event) {
      var keyCode = event.keyCode;


      if (keyCode === KeyCodes.arrowDown || keyCode === KeyCodes.arrowUp) {
        _this.handleArrowKeyUse(event);
      }

      if (_this.isItemSelectKeyCode(keyCode)) {
        event.preventDefault();
        _this.handleSelectKeyUse(event);
      }
    };

    _this.getFocusedItemCallback = function (itemKey) {
      if (!_this.hoverCallbacks[itemKey]) {
        _this.hoverCallbacks[itemKey] = function () {
          if (!_this.isHoverDisabled) {
            _this.changeFocusedElement(itemKey);
          }
        };
      }

      return _this.hoverCallbacks[itemKey];
    };

    _this.handleSelectKeyUse = function (event) {
      var focusedElement = _this.state.focusedElement;


      if (focusedElement !== null) {
        var selectedItem = _this.props.items.find(function (item) {
          return item.itemId === focusedElement;
        });

        if (selectedItem && selectedItem.onItemSelect) {
          selectedItem.onItemSelect(selectedItem.itemId, event);
        }
      }
    };

    _this.handleArrowKeyUse = function (event) {
      event.preventDefault();
      var keyCode = event.keyCode;
      var items = _this.props.items;


      var nextItem = findNextFocusableItem(items, _this.state.focusedElement, keyCode);

      if (nextItem) {
        _this.changeFocusedElement(nextItem.itemId);
        _this.scrollItems();
      }
    };

    _this.handleListScroll = function (event) {
      event.preventDefault();
      if (_this.props.onScroll) {
        _this.props.onScroll(event);
      }
      _this.enableHoverOnItems(150);
    };

    _this.changeFocusedElement = function (id) {
      _this.setState({
        focusedElement: id
      }, function () {
        var focusedItem = _this.props.items.find(function (item) {
          return item.itemId === id;
        });

        if (focusedItem && focusedItem.onItemFocus) {
          focusedItem.onItemFocus(focusedItem.itemdId);
        }
      });
    };

    _this.isItemSelectKeyCode = function (keyCode) {
      var itemSelectKeyCodes = _this.props.itemSelectKeyCodes;


      if (itemSelectKeyCodes && itemSelectKeyCodes.includes(keyCode)) {
        return true;
      }

      return false;
    };

    _this.scrollItems = function () {
      if (!_this.listRef.current) {
        return;
      }
      var focusedElement = _this.listRef.current.querySelector('.lc-' + baseClass$K + '__list-item--focused');

      if (focusedElement) {
        _this.isHoverDisabled = true;

        var _this$listRef$current = _this.listRef.current.getBoundingClientRect(),
            ulHeight = _this$listRef$current.height,
            ulTop = _this$listRef$current.top;

        var _focusedElement$getBo = focusedElement.getBoundingClientRect(),
            itemHeigth = _focusedElement$getBo.height,
            itemTop = _focusedElement$getBo.top;

        var relativeTop = itemTop + itemHeigth - ulTop;
        var itemOfsetTop = focusedElement.offsetTop;

        if (relativeTop > ulHeight) {
          _this.listRef.current.scrollTop = itemOfsetTop - ulHeight + itemHeigth;
        } else if (itemTop < ulTop) {
          _this.listRef.current.scrollTop = itemOfsetTop - itemOfsetTop % itemHeigth;
        }
      }

      _this.enableHoverOnItems(150);
    };

    _this.isHoverDisabled = false;
    _this.hoverEnablerTimeout = null;
    _this.hoverCallbacks = [];
    _this.listRef = React.createRef();


    _this.state = {
      focusedElement: _this.props.autoFocusedItemId || getFirstFocusableItemId(props.items),
      itemsCount: props.items.length
    };
    return _this;
  }

  DropdownList.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
    if (props.autoFocusOnItemsCountChange && props.items.length !== state.itemsCount) {
      return {
        focusedElement: getFirstFocusableItemId(props.items),
        itemsCount: props.items.length
      };
    }
    return null;
  };

  DropdownList.prototype.componentDidMount = function componentDidMount() {
    if (this.props.keyboardEventsEnabled) {
      document.addEventListener('keydown', this.onKeydown);
    }

    if (this.props.autoFocusedItemId) {
      this.scrollItems();
    }
  };

  DropdownList.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
    var eventsEnabled = !prevProps.keyboardEventsEnabled && this.props.keyboardEventsEnabled;
    var eventsDisabled = prevProps.keyboardEventsEnabled && !this.props.keyboardEventsEnabled;

    if (eventsEnabled) {
      document.addEventListener('keydown', this.onKeydown);
    } else if (eventsDisabled) {
      document.removeEventListener('keydown', this.onKeydown);
    }
  };

  DropdownList.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this.hoverEnablerTimeout) {
      clearTimeout(this.hoverEnablerTimeout);
    }
    document.removeEventListener('keydown', this.onKeydown);
  };

  DropdownList.prototype.enableHoverOnItems = function enableHoverOnItems(delayInMs) {
    var _this2 = this;

    if (this.hoverEnablerTimeout) {
      clearTimeout(this.hoverEnablerTimeout);
    }

    if (delayInMs) {
      this.hoverEnablerTimeout = setTimeout(function () {
        _this2.isHoverDisabled = false;
      }, delayInMs);
    } else {
      this.isHoverDisabled = false;
    }
  };

  DropdownList.prototype.render = function render() {
    var _this3 = this;

    var _props = this.props,
        className = _props.className,
        items = _props.items,
        getItemBody = _props.getItemBody,
        itemSelectKeyCodes = _props.itemSelectKeyCodes,
        autoFocusOnItemsCountChange = _props.autoFocusOnItemsCountChange,
        keyboardEventsEnabled = _props.keyboardEventsEnabled,
        restProps = objectWithoutProperties(_props, ['className', 'items', 'getItemBody', 'itemSelectKeyCodes', 'autoFocusOnItemsCountChange', 'keyboardEventsEnabled']);


    var mergedClassNames = getMergedClassNames(styles$r[baseClass$K + '__list'], className);

    return React.createElement(
      'ul',
      _extends({
        className: mergedClassNames,
        tabIndex: 0,
        onScroll: this.handleListScroll,
        ref: this.listRef
      }, restProps),
      items.map(function (_ref) {
        var content = _ref.content,
            itemId = _ref.itemId,
            props = _ref.props,
            onItemFocus = _ref.onItemFocus,
            itemRestProps = objectWithoutProperties(_ref, ['content', 'itemId', 'props', 'onItemFocus']);

        var itemProps = _extends({}, itemRestProps, {
          itemId: itemId,
          isFocused: _this3.state.focusedElement === itemId,
          onMouseOverItem: _this3.getFocusedItemCallback(itemId)
        });

        if (_this3.props.getItemBody) {
          return _this3.props.getItemBody(_extends({}, itemProps, {
            props: props || {},
            onItemFocus: onItemFocus,
            content: content
          }));
        }

        return React.createElement(
          DropdownListItem,
          _extends({ key: itemId }, itemProps),
          content
        );
      })
    );
  };

  return DropdownList;
}(React.PureComponent);

process.env.NODE_ENV !== "production" ? DropdownList.propTypes = {
  /**
   * Specify which item should be focused after dropdown open
   */
  autoFocusedItemId: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  autoFocusOnItemsCountChange: PropTypes.bool,
  className: PropTypes.string,
  /**
   * use this property to enable/disable keyboard events of DropdownList
   */
  keyboardEventsEnabled: PropTypes.bool,
  items: PropTypes.arrayOf(PropTypes.shape({
    className: PropTypes.string,
    itemId: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,
    content: PropTypes.node,
    divider: PropTypes.bool,
    icon: PropTypes.node,
    onItemSelect: PropTypes.func,
    onItemFocus: PropTypes.func,
    isDisabled: PropTypes.bool,
    isSelected: PropTypes.bool,
    props: PropTypes.object
  })).isRequired,
  getItemBody: PropTypes.func,
  onScroll: PropTypes.func,
  /**
   * you can specify which key press should trigger list item select
   */
  itemSelectKeyCodes: PropTypes.arrayOf(PropTypes.number)
} : void 0;

DropdownList.defaultProps = {
  keyboardEventsEnabled: true,
  itemSelectKeyCodes: [KeyCodes.enter]
};

var styles$s = { "popper-tooltip": "lc-popper-tooltip", "popper-tooltip--invert": "lc-popper-tooltip--invert", "popper-tooltip--important": "lc-popper-tooltip--important", "popper-tooltip-enter": "lc-popper-tooltip-enter", "popper-tooltip-enter-active": "lc-popper-tooltip-enter-active", "popper-tooltip-exit": "lc-popper-tooltip-exit", "popper-tooltip-exit-active": "lc-popper-tooltip-exit-active", "popper-tooltip__arrow": "lc-popper-tooltip__arrow", "css-tooltip": "lc-css-tooltip", "css-tooltip--visible": "lc-css-tooltip--visible", "css-tooltip--invert": "lc-css-tooltip--invert", "css-tooltip--important": "lc-css-tooltip--important", "css-tooltip__arrow": "lc-css-tooltip__arrow", "css-tooltip__close": "lc-css-tooltip__close", "popper-tooltip__close": "lc-popper-tooltip__close", "guide-tooltip--slide": "lc-guide-tooltip--slide", "guide-tooltip__overlay": "lc-guide-tooltip__overlay", "guide-tooltip__overlay--slide": "lc-guide-tooltip__overlay--slide", "guide-tooltip__overlay--visible": "lc-guide-tooltip__overlay--visible" };

function buildPopperModifiers(modifiers) {
  var offset = modifiers.offset,
      flip = modifiers.flip,
      hide = modifiers.hide,
      preventOverflow = modifiers.preventOverflow,
      arrow = modifiers.arrow,
      rest = objectWithoutProperties(modifiers, ['offset', 'flip', 'hide', 'preventOverflow', 'arrow']);

  var arrowProps = _extends({ enabled: true }, arrow || {});

  return _extends({
    offset: _extends({
      offset: arrowProps.enabled ? '0, 8' : '0, 4'
    }, offset || {}),
    flip: _extends({ enabled: true, behavior: 'flip' }, flip || {}),
    arrow: arrowProps,
    preventOverflow: _extends({
      enabled: true,
      escapeWithReference: true,
      boundariesElement: 'viewport'
    }, preventOverflow || {}),
    hide: _extends({ enabled: true }, hide || {})
  }, rest);
}

function buildPopperTooltipStyle(popperCalculatedStyle, propsStyle, zIndex, transitionDuration, transitionDelay) {
  return _extends({}, popperCalculatedStyle, propsStyle, {
    zIndex: zIndex,
    transitionDuration: transitionDuration + 'ms',
    transitionDelay: transitionDelay + 'ms'
  });
}

var baseClass$L = 'popper-tooltip';

var noop$2 = function noop() {};

var PopperTooltip = function (_React$PureComponent) {
  inherits(PopperTooltip, _React$PureComponent);

  function PopperTooltip() {
    var _temp, _this, _ret;

    classCallCheck(this, PopperTooltip);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args))), _this), _this.state = {
      isVisible: false
    }, _this.getModifiers = memoizeOne(buildPopperModifiers), _this.getTooltipStyle = memoizeOne(buildPopperTooltipStyle), _this.getIsVisible = function () {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.props;
      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this.state;
      return _this.isIsVisibleControlled() ? props.isVisible : state.isVisible;
    }, _this.setTooltipRef = function (ref) {
      _this.tooltipRef = ref;
    }, _this.setTriggerRef = function (ref) {
      _this.triggerRef = ref;
    }, _this.getTriggerRef = function () {
      return _this.props.triggerRef || _this.triggerRef;
    }, _this.getTooltipRef = function () {
      return _this.props.tooltipRef || _this.tooltipRef;
    }, _this.isIsVisibleControlled = function () {
      return _this.props.triggerActionType === 'managed';
    }, _this.handleTriggerMouseEnter = function () {
      _this.isTriggerHovered = true;
      _this.clearTooltipHideTimeout();
      _this.setState(function (prevState) {
        var shouldTriggerOpenCallback = !_this.isIsVisibleControlled() && !prevState.isVisible && _this.props.onOpen;

        if (shouldTriggerOpenCallback) {
          _this.props.onOpen();
        }

        return {
          isVisible: true
        };
      });
    }, _this.handleTriggerMouseLeave = function () {
      _this.isTriggerHovered = false;
      _this.handleDelayedTooltipHide();
    }, _this.handleTooltipMouseEnter = function () {
      _this.clearTooltipHideTimeout();
      var tooltipRef = _this.getTooltipRef();
      if (tooltipRef) {
        tooltipRef.addEventListener('mouseleave', _this.handleTooltipMouseLeave);
      }

      _this.setState({
        isVisible: true
      });
    }, _this.handleTooltipMouseLeave = function () {
      /**
       * We need to check `isTriggerHovered` condition to cover the following scenario.
       * Using custom offset can cause tooltip and trigger overlaping,
       * Then mouse events can be triggered in specific order:
       * - trigger mouse enter (mouse moves to trigger, tooltip shows),
       * - tooltip mouse leave (mouse still moves over trigger, but leaves tooltip),
       * - no second trigger mouse enter event (mouse still over trigger, so it was not entering trigger boudaries)
       * This will close tooltip component despite the fact that mouse cursor is over trigger.
       */
      if (!_this.isTriggerHovered) {
        _this.clearTooltipHideTimeout();
        _this.handleDelayedTooltipHide();
      }
    }, _this.handleTriggerClick = function () {
      _this.setState(function (prevState) {
        var isVisible = !prevState.isVisible;

        var shouldTriggerOpenCallback = !_this.isIsVisibleControlled() && isVisible && _this.props.onOpen;

        if (shouldTriggerOpenCallback) {
          _this.props.onOpen();
        }

        return {
          isVisible: isVisible
        };
      });
    }, _this.handleDelayedTooltipHide = function () {
      _this.hideTimerId = setTimeout(function () {
        _this.setState({
          isVisible: false
        });
      }, _this.props.hoverOutDelayTimeout);
    }, _this.clearTooltipHideTimeout = function () {
      if (_this.hideTimerId) {
        clearTimeout(_this.hideTimerId);
      }
    }, _this.manageTooltipListeners = function (didShow, didHide) {
      var tooltipRef = _this.getTooltipRef();
      if (!tooltipRef) {
        return;
      }

      if (didShow) {
        tooltipRef.addEventListener('mouseenter', _this.handleTooltipMouseEnter);
      }

      if (didHide) {
        tooltipRef.removeEventListener('mouseenter', _this.handleTooltipMouseEnter);
        tooltipRef.removeEventListener('mouseleave', _this.handleTooltipMouseLeave);
      }
    }, _this.handleDocumentClick = function (event) {
      var triggerRef = _this.getTriggerRef();
      var tooltipRef = _this.getTooltipRef();

      if (triggerRef && !triggerRef.contains(event.target) && tooltipRef && !tooltipRef.contains(event.target)) {
        _this.handleClose();
      }
    }, _this.handleDocumentKeyDown = function (event) {
      if (event.key === 'Escape') {
        _this.handleClose();
      }
    }, _this.handleClose = function () {
      if (_this.isIsVisibleControlled()) {
        _this.props.onClose();
      } else {
        _this.setState({
          isVisible: false
        });
      }
    }, _this.renderTriggerElement = function (_ref) {
      var ref = _ref.ref;
      var _this$props = _this.props,
          trigger = _this$props.trigger,
          triggerActionType = _this$props.triggerActionType;


      var triggerProps = { ref: ref };

      if (triggerActionType === 'click') {
        triggerProps.onClick = _this.handleTriggerClick;
      }

      if (triggerActionType === 'hover') {
        triggerProps.onMouseEnter = _this.handleTriggerMouseEnter;
        triggerProps.onMouseLeave = _this.handleTriggerMouseLeave;
      }

      if (typeof trigger === 'function') {
        return trigger(triggerProps);
      }

      return React.cloneElement(trigger, triggerProps);
    }, _this.renderPopperContent = function (_ref2) {
      var _cx, _cx2;

      var ref = _ref2.ref,
          popperCalculatedStyle = _ref2.style,
          placement = _ref2.placement,
          arrowProps = _ref2.arrowProps;
      var _this$props2 = _this.props,
          children = _this$props2.children,
          className = _this$props2.className,
          closeOnOutsideClick = _this$props2.closeOnOutsideClick,
          closeWithX = _this$props2.closeWithX,
          closeWithEsc = _this$props2.closeWithEsc,
          hoverOutDelayTimeout = _this$props2.hoverOutDelayTimeout,
          zIndex = _this$props2.zIndex,
          eventsEnabled = _this$props2.eventsEnabled,
          modifiers = _this$props2.modifiers,
          propsStyle = _this$props2.style,
          theme = _this$props2.theme,
          positionFixed = _this$props2.positionFixed,
          isVisible = _this$props2.isVisible,
          referenceElement = _this$props2.referenceElement,
          trigger = _this$props2.trigger,
          triggerActionType = _this$props2.triggerActionType,
          withFadeAnimation = _this$props2.withFadeAnimation,
          transitionDuration = _this$props2.transitionDuration,
          transitionDelay = _this$props2.transitionDelay,
          onOpen = _this$props2.onOpen,
          restProps = objectWithoutProperties(_this$props2, ['children', 'className', 'closeOnOutsideClick', 'closeWithX', 'closeWithEsc', 'hoverOutDelayTimeout', 'zIndex', 'eventsEnabled', 'modifiers', 'style', 'theme', 'positionFixed', 'isVisible', 'referenceElement', 'trigger', 'triggerActionType', 'withFadeAnimation', 'transitionDuration', 'transitionDelay', 'onOpen']);


      var computedModifiers = _this.getModifiers(_this.props.modifiers);
      var style = _this.getTooltipStyle(popperCalculatedStyle, propsStyle, zIndex, transitionDuration, transitionDelay);

      return React.createElement(
        'div',
        _extends({
          tabIndex: 0
        }, restProps, {
          ref: ref,
          style: style,
          'data-placement': placement,
          className: cx((_cx = {}, _cx[styles$s[baseClass$L]] = true, _cx[styles$s[baseClass$L + '--' + theme]] = theme, _cx[className] = className, _cx))
        }),
        closeWithX && React.createElement(
          'button',
          {
            type: 'button',
            onClick: _this.handleClose,
            className: styles$s[baseClass$L + '__close']
          },
          React.createElement(CloseIcon, { width: '16px', height: '16px' })
        ),
        children,
        computedModifiers.arrow.enabled && React.createElement('div', _extends({}, arrowProps, {
          className: cx((_cx2 = {}, _cx2[styles$s[baseClass$L + '__arrow']] = true, _cx2[arrowProps.className] = arrowProps.className, _cx2)),
          'data-placement': placement
        }))
      );
    }, _this.renderPopper = function () {
      var modifiers = _this.getModifiers(_this.props.modifiers);
      var isVisible = _this.getIsVisible();

      var popperComponent = React.createElement(
        reactPopper.Popper,
        {
          placement: _this.props.placement,
          modifiers: modifiers,
          innerRef: _this.props.tooltipRef || _this.setTooltipRef,
          eventsEnabled: _this.props.eventsEnabled,
          positionFixed: _this.props.positionFixed,
          referenceElement: _this.props.referenceElement
        },
        _this.renderPopperContent
      );

      if (_this.props.withFadeAnimation) {
        return React.createElement(
          reactTransitionGroup.CSSTransition,
          {
            timeout: _this.props.transitionDuration,
            mountOnEnter: true,
            unmountOnExit: true,
            'in': isVisible,
            classNames: styles$s[baseClass$L]
          },
          popperComponent
        );
      }

      return isVisible && popperComponent;
    }, _this.renderPopperManager = function () {
      return React.createElement(
        reactPopper.Manager,
        null,
        _this.props.trigger && React.createElement(
          reactPopper.Reference,
          { innerRef: _this.props.triggerRef || _this.setTriggerRef },
          _this.renderTriggerElement
        ),
        _this.renderPopper()
      );
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  PopperTooltip.prototype.componentDidMount = function componentDidMount() {
    if (this.props.closeOnOutsideClick && this.getIsVisible()) {
      document.addEventListener('click', this.handleDocumentClick);
    }
    if (this.props.closeWithEsc && this.getIsVisible()) {
      document.addEventListener('keydown', this.handleDocumentKeyDown);
    }
  };

  PopperTooltip.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    var prevIsVisible = this.getIsVisible(prevProps, prevState);
    var isVisible = this.getIsVisible();

    var didShow = !prevIsVisible && isVisible;
    var didHide = prevIsVisible && !isVisible;

    if (this.props.closeOnOutsideClick && didShow) {
      document.addEventListener('click', this.handleDocumentClick);
    }

    if (this.props.closeWithEsc && this.getIsVisible()) {
      document.addEventListener('keydown', this.handleDocumentKeyDown);
    }

    if (didHide) {
      document.removeEventListener('click', this.handleDocumentClick);
      document.removeEventListener('keydown', this.handleDocumentKeyDown);
    }

    if (this.props.triggerActionType === 'hover') {
      this.manageTooltipListeners(didShow, didHide);
    }
  };

  PopperTooltip.prototype.componentWillUnmount = function componentWillUnmount() {
    var tooltipRef = this.getTooltipRef();
    if (tooltipRef) {
      tooltipRef.removeEventListener('mouseenter', this.handleTooltipMouseEnter);
      tooltipRef.removeEventListener('mouseleave', this.handleTooltipMouseLeave);
    }
    document.removeEventListener('click', this.handleDocumentClick);
    document.removeEventListener('keydown', this.handleDocumentKeyDown);
  };

  PopperTooltip.prototype.render = function render() {
    return this.renderPopperManager();
  };

  return PopperTooltip;
}(React.PureComponent);

process.env.NODE_ENV !== "production" ? PopperTooltip.propTypes = {
  children: PropTypes.node.isRequired,
  className: PropTypes.string,
  /**
   * Use `closeOnOutsideClick=true` when you want tooltip to be closed on click outside it.
   * If you are using `triggerActionType='managed'` event handler will call provided onClose prop.
   */
  closeOnOutsideClick: PropTypes.bool,
  /**
   * Set to `true` to add an X button that will close the tooltip.
   */
  closeWithX: PropTypes.bool,
  /**
   * Set to `true` to close tooltip when ESC key is pressed.
   */
  closeWithEsc: PropTypes.bool,
  eventsEnabled: PropTypes.bool,
  /**
   * Number of miliseconds until tooltip close.
   * `hoverOutDelayTimeout` prop is important when you are using `triggerActionType='hover'`.
   * Thanks to this tooltip won't close when user moves mouse cursor from `trigger` to `tooltip`.
   */
  hoverOutDelayTimeout: PropTypes.number,
  isVisible: PropTypes.bool,
  /**
   * Set to `false` to turn off fade-in/fade-out animations.
   */
  withFadeAnimation: PropTypes.bool,
  style: PropTypes.object,
  /**
   * The theme changes the look of the tooltip.
   */
  theme: PropTypes.oneOf(['invert', 'important']),
  modifiers: PropTypes.object,
  onClose: PropTypes.func,
  placement: PropTypes.oneOf(['auto', 'auto-end', 'auto-start', 'bottom', 'bottom-end', 'bottom-start', 'left', 'left-end', 'left-start', 'right', 'right-end', 'right-start', 'top', 'top-end', 'top-start']),
  positionFixed: PropTypes.bool,
  tooltipRef: PropTypes.func,
  triggerRef: PropTypes.func,
  referenceElement: PropTypes.shape({
    clientWidth: PropTypes.number.isRequired,
    clientHeight: PropTypes.number.isRequired
  }),
  /**
   * Use this props to change default value of opacity transition duration (number of miliseconds).
   */
  transitionDuration: PropTypes.number,
  /**
   * Use this props to delay tooltip visibilty change (number of miliseconds).
   */
  transitionDelay: PropTypes.number,
  /**
   * You can pass as tooltip trigger element a renderer or a component. A couple of props will passed to your
   * component, depending on the chosen `triggerActionType`:
   * - `managed` - `ref`
   * - `click` - `onClick`
   * - `hover` - `onMouseEnter`, `onMouseLeave`
   */
  trigger: PropTypes.oneOfType([PropTypes.func, PropTypes.node]),
  /**
   * - Using `managed` will switch component visiblity to controlled state - you will need to provide isVisible props to show/hide tooltip.
   *   It's pretty usefull to handle custom use cases, for instance new feature info tooltips which will be shown to user only once.
   * - Using `click` and `hover` will make component visiblity uncontrolled (`isVisible` state handled by component itself). `isVisible` props won't affect
   *   component visibility.
   */
  triggerActionType: PropTypes.oneOf(['managed', 'click', 'hover']),
  zIndex: PropTypes.number.isRequired,
  /**
   * Use this props to trigger the function if the tooltip content is going to be visible. It works for `click` and `hover` trigger action types.
   */
  onOpen: PropTypes.func
} : void 0;

PopperTooltip.defaultProps = {
  hoverOutDelayTimeout: 100,
  modifiers: {},
  onClose: noop$2,
  style: {},
  withFadeAnimation: true,
  transitionDuration: 200,
  transitionDelay: 0,
  triggerActionType: 'hover',
  placement: 'bottom'
};

var baseClass$M = 'css-tooltip';

function handleTooltipOnClick(event) {
  event.stopPropagation();
}

function handleTooltipFocus(event) {
  event.stopPropagation();
}

var CssTooltip = function CssTooltip(props) {
  var _cx, _cx2;

  var children = props.children,
      className = props.className,
      isVisible = props.isVisible,
      placement = props.placement,
      width = props.width,
      style = props.style,
      theme = props.theme,
      zIndex = props.zIndex,
      arrowOffsetTop = props.arrowOffsetTop,
      arrowOffsetBottom = props.arrowOffsetBottom,
      arrowOffsetLeft = props.arrowOffsetLeft,
      arrowOffsetRight = props.arrowOffsetRight,
      arrowClassName = props.arrowClassName,
      offsetTop = props.offsetTop,
      offsetBottom = props.offsetBottom,
      offsetLeft = props.offsetLeft,
      offsetRight = props.offsetRight,
      onClose = props.onClose,
      restProps = objectWithoutProperties(props, ['children', 'className', 'isVisible', 'placement', 'width', 'style', 'theme', 'zIndex', 'arrowOffsetTop', 'arrowOffsetBottom', 'arrowOffsetLeft', 'arrowOffsetRight', 'arrowClassName', 'offsetTop', 'offsetBottom', 'offsetLeft', 'offsetRight', 'onClose']);


  return React.createElement(
    'div',
    _extends({}, restProps, {
      'data-placement': placement,
      className: cx((_cx = {}, _cx[styles$s[baseClass$M]] = true, _cx[styles$s[baseClass$M + '--visible']] = isVisible, _cx[styles$s[baseClass$M + '--' + theme]] = theme, _cx[className] = className, _cx)),
      style: _extends({
        top: offsetTop,
        bottom: offsetBottom,
        left: offsetLeft,
        right: offsetRight,
        zIndex: zIndex,
        width: width
      }, style || {})
    }),
    onClose && React.createElement(
      'button',
      {
        type: 'button',
        onClick: onClose,
        className: styles$s[baseClass$M + '__close']
      },
      React.createElement(CloseIcon, { width: '16px', height: '16px' })
    ),
    children,
    React.createElement('div', {
      className: cx((_cx2 = {}, _cx2[styles$s[baseClass$M + '__arrow']] = true, _cx2[arrowClassName] = arrowClassName, _cx2)),
      style: {
        top: arrowOffsetTop,
        bottom: arrowOffsetBottom,
        left: arrowOffsetLeft,
        right: arrowOffsetRight
      },
      'data-placement': placement
    })
  );
};

CssTooltip.defaultProps = {
  onClick: handleTooltipOnClick,
  onFocus: handleTooltipFocus,
  placement: 'bottom'
};

process.env.NODE_ENV !== "production" ? CssTooltip.propTypes = {
  /**
   * Css class name of tooltip arrow.
   * Use this property to extend styles of tooltip arrow, it's a different way to, for instance control position of arrow
   */
  arrowClassName: PropTypes.string,
  children: PropTypes.node.isRequired,
  /**
   * Css class name of tooltip.
   */
  className: PropTypes.string,
  style: PropTypes.object,
  /**
   * The theme changes the look of the tooltip.
   */
  theme: PropTypes.oneOf(['invert', 'important']),
  isVisible: PropTypes.bool,
  onClick: PropTypes.func,
  onFocus: PropTypes.func,
  /**
   * If provided, there will be an X button added to the tooltip that will invoke this callback when clicked.
   */
  onClose: PropTypes.func,
  width: PropTypes.string,
  placement: PropTypes.oneOf(['bottom', 'bottom-end', 'bottom-start', 'left', 'left-end', 'left-start', 'right', 'right-end', 'right-start', 'top', 'top-end', 'top-start']),
  /**
   * Use `arrowOffsetTop`, `arrowOffsetBottom`, `arrowOffsetLeft` or `arrowOffsetRight`
   * to control offset of arrow from one of the edges of tooltip
   */
  arrowOffsetTop: PropTypes.string,
  arrowOffsetBottom: PropTypes.string,
  arrowOffsetLeft: PropTypes.string,
  arrowOffsetRight: PropTypes.string,
  /**
   * Use `offsetTop`, `offsetBottom`, `offsetLeft` or `offsetRight`
   * to control offset of tooltip from one of the edges of reference element
   */
  offsetTop: PropTypes.string,
  offsetBottom: PropTypes.string,
  offsetLeft: PropTypes.string,
  offsetRight: PropTypes.string,
  zIndex: PropTypes.number
} : void 0;

var baseClass$N = 'guide-tooltip';

var cx$z = classNames.bind(styles$s);

var SpotlightOverlay = function SpotlightOverlay(_ref) {
  var _cx, _cx2, _cx3, _cx4, _cx5;

  var gap = _ref.gap,
      isVisible = _ref.isVisible,
      slide = _ref.slide,
      disablePointerEvents = _ref.disablePointerEvents;

  var overlayLeft = {
    top: gap.top + 'px',
    left: '0',
    width: gap.left + 'px',
    height: gap.height + 'px'
  };
  var overlayRight = {
    top: gap.top + 'px',
    left: gap.right + 'px',
    width: 'calc(100% - ' + gap.right + 'px)',
    height: gap.height + 'px'
  };
  var overlayTop = {
    top: '0',
    left: '0',
    width: '100%',
    height: gap.top + 'px'
  };
  var overlayBottom = {
    top: gap.bottom + 'px',
    left: '0',
    width: '100%',
    height: 'calc(100% - ' + gap.bottom + 'px)'
  };

  var spotlight = {
    top: gap.top + 'px',
    left: gap.left + 'px',
    width: gap.width + 'px',
    height: gap.height + 'px',
    backgroundColor: 'transparent'
  };

  return React.createElement(
    React.Fragment,
    null,
    React.createElement('div', {
      className: cx$z((_cx = {}, _cx[styles$s[baseClass$N + '__overlay']] = true, _cx[styles$s[baseClass$N + '__overlay--visible']] = isVisible, _cx[styles$s[baseClass$N + '__overlay--slide']] = slide, _cx)),
      style: overlayLeft
    }),
    React.createElement('div', {
      className: cx$z((_cx2 = {}, _cx2[styles$s[baseClass$N + '__overlay']] = true, _cx2[styles$s[baseClass$N + '__overlay--visible']] = isVisible, _cx2[styles$s[baseClass$N + '__overlay--slide']] = slide, _cx2)),
      style: overlayTop
    }),
    React.createElement('div', {
      className: cx$z((_cx3 = {}, _cx3[styles$s[baseClass$N + '__overlay']] = true, _cx3[styles$s[baseClass$N + '__overlay--visible']] = isVisible, _cx3[styles$s[baseClass$N + '__overlay--slide']] = slide, _cx3)),
      style: overlayRight
    }),
    React.createElement('div', {
      className: cx$z((_cx4 = {}, _cx4[styles$s[baseClass$N + '__overlay']] = true, _cx4[styles$s[baseClass$N + '__overlay--visible']] = isVisible, _cx4[styles$s[baseClass$N + '__overlay--slide']] = slide, _cx4)),
      style: overlayBottom
    }),
    disablePointerEvents && React.createElement('div', {
      className: cx$z((_cx5 = {}, _cx5[styles$s[baseClass$N + '__overlay']] = true, _cx5[styles$s[baseClass$N + '__overlay--visible']] = isVisible, _cx5[styles$s[baseClass$N + '__overlay--slide']] = slide, _cx5)),
      style: spotlight
    })
  );
};

process.env.NODE_ENV !== "production" ? SpotlightOverlay.propTypes = {
  gap: PropTypes.shape({
    top: PropTypes.number.isRequired,
    left: PropTypes.number.isRequired,
    bottom: PropTypes.number.isRequired,
    right: PropTypes.number.isRequired,
    width: PropTypes.number.isRequired,
    height: PropTypes.number.isRequired
  }).isRequired,
  isVisible: PropTypes.bool.isRequired,
  slide: PropTypes.bool.isRequired,
  disablePointerEvents: PropTypes.bool
} : void 0;

var VirtualReference = function () {
  function VirtualReference(element, padding) {
    classCallCheck(this, VirtualReference);

    this.element = element;
    this.padding = padding;
  }

  VirtualReference.prototype.addPadding = function addPadding(rect) {
    var x = Math.round(rect.left) - this.padding;
    var y = Math.round(rect.top) - this.padding;
    var width = Math.round(rect.width) + 2 * this.padding;
    var height = Math.round(rect.height) + 2 * this.padding;
    var top = y;
    var left = x;
    var bottom = top + height;
    var right = left + width;

    return {
      x: x,
      y: y,
      width: width,
      height: height,
      top: top,
      left: left,
      bottom: bottom,
      right: right
    };
  };

  VirtualReference.prototype.getBoundingClientRect = function getBoundingClientRect() {
    return this.addPadding(this.element.getBoundingClientRect());
  };

  createClass(VirtualReference, [{
    key: "clientWidth",
    get: function get$$1() {
      return this.getBoundingClientRect().width;
    }
  }, {
    key: "clientHeight",
    get: function get$$1() {
      return this.getBoundingClientRect().height;
    }
  }]);
  return VirtualReference;
}();

var baseClass$O = 'guide-tooltip';

var cx$A = classNames.bind(styles$s);

var virtualReference = function virtualReference(element, padding) {
  return new VirtualReference(element, padding);
};

var offsetModifiers = {
  offset: {
    offset: '0, 20'
  }
};

var spotlightPadding = 8;

var UserGuideTooltip = function (_React$PureComponent) {
  inherits(UserGuideTooltip, _React$PureComponent);

  UserGuideTooltip.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
    if (props.isVisible) {
      if (!state.lastElement) {
        // this is the first time the tooltip is shown - don't slide from the (0, 0) origin
        return {
          shouldSlide: false,
          lastElement: props.element,
          rect: virtualReference(props.element, spotlightPadding).getBoundingClientRect()
        };
      }

      if (props.element !== state.lastElement) {
        // the element has changed - slide to the next one
        return {
          shouldSlide: true,
          lastElement: props.element,
          rect: virtualReference(props.element, spotlightPadding).getBoundingClientRect()
        };
      }

      // window was scrolled or any other change has happened - don't slide
      return {
        shouldSlide: false
      };
    }

    // reset the element when the tooltip hides
    return {
      lastElement: null
    };
  };

  function UserGuideTooltip(props) {
    classCallCheck(this, UserGuideTooltip);

    var _this = possibleConstructorReturn(this, _React$PureComponent.call(this, props));

    _this.state = {
      shouldSlide: false,
      rect: virtualReference(props.element, spotlightPadding).getBoundingClientRect()
    };

    _this.handleViewPortChange = dataUtils.throttle(16, _this.handleDocumentChange.bind(_this));
    return _this;
  }

  UserGuideTooltip.prototype.componentDidMount = function componentDidMount() {
    window.addEventListener('resize', this.handleViewPortChange);
    (this.props.scrollableWrapper || document).addEventListener('scroll', this.handleViewPortChange);
  };

  UserGuideTooltip.prototype.componentWillUnmount = function componentWillUnmount() {
    window.removeEventListener('resize', this.handleViewPortChange);
    (this.props.scrollableWrapper || document).removeEventListener('scroll', this.handleViewPortChange);
  };

  UserGuideTooltip.prototype.handleDocumentChange = function handleDocumentChange() {
    this.setState({
      rect: virtualReference(this.props.element, spotlightPadding).getBoundingClientRect()
    });
  };

  UserGuideTooltip.prototype.render = function render() {
    var _cx;

    var _props = this.props,
        children = _props.children,
        className = _props.className,
        placement = _props.placement,
        zIndex = _props.zIndex,
        element = _props.element,
        isVisible = _props.isVisible,
        slide = _props.slide,
        theme = _props.theme,
        containerName = _props.containerName,
        disableSpotlightPointerEvents = _props.disableSpotlightPointerEvents;
    var rect = this.state.rect;


    var referenceElement = virtualReference(element, spotlightPadding);
    var shouldSlide = !!(slide && this.state.shouldSlide);

    return React.createElement(
      ModalPortal,
      { parentElementName: containerName, zIndex: zIndex },
      React.createElement(SpotlightOverlay, {
        gap: rect,
        isVisible: isVisible,
        slide: shouldSlide,
        disablePointerEvents: disableSpotlightPointerEvents
      }),
      React.createElement(
        PopperTooltip,
        {
          theme: theme || 'invert',
          className: cx$A((_cx = {}, _cx[styles$s[baseClass$O]] = true, _cx[styles$s[baseClass$O + '--slide']] = shouldSlide, _cx[className] = className, _cx)),
          placement: placement,
          triggerActionType: 'managed',
          isVisible: isVisible,
          referenceElement: referenceElement,
          zIndex: zIndex,
          modifiers: offsetModifiers
        },
        children
      )
    );
  };

  return UserGuideTooltip;
}(React.PureComponent);

process.env.NODE_ENV !== "production" ? UserGuideTooltip.propTypes = {
  children: PropTypes.node.isRequired,
  className: PropTypes.string,
  zIndex: PropTypes.number.isRequired,
  element: PropTypes.oneOfType([PropTypes.node, PropTypes.instanceOf(typeof Element === 'undefined' ? function () {} : Element)]).isRequired,
  scrollableWrapper: PropTypes.instanceOf(typeof Element === 'undefined' ? function () {} : Element),
  isVisible: PropTypes.bool.isRequired,
  slide: PropTypes.bool,
  theme: PropTypes.oneOf(['invert', 'important']),
  placement: PropTypes.oneOf(['auto', 'auto-end', 'auto-start', 'bottom', 'bottom-end', 'bottom-start', 'left', 'left-end', 'left-start', 'right', 'right-end', 'right-start', 'top', 'top-end', 'top-start']),
  containerName: PropTypes.string,
  disableSpotlightPointerEvents: PropTypes.bool
} : void 0;

var styles$t = { "divider": "lc-divider" };

var baseClass$P = 'divider';

var Divider = function Divider(props) {
  var className = props.className,
      restProps = objectWithoutProperties(props, ['className']);

  var mergedClassNames = getMergedClassNames(styles$t[baseClass$P], className);

  return React.createElement('div', _extends({ className: mergedClassNames }, restProps));
};

process.env.NODE_ENV !== "production" ? Divider.propTypes = {
  className: PropTypes.string
} : void 0;

var styles$u = { "progress-bar": "lc-progress-bar", "progress-bar--small": "lc-progress-bar--small", "progress-bar--medium": "lc-progress-bar--medium", "progress-bar--large": "lc-progress-bar--large", "progress-bar--error": "lc-progress-bar--error", "progress-bar__indicator": "lc-progress-bar__indicator", "progress-circle": "lc-progress-circle", "progress-circle--small": "lc-progress-circle--small", "progress-circle--medium": "lc-progress-circle--medium", "progress-circle--large": "lc-progress-circle--large", "progress-circle__bg-line": "lc-progress-circle__bg-line", "progress-circle__indicator": "lc-progress-circle__indicator", "progress-circle--error": "lc-progress-circle--error" };

var _THICKNESS_FROM_SIZE$1, _SIZE_VALUE_FROM_SIZE;

var PROGRESS_STATUS = {
  normal: 'normal',
  error: 'error',
  success: 'success'
};

var PROGRESS_SIZE = {
  small: 'small',
  medium: 'medium',
  large: 'large'
};

var PROGRESS_STATUSES = [PROGRESS_STATUS.normal, PROGRESS_STATUS.error, PROGRESS_STATUS.success];

var PROGRESS_SIZES = [PROGRESS_SIZE.small, PROGRESS_SIZE.medium, PROGRESS_SIZE.large];

var THICKNESS_FROM_SIZE$1 = (_THICKNESS_FROM_SIZE$1 = {}, _THICKNESS_FROM_SIZE$1[PROGRESS_SIZE.small] = 2, _THICKNESS_FROM_SIZE$1[PROGRESS_SIZE.medium] = 3, _THICKNESS_FROM_SIZE$1[PROGRESS_SIZE.large] = 4, _THICKNESS_FROM_SIZE$1);

var SIZE_VALUE_FROM_SIZE = (_SIZE_VALUE_FROM_SIZE = {}, _SIZE_VALUE_FROM_SIZE[PROGRESS_SIZE.small] = 15, _SIZE_VALUE_FROM_SIZE[PROGRESS_SIZE.medium] = 36, _SIZE_VALUE_FROM_SIZE[PROGRESS_SIZE.large] = 56, _SIZE_VALUE_FROM_SIZE);

function getPercentNumber(status) {
  var percent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  if (status === PROGRESS_STATUS.error) {
    return 0;
  }

  return parseInt(percent.toString(), 10);
}

function getProgressStatus(status, percent) {
  if (!PROGRESS_STATUSES.includes(status) && percent >= 100) {
    return PROGRESS_STATUS.normal;
  }

  return status || PROGRESS_STATUS.normal;
}

var cx$B = classNames.bind(styles$u);

var baseClass$Q = 'progress-bar';

var ProgressBar = React.forwardRef(function (_ref, ref) {
  var _cx;

  var status = _ref.status,
      percent = _ref.percent,
      size = _ref.size,
      className = _ref.className,
      restProps = objectWithoutProperties(_ref, ['status', 'percent', 'size', 'className']);

  var progressStatus = getProgressStatus(status, percent);
  var percentNumber = getPercentNumber(progressStatus, percent);

  var mergedClassNames = getMergedClassNames(cx$B((_cx = {}, _cx[baseClass$Q] = true, _cx[baseClass$Q + '--' + size] = size, _cx[baseClass$Q + '--error'] = progressStatus === PROGRESS_STATUS.error, _cx[baseClass$Q + '--success'] = progressStatus === PROGRESS_STATUS.success, _cx)), className);

  return React.createElement(
    'div',
    _extends({}, restProps, { className: mergedClassNames, ref: ref }),
    React.createElement('div', {
      className: styles$u[baseClass$Q + '__indicator'],
      style: { width: percentNumber + '%' }
    })
  );
});

process.env.NODE_ENV !== "production" ? ProgressBar.propTypes = {
  className: PropTypes.string,
  /**
   * Progress of upload presented on the `ProgressBar`
   */
  percent: PropTypes.number.isRequired,
  /**
   * Upload status of the file
   */
  status: PropTypes.oneOf(PROGRESS_STATUSES),
  /**
   * The size of the `ProgressBar`
   */
  size: PropTypes.oneOf(PROGRESS_SIZES)
} : void 0;

var cx$C = classNames.bind(styles$u);

var baseClass$R = 'progress-circle';

var ProgressCircle = React.forwardRef(function (_ref, ref) {
  var _cx;

  var status = _ref.status,
      percent = _ref.percent,
      className = _ref.className,
      size = _ref.size,
      restProps = objectWithoutProperties(_ref, ['status', 'percent', 'className', 'size']);

  var progressStatus = getProgressStatus(status, percent);
  var percentNumber = getPercentNumber(progressStatus, percent);
  var thickness = THICKNESS_FROM_SIZE$1[size];
  var sizeValue = SIZE_VALUE_FROM_SIZE[size];

  var mergedClassNames = getMergedClassNames(cx$C((_cx = {}, _cx[baseClass$R] = true, _cx[baseClass$R + '--' + size] = size, _cx[baseClass$R + '--error'] = progressStatus === PROGRESS_STATUS.error, _cx[baseClass$R + '--success'] = progressStatus === PROGRESS_STATUS.success, _cx)), className);

  var circumference = 2 * Math.PI * ((sizeValue - thickness) / 2);

  var indicatorStyle = {
    strokeDasharray: circumference.toFixed(3),
    strokeDashoffset: ((100 - percentNumber) / 100 * circumference).toFixed(3) + 'px'
  };

  var svgViewBox = sizeValue / 2 + ' ' + sizeValue / 2 + ' ' + sizeValue + ' ' + sizeValue;

  return React.createElement(
    'div',
    _extends({
      className: mergedClassNames,
      ref: ref,
      role: 'progressbar'
    }, restProps),
    React.createElement(
      'svg',
      { viewBox: svgViewBox },
      React.createElement('circle', {
        className: styles$u[baseClass$R + '__bg-line'],
        cx: sizeValue,
        cy: sizeValue,
        r: (sizeValue - thickness) / 2,
        fill: 'none',
        strokeWidth: thickness
      }),
      React.createElement('circle', {
        className: styles$u[baseClass$R + '__indicator'],
        style: indicatorStyle,
        cx: sizeValue,
        cy: sizeValue,
        r: (sizeValue - thickness) / 2,
        fill: 'none',
        strokeWidth: thickness
      })
    )
  );
});

process.env.NODE_ENV !== "production" ? ProgressCircle.propTypes = {
  className: PropTypes.string,
  /**
   * Progress of upload presented on the `ProgressBar`
   */
  percent: PropTypes.number.isRequired,
  /**
   * Upload status of the file
   */
  status: PropTypes.oneOf(PROGRESS_STATUSES),
  /**
   * The size of the `ProgressBar`
   */
  size: PropTypes.oneOf(PROGRESS_SIZES)
} : void 0;

ProgressCircle.defaultProps = {
  size: PROGRESS_SIZE.medium
};

var styles$v = { "promo": "lc-promo", "promo__content": "lc-promo__content", "promo__wrapper": "lc-promo__wrapper", "promo__header": "lc-promo__header", "promo__img": "lc-promo__img", "promo__button-text": "lc-promo__button-text", "promo--light": "lc-promo--light", "promo--small": "lc-promo--small", "promo__footer": "lc-promo__footer", "promo--medium": "lc-promo--medium", "promo--large": "lc-promo--large", "promo__close-icon": "lc-promo__close-icon" };

var cx$D = classNames.bind(styles$v);

var baseClass$S = 'promo';

var Promo = function Promo(props) {
  var _cx;

  var buttonText = props.buttonText,
      children = props.children,
      className = props.className,
      header = props.header,
      image = props.image,
      light = props.light,
      linkText = props.linkText,
      onButtonClick = props.onButtonClick,
      onClose = props.onClose,
      onLinkClick = props.onLinkClick,
      size = props.size,
      img = props.img,
      restProps = objectWithoutProperties(props, ['buttonText', 'children', 'className', 'header', 'image', 'light', 'linkText', 'onButtonClick', 'onClose', 'onLinkClick', 'size', 'img']);


  var mergedWrapperClassNames = getMergedClassNames(cx$D((_cx = {}, _cx[baseClass$S + '--light'] = light, _cx[baseClass$S + '--' + size] = size, _cx['' + baseClass$S] = true, _cx)), className);
  var shouldRenderLargeFooter = (buttonText || linkText) && size === 'large';
  var shouldRenderSmallOrMediumFooter = (buttonText || linkText) && size !== 'large';

  var footer = React.createElement(
    'div',
    { className: styles$v[baseClass$S + '__footer'] },
    buttonText && React.createElement(
      Button,
      {
        kind: 'primary',
        size: 'compact',
        onClick: onButtonClick,
        className: styles$v[baseClass$S + '__button-text']
      },
      buttonText
    ),
    linkText && React.createElement(
      Button,
      { size: 'compact', kind: 'text', onClick: onLinkClick },
      linkText
    )
  );

  return React.createElement(
    'div',
    _extends({ className: mergedWrapperClassNames }, restProps),
    React.createElement(
      'div',
      { className: styles$v[baseClass$S + '__content'] },
      img && React.createElement('img', { src: img, className: styles$v[baseClass$S + '__img'] }),
      React.createElement(
        'div',
        { className: styles$v[baseClass$S + '__wrapper'] },
        React.createElement(
          'div',
          { className: styles$v[baseClass$S + '__header'] },
          header
        ),
        React.createElement(
          'div',
          null,
          children
        ),
        shouldRenderSmallOrMediumFooter && footer
      ),
      shouldRenderLargeFooter && footer
    ),
    React.createElement(
      'button',
      {
        type: 'button',
        className: styles$v[baseClass$S + '__close-icon'],
        onClick: onClose
      },
      React.createElement(CloseIcon, { fill: '#424d57' })
    )
  );
};
process.env.NODE_ENV !== "production" ? Promo.propTypes = {
  className: PropTypes.string,
  buttonText: PropTypes.string,
  children: PropTypes.node.isRequired,
  header: PropTypes.string.isRequired,
  image: PropTypes.node,
  img: PropTypes.string,
  light: PropTypes.bool,
  linkText: PropTypes.string,
  onButtonClick: PropTypes.func,
  onClose: PropTypes.func,
  onLinkClick: PropTypes.func,
  size: PropTypes.oneOf(['small', 'medium', 'large'])
} : void 0;

Promo.defaultProps = {
  size: 'small'
};

var styles$w = { "upload-bar": "lc-upload-bar", "upload-bar__main": "lc-upload-bar__main", "upload-bar--single": "lc-upload-bar--single", "upload-bar--success": "lc-upload-bar--success", "upload-bar--error": "lc-upload-bar--error", "upload-bar__error-icon": "lc-upload-bar__error-icon", "upload-bar__success-icon": "lc-upload-bar__success-icon", "upload-bar__header": "lc-upload-bar__header", "progress-circle": "lc-progress-circle", "upload-bar__files": "lc-upload-bar__files", "upload-bar__files--enter": "lc-upload-bar__files--enter", "upload-bar__files--enter-active": "lc-upload-bar__files--enter-active", "upload-bar__files--exit": "lc-upload-bar__files--exit", "upload-bar__files--exit-active": "lc-upload-bar__files--exit-active", "upload-bar__files--exit-done": "lc-upload-bar__files--exit-done", "upload-bar__files-wrapper": "lc-upload-bar__files-wrapper", "upload-bar__list": "lc-upload-bar__list", "file-upload-progress": "lc-file-upload-progress", "upload-bar__collapse-btn": "lc-upload-bar__collapse-btn", "upload-bar__title": "lc-upload-bar__title", "file-upload-progress__actions": "lc-file-upload-progress__actions", "file-upload-progress--with-actions-on-hover": "lc-file-upload-progress--with-actions-on-hover", "file-upload-progress__header": "lc-file-upload-progress__header", "file-upload-progress__icon": "lc-file-upload-progress__icon", "file-upload-progress__wrapper": "lc-file-upload-progress__wrapper", "file-upload-progress__title": "lc-file-upload-progress__title", "file-upload-progress--with-icon": "lc-file-upload-progress--with-icon", "file-upload-progress--error": "lc-file-upload-progress--error", "file-upload-progress--success": "lc-file-upload-progress--success", "file-upload-progress__success-icon": "lc-file-upload-progress__success-icon", "upload-bar__actions": "lc-upload-bar__actions", "file-upload-progress__close": "lc-file-upload-progress__close", "file-upload-progress__retry": "lc-file-upload-progress__retry", "upload-bar__close": "lc-upload-bar__close", "upload-bar__retry": "lc-upload-bar__retry" };

var styles$x = { "collapse-icon": "lc-collapse-icon", "collapse-icon__bottom-arrow": "lc-collapse-icon__bottom-arrow", "collapse-icon__top-arrow": "lc-collapse-icon__top-arrow", "collapse-icon--expanded": "lc-collapse-icon--expanded" };

var cx$E = classNames.bind(styles$x);

var baseClass$T = 'collapse-icon';

var CollapseIcon = function CollapseIcon(_ref) {
  var _cx;

  var isExpanded = _ref.isExpanded,
      className = _ref.className,
      restProps = objectWithoutProperties(_ref, ['isExpanded', 'className']);

  var mergedClassNames = getMergedClassNames(cx$E((_cx = {}, _cx[baseClass$T] = true, _cx[baseClass$T + '--expanded'] = isExpanded, _cx)), className);

  return React.createElement(
    'svg',
    _extends({
      width: '18',
      height: '18',
      viewBox: '0 0 18 18'
    }, restProps, {
      className: mergedClassNames
    }),
    React.createElement('path', {
      className: styles$x[baseClass$T + '__top-arrow'],
      d: 'M7 18V16H3.41L7.91 11.5L6.5 10.09L2 14.59V11H0V18H7Z'
    }),
    React.createElement('path', {
      className: styles$x[baseClass$T + '__bottom-arrow'],
      d: 'M11.5001 7.91L16.0001 3.41V7H18.0001V0H11.0001V2H14.5901L10.0901 6.5L11.5001 7.91Z'
    })
  );
};

process.env.NODE_ENV !== "production" ? CollapseIcon.propTypes = {
  className: PropTypes.string,
  isExpanded: PropTypes.bool
} : void 0;

var UPLOAD_BAR_MODE = {
  single: 'single',
  multiple: 'multiple'
};

var UPLOAD_BAR_MODES = [UPLOAD_BAR_MODE.single, UPLOAD_BAR_MODE.multiple];

var UPLOAD_PROGRESS_ACTIONS_STATE = {
  visible: 'visible',
  hover: 'hover',
  hidden: 'hidden'
};

var UPLOAD_PROGRESS_ACTIONS_STATES = [UPLOAD_PROGRESS_ACTIONS_STATE.visible, UPLOAD_PROGRESS_ACTIONS_STATE.hover, UPLOAD_PROGRESS_ACTIONS_STATE.hidden];

var cx$F = classNames.bind(styles$w);

var baseClass$U = 'file-upload-progress';

var FileUploadProgressActions = function FileUploadProgressActions(props) {
  if (!props.onRetryButtonClick && !props.onCloseButtonClick || !props.isVisible) {
    return null;
  }

  return React.createElement(
    'div',
    { className: styles$w[baseClass$U + '__actions'] },
    props.onRetryButtonClick && props.progressStatus === 'error' && React.createElement(
      'button',
      {
        type: 'button',
        className: styles$w[baseClass$U + '__retry'],
        'aria-label': 'Retry',
        onClick: props.onRetryButtonClick
      },
      React.createElement(RefreshIcon, null)
    ),
    props.onCloseButtonClick && props.progressStatus !== PROGRESS_STATUS.success && React.createElement(
      'button',
      {
        type: 'button',
        className: styles$w[baseClass$U + '__close'],
        'aria-label': 'Close',
        onClick: props.onCloseButtonClick
      },
      React.createElement(CloseIcon, null)
    )
  );
};

process.env.NODE_ENV !== "production" ? FileUploadProgressActions.propTypes = {
  /**
   * Useful to cancel the file upload or to remove the file when it's upload resulted in an error
   */
  onCloseButtonClick: PropTypes.func,
  /**
   * Useful to retry the file upload
   */
  onRetryButtonClick: PropTypes.func,
  progressStatus: PropTypes.oneOf(PROGRESS_STATUSES),
  isVisible: PropTypes.bool,
  className: PropTypes.string
} : void 0;

var FileUploadProgress = React.forwardRef(function (props, ref) {
  var _cx;

  var className = props.className,
      icon = props.icon,
      percent = props.percent,
      status = props.status,
      title = props.title,
      size = props.size,
      actionsVisibilityState = props.actionsVisibilityState,
      onCloseButtonClick = props.onCloseButtonClick,
      onRetryButtonClick = props.onRetryButtonClick,
      restProps = objectWithoutProperties(props, ['className', 'icon', 'percent', 'status', 'title', 'size', 'actionsVisibilityState', 'onCloseButtonClick', 'onRetryButtonClick']);


  var progressStatus = getProgressStatus(status, percent);
  var percentNumber = getPercentNumber(progressStatus, percent);

  var mergedClassNames = getMergedClassNames(cx$F((_cx = {}, _cx[baseClass$U] = true, _cx[baseClass$U + '--with-icon'] = icon, _cx[baseClass$U + '--error'] = progressStatus === PROGRESS_STATUS.error, _cx[baseClass$U + '--success'] = progressStatus === PROGRESS_STATUS.success, _cx[baseClass$U + '--with-actions-on-hover'] = actionsVisibilityState === UPLOAD_PROGRESS_ACTIONS_STATE.hover, _cx)), className);

  return React.createElement(
    'div',
    _extends({}, restProps, { className: mergedClassNames, ref: ref }),
    icon && progressStatus !== PROGRESS_STATUS.success && React.createElement(
      'div',
      { className: styles$w[baseClass$U + '__icon'] },
      icon
    ),
    progressStatus === PROGRESS_STATUS.success && React.createElement(
      'div',
      { className: styles$w[baseClass$U + '__success-icon'] },
      React.createElement(CheckIcon, null)
    ),
    React.createElement(
      'div',
      { className: styles$w[baseClass$U + '__wrapper'] },
      React.createElement(
        'div',
        { className: styles$w[baseClass$U + '__header'] },
        title && React.createElement(
          'div',
          { className: styles$w[baseClass$U + '__title'] },
          title
        ),
        React.createElement(FileUploadProgressActions, {
          onRetryButtonClick: onRetryButtonClick,
          onCloseButtonClick: onCloseButtonClick,
          isVisible: props.actionsVisibilityState !== 'hidden',
          progressStatus: progressStatus
        })
      ),
      progressStatus !== PROGRESS_STATUS.success && React.createElement(ProgressBar, {
        size: size,
        percent: percentNumber,
        status: progressStatus
      })
    )
  );
});

process.env.NODE_ENV !== "production" ? FileUploadProgress.propTypes = {
  /**
   * Use `actionsVisibilityState` to control visibility of file upload actions (refresh and remove)
   */
  actionsVisibilityState: PropTypes.oneOf(UPLOAD_PROGRESS_ACTIONS_STATES),
  className: PropTypes.string,
  /**
   * Usually an icon of the uploaded file
   */
  icon: PropTypes.node,
  /**
   * Usually a name of the uploaded file
   */
  title: PropTypes.string,
  /**
   * Progress of upload presented on the `ProgressBar`
   */
  percent: PropTypes.number,
  /**
   * The size of the `ProgressBar`
   */
  size: PropTypes.oneOf(PROGRESS_SIZES),
  /**
   * Upload status of the file
   */
  status: PropTypes.oneOf(PROGRESS_STATUSES),
  /**
   * Useful to cancel the file upload or to remove the file when it's upload resulted in an error
   */
  onCloseButtonClick: PropTypes.func,
  /**
   * Useful to retry the file upload
   */
  onRetryButtonClick: PropTypes.func
} : void 0;

var cx$G = classNames.bind(styles$w);

var baseClass$V = 'upload-bar';

var UploadBarComponent = function (_React$PureComponent) {
  inherits(UploadBarComponent, _React$PureComponent);

  function UploadBarComponent() {
    var _temp, _this, _ret;

    classCallCheck(this, UploadBarComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args))), _this), _this.state = {
      isExpanded: false
    }, _this.getIsExpanded = function () {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.props;
      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this.state;
      return _this.isIsExpandedControlled() ? props.isExpanded : state.isExpanded;
    }, _this.getHeaderIcon = function () {
      var _this$props = _this.props,
          status = _this$props.status,
          percent = _this$props.percent;


      if (status === PROGRESS_STATUS.success) {
        return React.createElement(
          'div',
          { className: styles$w[baseClass$V + '__success-icon'] },
          React.createElement(CheckIcon, null)
        );
      }

      if (status === PROGRESS_STATUS.error) {
        return React.createElement(
          'div',
          { className: styles$w[baseClass$V + '__error-icon'] },
          React.createElement(AlertCircleIcon, { fill: '#f4574c' })
        );
      }

      return React.createElement(ProgressCircle, {
        status: status,
        percent: percent,
        size: PROGRESS_SIZE.small
      });
    }, _this.getHtmlProps = function () {
      var _this$props2 = _this.props,
          className = _this$props2.className,
          children = _this$props2.children,
          icon = _this$props2.icon,
          size = _this$props2.size,
          status = _this$props2.status,
          title = _this$props2.title,
          innerRef = _this$props2.innerRef,
          percent = _this$props2.percent,
          errorMessage = _this$props2.errorMessage,
          isExpanded = _this$props2.isExpanded,
          onCloseButtonClick = _this$props2.onCloseButtonClick,
          shouldExpandOnEndWithErrors = _this$props2.shouldExpandOnEndWithErrors,
          shouldCollapseOnEndWithSuccess = _this$props2.shouldCollapseOnEndWithSuccess,
          onCollapseButtonClick = _this$props2.onCollapseButtonClick,
          onRetryButtonClick = _this$props2.onRetryButtonClick,
          mode = _this$props2.mode,
          restProps = objectWithoutProperties(_this$props2, ['className', 'children', 'icon', 'size', 'status', 'title', 'innerRef', 'percent', 'errorMessage', 'isExpanded', 'onCloseButtonClick', 'shouldExpandOnEndWithErrors', 'shouldCollapseOnEndWithSuccess', 'onCollapseButtonClick', 'onRetryButtonClick', 'mode']);


      return restProps;
    }, _this.handleCollapseButtonClick = function (e) {
      e.stopPropagation();

      if (_this.isIsExpandedControlled()) {
        _this.props.onCollapseButtonClick(e);
      } else {
        _this.setState(function (prevState) {
          return {
            isExpanded: !prevState.isExpanded
          };
        });
      }
    }, _this.handleRetryButtonClick = function (e) {
      e.stopPropagation();
      _this.props.onRetryButtonClick(e);
    }, _this.handleCloseButtonClick = function (e) {
      e.stopPropagation();
      _this.props.onCloseButtonClick(e);
    }, _this.isIsExpandedControlled = function () {
      return _this.props.isExpanded !== undefined;
    }, _this.showDetailedView = function () {
      _this.setState({ isExpanded: true });
    }, _this.hideDetailedView = function () {
      _this.setState({ isExpanded: false });
    }, _this.renderActionIcons = function () {
      var _this$props3 = _this.props,
          mode = _this$props3.mode,
          status = _this$props3.status,
          onCloseButtonClick = _this$props3.onCloseButtonClick,
          onRetryButtonClick = _this$props3.onRetryButtonClick;


      var withError = status === PROGRESS_STATUS.error;

      if (!(withError && (onRetryButtonClick || onCloseButtonClick))) {
        if (mode !== UPLOAD_BAR_MODE.single) {
          return React.createElement(
            'button',
            {
              className: styles$w[baseClass$V + '__collapse-btn'],
              type: 'button',
              onClick: _this.handleCollapseButtonClick
            },
            React.createElement(CollapseIcon, { isExpanded: _this.getIsExpanded() })
          );
        }

        return null;
      }

      return React.createElement(
        'div',
        { className: styles$w[baseClass$V + '__actions'] },
        onRetryButtonClick && React.createElement(
          'button',
          {
            type: 'button',
            className: styles$w[baseClass$V + '__retry'],
            'aria-label': 'Retry',
            onClick: _this.handleRetryButtonClick
          },
          React.createElement(RefreshIcon, null)
        ),
        onCloseButtonClick && React.createElement(
          'button',
          {
            type: 'button',
            className: styles$w[baseClass$V + '__close'],
            'aria-label': 'Close',
            onClick: _this.handleCloseButtonClick
          },
          React.createElement(CloseIcon, null)
        )
      );
    }, _this.renderUploadBarSingleMode = function () {
      var _cx;

      var _this$props4 = _this.props,
          className = _this$props4.className,
          icon = _this$props4.icon,
          status = _this$props4.status,
          title = _this$props4.title,
          innerRef = _this$props4.innerRef,
          percent = _this$props4.percent,
          size = _this$props4.size,
          errorMessage = _this$props4.errorMessage;


      var htmlProps = _this.getHtmlProps();

      var withError = status === PROGRESS_STATUS.error;
      var withSuccess = status === PROGRESS_STATUS.success;

      var mergedClassNames = getMergedClassNames(cx$G(baseClass$V, baseClass$V + '--single', (_cx = {}, _cx[baseClass$V + '--error'] = withError, _cx[baseClass$V + '--success'] = withSuccess, _cx)), className);

      return React.createElement(
        'div',
        _extends({ ref: innerRef, className: mergedClassNames }, htmlProps),
        React.createElement(
          'div',
          {
            className: styles$w[baseClass$V + '__main'],
            onClick: _this.handleCollapseButtonClick
          },
          React.createElement(
            'div',
            { className: styles$w[baseClass$V + '__header'] },
            React.createElement(FileUploadProgress, {
              title: withError ? errorMessage || title : title,
              percent: percent,
              status: status,
              icon: icon,
              size: size
            })
          ),
          _this.renderActionIcons()
        )
      );
    }, _this.renderUploadBarMultipleMode = function () {
      var _cx2;

      var _this$props5 = _this.props,
          className = _this$props5.className,
          children = _this$props5.children,
          status = _this$props5.status,
          title = _this$props5.title,
          innerRef = _this$props5.innerRef,
          errorMessage = _this$props5.errorMessage;


      var htmlProps = _this.getHtmlProps();

      var withError = status === PROGRESS_STATUS.error;

      var mergedClassNames = getMergedClassNames(cx$G(baseClass$V, (_cx2 = {}, _cx2[baseClass$V + '--error'] = withError, _cx2)), className);

      return React.createElement(
        'div',
        _extends({ ref: innerRef, className: mergedClassNames }, htmlProps),
        React.createElement(
          'div',
          {
            className: styles$w[baseClass$V + '__main'],
            onClick: _this.handleCollapseButtonClick
          },
          React.createElement(
            'div',
            { className: styles$w[baseClass$V + '__header'] },
            _this.getHeaderIcon(),
            React.createElement(
              'div',
              { className: styles$w[baseClass$V + '__title'] },
              withError ? errorMessage || title : title
            )
          ),
          _this.renderActionIcons()
        ),
        React.createElement(
          reactTransitionGroup.TransitionGroup,
          { component: null },
          _this.getIsExpanded() && React.createElement(
            reactTransitionGroup.CSSTransition,
            {
              timeout: 300,
              classNames: {
                enter: styles$w[baseClass$V + '__files--enter'],
                enterActive: styles$w[baseClass$V + '__files--enter-active'],
                exit: styles$w[baseClass$V + '__files--exit'],
                exitActive: styles$w[baseClass$V + '__files--exit-active'],
                exitDone: styles$w[baseClass$V + '__files--exit-done']
              }
            },
            React.createElement(
              'div',
              { className: styles$w[baseClass$V + '__files'] },
              React.createElement(
                'div',
                { className: styles$w[baseClass$V + '__files-wrapper'] },
                React.createElement(
                  'div',
                  { className: styles$w[baseClass$V + '__list'] },
                  children
                )
              )
            )
          )
        )
      );
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  UploadBarComponent.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (!this.isIsExpandedControlled()) {
      if (this.props.shouldExpandOnEndWithErrors && prevProps.status !== PROGRESS_STATUS.error && this.props.status === PROGRESS_STATUS.error) {
        this.showDetailedView();
      }

      if (this.props.shouldCollapseOnEndWithSuccess && prevProps.status !== PROGRESS_STATUS.success && this.props.status === PROGRESS_STATUS.success) {
        this.hideDetailedView();
      }
    }
  };

  UploadBarComponent.prototype.render = function render() {
    if (this.props.mode === UPLOAD_BAR_MODE.single) {
      return this.renderUploadBarSingleMode();
    }

    return this.renderUploadBarMultipleMode();
  };

  return UploadBarComponent;
}(React.PureComponent);

var basePropTypes$1 = {
  className: PropTypes.string,
  /**
   * Error message visible when the status of the upload is equal 'error'
   */
  errorMessage: PropTypes.string,
  /**
   * Available in single mode, ie. svg file icon
   */
  icon: PropTypes.node,
  /**
   * `UploadBar`'s details visibility can be a controlled by `isExpanded` property. Any inside change (ie. click on the bar head) will trigger `onCollapseButtonClick` method
   * You can also use `UploadBar` without providing `isExpanded` property and it's state will be resolved with component's state
   */
  isExpanded: PropTypes.bool,
  /**
   * Multiple mode: use when user can upload a few files at the same time
   * Single mode: Useful on mobile devices or when upload of multiple files at the same time is not supported
   */
  mode: PropTypes.oneOf(UPLOAD_BAR_MODES),
  /**
   * Progress of upload presented on `ProgressCircle` (multiple mode) or `ProgressBar` (single mode)
   */
  percent: PropTypes.number.isRequired,
  /**
   * Available in single mode, the size of the `ProgressBar`
   */
  size: PropTypes.oneOf(PROGRESS_SIZES),
  /**
   * Available in multiple mode, when component isExpanded state is not controlled (`isExpanded` property is not defined)
   * When it's equal `true` `UploadBar` will expand and show details on upload end with error
   */
  shouldExpandOnEndWithErrors: PropTypes.bool,
  /**
   * Available in multiple mode, when component isExpanded state is not controlled (`isExpanded` property is not defined)
   * When it's equal `true` `UploadBar` will collapse and hide details on upload end with success
   */
  shouldCollapseOnEndWithSuccess: PropTypes.bool,
  /**
   * Multiple mode: Combined status of the upload
   * Single mode: Upload status of the file
   */
  status: PropTypes.oneOf(PROGRESS_STATUSES),
  /**
   * Multiple mode: Used to inform user about progress of the upload when UploadBar is collapsed
   * Single mode: Usually a file name
   */
  title: PropTypes.string.isRequired,
  /**
   * It's available when used together with `isExpanded` property.
   */
  onCollapseButtonClick: PropTypes.func,
  /**
   * Useful to cancel the file upload or to remove the file when it's upload resulted in an error
   * In the multiple mode it should be used to cancel all files
   * The button is visible when `status` property is equal 'error'
   */
  onCloseButtonClick: PropTypes.func,
  /**
   * Useful to retry the file upload
   * In the multiple mode it should be used to retry the upload of all files
   * The button is visible when `status` property is equal 'error'
   */
  onRetryButtonClick: PropTypes.func
};

var baseDefaultProps$1 = {
  mode: UPLOAD_BAR_MODE.multiple // eslint-disable-line react/default-props-match-prop-types,
};

process.env.NODE_ENV !== "production" ? UploadBarComponent.propTypes = _extends({}, basePropTypes$1, {
  innerRef: PropTypes.instanceOf(typeof Element === 'undefined' ? function () {} : Element)
}) : void 0;

UploadBarComponent.defaultProps = baseDefaultProps$1;

var UploadBar = React.forwardRef(function (props, ref) {
  return React.createElement(UploadBarComponent, _extends({ innerRef: ref }, props));
});

UploadBar.propTypes = basePropTypes$1;
UploadBar.defaultProps = baseDefaultProps$1;

var styles$y = { "search-bar__container": "lc-search-bar__container", "search-bar__icon": "lc-search-bar__icon", "search-bar__search-icon": "lc-search-bar__search-icon", "search-bar__search-icon--interactive": "lc-search-bar__search-icon--interactive", "search-bar__clear-icon": "lc-search-bar__clear-icon", "search-bar__clear-icon--hidden": "lc-search-bar__clear-icon--hidden", "search-bar__loader": "lc-search-bar__loader", "search-bar__input": "lc-search-bar__input", "search-bar__input--collapsed": "lc-search-bar__input--collapsed" };

var baseClass$W = 'search-bar';

var SearchBar = function (_React$PureComponent) {
  inherits(SearchBar, _React$PureComponent);

  function SearchBar(props) {
    classCallCheck(this, SearchBar);

    var _this = possibleConstructorReturn(this, _React$PureComponent.call(this, props));

    _this.handleChange = function (event) {
      var value = event.target.value;
      var _this$props = _this.props,
          debounceTime = _this$props.debounceTime,
          onChange = _this$props.onChange;


      _this.setState({
        searchTerm: value
      });

      if (debounceTime) {
        _this.debouncedOnChange(value);
        return;
      }

      if (onChange) {
        onChange(value);
      }
    };

    _this.handleKeyPress = function (event) {
      var _this$props2 = _this.props,
          onSubmit = _this$props2.onSubmit,
          onKeyDown = _this$props2.onKeyDown;


      if (onKeyDown) {
        onKeyDown(event);
      }

      if (onSubmit) {
        if (event.keyCode === KeyCodes.enter) {
          onSubmit(_this.state.searchTerm);
        }
      }
    };

    _this.handleClear = function () {
      var _this$props3 = _this.props,
          onChange = _this$props3.onChange,
          onSubmit = _this$props3.onSubmit,
          onClear = _this$props3.onClear;

      var searchFunction = onClear || onSubmit || onChange;

      _this.setState({
        searchTerm: ''
      });

      searchFunction('');

      if (_this.inputRef.current) {
        _this.inputRef.current.focus();
      }
    };

    _this.handleClearButtonKeyDown = function (event) {
      if (event.keyCode === KeyCodes.enter) {
        _this.handleClear();
      }
    };

    _this.handleBlur = function (event) {
      if (_this.props.onBlur) {
        _this.props.onBlur(event);
      }

      if (_this.props.collapseOnBlur) {
        _this.setState({
          isCollapsed: true
        }, function () {
          if (_this.props.onCollapse) {
            _this.props.onCollapse();
          }
        });
      }
    };

    _this.handleFocus = function (event) {
      if (_this.props.onFocus) {
        _this.props.onFocus(event);
      }

      if (_this.props.expandOnFocus) {
        _this.setState({
          isCollapsed: false
        }, function () {
          if (_this.inputRef.current) {
            _this.inputRef.current.focus();
          }

          if (_this.props.onExpand) {
            _this.props.onExpand();
          }
        });
      }
    };

    _this.toggleSearchBarMode = function () {
      _this.setState(function (prevState) {
        return {
          isCollapsed: !!_this.props.collapsable && !prevState.isCollapsed
        };
      }, function () {
        if (_this.state.isCollapsed && _this.props.onCollapse) {
          _this.props.onCollapse();
        }

        if (!_this.state.isCollapsed) {
          if (_this.inputRef.current) {
            _this.inputRef.current.focus();
          }

          if (_this.props.onExpand) {
            _this.props.onExpand();
          }
        }
      });
    };

    _this.inputRef = React.createRef();
    if (_this.props.debounceTime) {
      _this.debouncedOnChange = debounce(function (value) {
        _this.props.onChange(value);
      }, _this.props.debounceTime);
    }

    _this.state = {
      searchTerm: props.value || '',
      isCollapsed: props.collapsable
    };
    return _this;
  }

  SearchBar.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this.debouncedOnChange) {
      this.debouncedOnChange.cancel();
    }
  };

  SearchBar.prototype.render = function render() {
    var _cx, _cx2, _cx3;

    var _props = this.props,
        className = _props.className,
        placeholder = _props.placeholder,
        value = _props.value,
        loading = _props.loading,
        collapsable = _props.collapsable,
        error = _props.error,
        debounceTime = _props.debounceTime,
        collapseOnBlur = _props.collapseOnBlur,
        expandOnFocus = _props.expandOnFocus,
        onClear = _props.onClear,
        onSubmit = _props.onSubmit,
        onChange = _props.onChange,
        onKeyDown = _props.onKeyDown,
        onCollapse = _props.onCollapse,
        onExpand = _props.onExpand,
        onBlur = _props.onBlur,
        onFocus = _props.onFocus,
        forwardedRef = _props.forwardedRef,
        restProps = objectWithoutProperties(_props, ['className', 'placeholder', 'value', 'loading', 'collapsable', 'error', 'debounceTime', 'collapseOnBlur', 'expandOnFocus', 'onClear', 'onSubmit', 'onChange', 'onKeyDown', 'onCollapse', 'onExpand', 'onBlur', 'onFocus', 'forwardedRef']);
    var _state = this.state,
        searchTerm = _state.searchTerm,
        isCollapsed = _state.isCollapsed;


    var shouldDisplayClearButton = searchTerm && !loading && !isCollapsed;

    var searchIconClassName = cx(['lc-' + baseClass$W + '__icon', 'lc-' + baseClass$W + '__search-icon'], (_cx = {}, _cx['lc-' + baseClass$W + '__search-icon--interactive'] = collapsable, _cx));

    var inputClassName = cx('lc-' + baseClass$W + '__input', (_cx2 = {}, _cx2['lc-' + baseClass$W + '__input--collapsed'] = isCollapsed, _cx2));

    var closeIconClassName = cx(['lc-' + baseClass$W + '__icon', 'lc-' + baseClass$W + '__clear-icon'], (_cx3 = {}, _cx3['lc-' + baseClass$W + '__clear-icon--hidden'] = !shouldDisplayClearButton, _cx3));

    return React.createElement(
      'div',
      _extends({ className: className, ref: forwardedRef }, restProps),
      React.createElement(
        'div',
        { className: styles$y[baseClass$W + '__container'] },
        React.createElement(SearchIcon, {
          width: '18px',
          height: '18px',
          className: searchIconClassName,
          onClick: this.toggleSearchBarMode
        }),
        loading && React.createElement(Loader, {
          size: 'small',
          className: cx(['lc-' + baseClass$W + '__icon', 'lc-' + baseClass$W + '__loader'])
        }),
        React.createElement(Input, {
          placeholder: placeholder,
          ref: this.inputRef,
          value: value != null ? value : this.state.searchTerm,
          onChange: this.handleChange,
          onFocus: this.handleFocus,
          onBlur: this.handleBlur,
          onKeyDown: this.handleKeyPress,
          className: inputClassName,
          'data-testid': 'search-input'
        }),
        React.createElement(CloseIcon, {
          width: '18px',
          height: '18px',
          onClick: shouldDisplayClearButton ? this.handleClear : null,
          onKeyDown: shouldDisplayClearButton ? this.handleClearButtonKeyDown : null,
          className: closeIconClassName,
          tabIndex: '0',
          'data-testid': 'close-button'
        })
      ),
      error && React.createElement(
        FieldError,
        null,
        error
      )
    );
  };

  return SearchBar;
}(React.PureComponent);

process.env.NODE_ENV !== "production" ? SearchBar.propTypes = {
  className: PropTypes.string,
  placeholder: PropTypes.string,
  /**
   * Pass this prop if you want to control searchbar term from parent component
   */
  value: PropTypes.string,
  loading: PropTypes.bool,
  /**
   * Pass collapsable if you want to display extendable searchbar (usually for smaller screens)
   */
  collapsable: PropTypes.bool,
  /**
   * Use if you want to collapse the component on blur
   */
  collapseOnBlur: PropTypes.bool,
  /**
   * Use if you want to expand the component on focus
   */
  expandOnFocus: PropTypes.bool,
  /**
   * Pass value in `ms` along with `onChange` handler if you want to query by specific number of ms
   */
  debounceTime: PropTypes.number,
  error: PropTypes.string,
  onChange: PropTypes.func,
  onSubmit: PropTypes.func,
  onClear: PropTypes.func,
  /**
   * Pass onKeyDown function if you want to use event props for example event.preventDefault()
   */
  onKeyDown: PropTypes.func,
  onCollapse: PropTypes.func,
  onExpand: PropTypes.func,
  onFocus: PropTypes.func,
  onBlur: PropTypes.func,
  forwardedRef: PropTypes.oneOfType([PropTypes.func, PropTypes.shape({ current: PropTypes.any })])
} : void 0;

SearchBar.defaultProps = {
  placeholder: 'Search...',
  debounceTime: 0
};

/* eslint prefer-arrow-callback: ["error", { "allowNamedFunctions": true }] */
var SearchBar$1 = React.forwardRef(function SearchBarWithRef(props, ref) {
  return React.createElement(SearchBar, _extends({}, props, { forwardedRef: ref }));
});

var _IconSize, _IconColorMapper, _IconColorDisabledMap;

var IconSizeName = {
  XSmall: 'xsmall',
  Small: 'small',
  Medium: 'medium',
  Large: 'large',
  XLarge: 'xlarge'
};

var IconSize = (_IconSize = {}, _IconSize[IconSizeName.XSmall] = {
  width: 12,
  height: 12
}, _IconSize[IconSizeName.Small] = {
  width: 16,
  height: 16
}, _IconSize[IconSizeName.Medium] = {
  width: 20,
  height: 20
}, _IconSize[IconSizeName.Large] = {
  width: 24,
  height: 24
}, _IconSize[IconSizeName.XLarge] = {
  width: 32,
  height: 32
}, _IconSize);

var IconTypeName = {
  Primary: 'primary',
  Inverted: 'inverted',
  Link: 'link',
  Success: 'success',
  Warning: 'warning',
  Error: 'error'
};

var IconColorMapper = (_IconColorMapper = {}, _IconColorMapper[IconTypeName.Primary] = '#424d57', _IconColorMapper[IconTypeName.Inverted] = '#fff', _IconColorMapper[IconTypeName.Link] = '#4384f5', _IconColorMapper[IconTypeName.Success] = '#4bb678', _IconColorMapper[IconTypeName.Warning] = '#efa842', _IconColorMapper[IconTypeName.Error] = '#d64646', _IconColorMapper);

var IconColorDisabledMapper = (_IconColorDisabledMap = {}, _IconColorDisabledMap[IconTypeName.Primary] = '#686d72', _IconColorDisabledMap[IconTypeName.Inverted] = '#dbdbdb', _IconColorDisabledMap[IconTypeName.Link] = '#c3d7fa', _IconColorDisabledMap[IconTypeName.Success] = '#4bb678', _IconColorDisabledMap[IconTypeName.Warning] = '#efa842', _IconColorDisabledMap[IconTypeName.Error] = '#d64646', _IconColorDisabledMap);

var Icon = function Icon(props) {
  var source = props.source,
      _props$size = props.size,
      size = _props$size === undefined ? IconSizeName.Medium : _props$size,
      _props$iconType = props.iconType,
      iconType = _props$iconType === undefined ? IconTypeName.Primary : _props$iconType,
      disabled = props.disabled,
      className = props.className,
      restProps = objectWithoutProperties(props, ['source', 'size', 'iconType', 'disabled', 'className']);

  var filledColor = IconColorMapper[iconType];

  if (disabled) {
    filledColor = IconColorDisabledMapper[iconType];
  }

  var GeneratedIcon = React.createElement(source, _extends({}, IconSize[size], {
    fill: filledColor
  }));

  return React.createElement(
    'span',
    _extends({}, restProps, { className: className }),
    GeneratedIcon
  );
};
process.env.NODE_ENV !== "production" ? Icon.propTypes = {
  /**
   * Icon passed in svg format ie. `source={require('svg_icon')}
   */
  source: PropTypes.func.isRequired,
  /**
   * Defines width and height of the icon
   */
  size: PropTypes.oneOf(['xsmall', 'small', 'medium', 'large', 'xlarge']),
  /**
   * Adjusts color of the icon (if passed)
   */
  disabled: PropTypes.bool,
  iconType: PropTypes.oneOf(['primary', 'inverted', 'link', 'success', 'warning', 'error']),
  className: PropTypes.string
} : void 0;

var helpers = {
  generateNotificationUniqueId: generateNotificationUniqueId,
  callAll: callAll,
  getMergedClassNames: getMergedClassNames
};

exports.helpers = helpers;
exports.Button = Button;
exports.ButtonGroup = ButtonGroup;
exports.Banner = Banner;
exports.Card = Card;
exports.Tab = Tab;
exports.TabsWrapper = TabsWrapper;
exports.TabsList = TabsList;
exports.Tooltip = Tooltip;
exports.TooltipContent = TooltipContent;
exports.Toast = Toast;
exports.ToastWrapper = ToastWrapper;
exports.NotificationProvider = NotificationProvider;
exports.ToastConsumer = ToastConsumer;
exports.NotificationContext = NotificationContext;
exports.notificationConnect = notificationConnect;
exports.ModalBase = ModalBase;
exports.ModalPortal = ModalPortal;
exports.ActionModal = ActionModal;
exports.ActionModalActions = ActionModalActions;
exports.ActionModalContent = ActionModalContent;
exports.ActionModalHeading = ActionModalHeading;
exports.ActionModalIcon = ActionModalIcon;
exports.Modal = Modal;
exports.ModalFooter = ModalFooter;
exports.ModalHeader = ModalHeader;
exports.ModalBody = ModalBody;
exports.TextField = TextField;
exports.Input = Input;
exports.InputField = InputField;
exports.TextArea = TextArea;
exports.TextAreaField = TextAreaField;
exports.RadioButton = RadioButton;
exports.CheckboxField = CheckboxField;
exports.Form = Form;
exports.FormGroup = FormGroup;
exports.FieldGroup = FieldGroup;
exports.FieldError = FieldError;
exports.FieldLabel = FieldLabel;
exports.FieldDescription = FieldDescription;
exports.Select = Select;
exports.SelectField = SelectField;
exports.MultiSelect = MultiSelect;
exports.MultiSelectField = MultiSelectField;
exports.NumericInput = NumericInput;
exports.NumericInputField = NumericInputField;
exports.DatePicker = DatePicker$1;
exports.RangeDatePicker = RangeDatePicker;
exports.DatePickerRangeSelectInputs = DatePickerRangeSelectInputs;
exports.DatePickerRangeCalendarsWrapper = DatePickerRangeCalendarsWrapper;
exports.Switch = Switch;
exports.InAppMessageBase = InAppMessageBase;
exports.InAppMessagePortal = InAppMessagePortal;
exports.InAppMessage = InAppMessage;
exports.InAppMessageFooter = InAppMessageFooter;
exports.InAppMessageHeader = InAppMessageHeader;
exports.InAppMessageBody = InAppMessageBody;
exports.Badge = Badge;
exports.Dropdown = Dropdown;
exports.DropdownList = DropdownList;
exports.DropdownListItem = DropdownListItem;
exports.PopperTooltip = PopperTooltip;
exports.CssTooltip = CssTooltip;
exports.UserGuideTooltip = UserGuideTooltip;
exports.Loader = Loader;
exports.Divider = Divider;
exports.ProgressBar = ProgressBar;
exports.ProgressCircle = ProgressCircle;
exports.Promo = Promo;
exports.UploadBar = UploadBar;
exports.FileUploadProgress = FileUploadProgress;
exports.SearchBar = SearchBar$1;
exports.Icon = Icon;
exports.IconSize = IconSizeName;
exports.IconType = IconTypeName;
